%!PS-Adobe-2.0
%%Creator: dvips(k) 5.95a Copyright 2005 Radical Eye Software
%%Title: iverson2016.sol.dvi
%%Pages: 14
%%PageOrder: Ascend
%%BoundingBox: 0 0 595 842
%%DocumentFonts: CMBX12 CMR12 CMTT12 CMR10 CMSL12 CMSY10 CMMI12 CMTI12
%%+ CMTT10 CMEX10
%%DocumentPaperSizes: a4
%%EndComments
%DVIPSWebPage: (www.radicaleye.com)
%DVIPSCommandLine: dvips -D 1000 iverson2016.sol
%DVIPSParameters: dpi=1000
%DVIPSSource:  TeX output 2016.06.03:1046
%%BeginProcSet: tex.pro 0 0
%!
/TeXDict 300 dict def TeXDict begin/N{def}def/B{bind def}N/S{exch}N/X{S
N}B/A{dup}B/TR{translate}N/isls false N/vsize 11 72 mul N/hsize 8.5 72
mul N/landplus90{false}def/@rigin{isls{[0 landplus90{1 -1}{-1 1}ifelse 0
0 0]concat}if 72 Resolution div 72 VResolution div neg scale isls{
landplus90{VResolution 72 div vsize mul 0 exch}{Resolution -72 div hsize
mul 0}ifelse TR}if Resolution VResolution vsize -72 div 1 add mul TR[
matrix currentmatrix{A A round sub abs 0.00001 lt{round}if}forall round
exch round exch]setmatrix}N/@landscape{/isls true N}B/@manualfeed{
statusdict/manualfeed true put}B/@copies{/#copies X}B/FMat[1 0 0 -1 0 0]
N/FBB[0 0 0 0]N/nn 0 N/IEn 0 N/ctr 0 N/df-tail{/nn 8 dict N nn begin
/FontType 3 N/FontMatrix fntrx N/FontBBox FBB N string/base X array
/BitMaps X/BuildChar{CharBuilder}N/Encoding IEn N end A{/foo setfont}2
array copy cvx N load 0 nn put/ctr 0 N[}B/sf 0 N/df{/sf 1 N/fntrx FMat N
df-tail}B/dfs{div/sf X/fntrx[sf 0 0 sf neg 0 0]N df-tail}B/E{pop nn A
definefont setfont}B/Cw{Cd A length 5 sub get}B/Ch{Cd A length 4 sub get
}B/Cx{128 Cd A length 3 sub get sub}B/Cy{Cd A length 2 sub get 127 sub}
B/Cdx{Cd A length 1 sub get}B/Ci{Cd A type/stringtype ne{ctr get/ctr ctr
1 add N}if}B/CharBuilder{save 3 1 roll S A/base get 2 index get S
/BitMaps get S get/Cd X pop/ctr 0 N Cdx 0 Cx Cy Ch sub Cx Cw add Cy
setcachedevice Cw Ch true[1 0 0 -1 -.1 Cx sub Cy .1 sub]{Ci}imagemask
restore}B/D{/cc X A type/stringtype ne{]}if nn/base get cc ctr put nn
/BitMaps get S ctr S sf 1 ne{A A length 1 sub A 2 index S get sf div put
}if put/ctr ctr 1 add N}B/I{cc 1 add D}B/bop{userdict/bop-hook known{
bop-hook}if/SI save N @rigin 0 0 moveto/V matrix currentmatrix A 1 get A
mul exch 0 get A mul add .99 lt{/QV}{/RV}ifelse load def pop pop}N/eop{
SI restore userdict/eop-hook known{eop-hook}if showpage}N/@start{
userdict/start-hook known{start-hook}if pop/VResolution X/Resolution X
1000 div/DVImag X/IEn 256 array N 2 string 0 1 255{IEn S A 360 add 36 4
index cvrs cvn put}for pop 65781.76 div/vsize X 65781.76 div/hsize X}N
/p{show}N/RMat[1 0 0 -1 0 0]N/BDot 260 string N/Rx 0 N/Ry 0 N/V{}B/RV/v{
/Ry X/Rx X V}B statusdict begin/product where{pop false[(Display)(NeXT)
(LaserWriter 16/600)]{A length product length le{A length product exch 0
exch getinterval eq{pop true exit}if}{pop}ifelse}forall}{false}ifelse
end{{gsave TR -.1 .1 TR 1 1 scale Rx Ry false RMat{BDot}imagemask
grestore}}{{gsave TR -.1 .1 TR Rx Ry scale 1 1 false RMat{BDot}
imagemask grestore}}ifelse B/QV{gsave newpath transform round exch round
exch itransform moveto Rx 0 rlineto 0 Ry neg rlineto Rx neg 0 rlineto
fill grestore}B/a{moveto}B/delta 0 N/tail{A/delta X 0 rmoveto}B/M{S p
delta add tail}B/b{S p tail}B/c{-4 M}B/d{-3 M}B/e{-2 M}B/f{-1 M}B/g{0 M}
B/h{1 M}B/i{2 M}B/j{3 M}B/k{4 M}B/w{0 rmoveto}B/l{p -4 w}B/m{p -3 w}B/n{
p -2 w}B/o{p -1 w}B/q{p 1 w}B/r{p 2 w}B/s{p 3 w}B/t{p 4 w}B/x{0 S
rmoveto}B/y{3 2 roll p a}B/bos{/SS save N}B/eos{SS restore}B end

%%EndProcSet
%%BeginProcSet: texps.pro 0 0
%!
TeXDict begin/rf{findfont dup length 1 add dict begin{1 index/FID ne 2
index/UniqueID ne and{def}{pop pop}ifelse}forall[1 index 0 6 -1 roll
exec 0 exch 5 -1 roll VResolution Resolution div mul neg 0 0]FontType 0
ne{/Metrics exch def dict begin Encoding{exch dup type/integertype ne{
pop pop 1 sub dup 0 le{pop}{[}ifelse}{FontMatrix 0 get div Metrics 0 get
div def}ifelse}forall Metrics/Metrics currentdict end def}{{1 index type
/nametype eq{exit}if exch pop}loop}ifelse[2 index currentdict end
definefont 3 -1 roll makefont/setfont cvx]cvx def}def/ObliqueSlant{dup
sin S cos div neg}B/SlantFont{4 index mul add}def/ExtendFont{3 -1 roll
mul exch}def/ReEncodeFont{CharStrings rcheck{/Encoding false def dup[
exch{dup CharStrings exch known not{pop/.notdef/Encoding true def}if}
forall Encoding{]exch pop}{cleartomark}ifelse}if/Encoding exch def}def
end

%%EndProcSet
%%BeginProcSet: special.pro 0 0
%!
TeXDict begin/SDict 200 dict N SDict begin/@SpecialDefaults{/hs 612 N
/vs 792 N/ho 0 N/vo 0 N/hsc 1 N/vsc 1 N/ang 0 N/CLIP 0 N/rwiSeen false N
/rhiSeen false N/letter{}N/note{}N/a4{}N/legal{}N}B/@scaleunit 100 N
/@hscale{@scaleunit div/hsc X}B/@vscale{@scaleunit div/vsc X}B/@hsize{
/hs X/CLIP 1 N}B/@vsize{/vs X/CLIP 1 N}B/@clip{/CLIP 2 N}B/@hoffset{/ho
X}B/@voffset{/vo X}B/@angle{/ang X}B/@rwi{10 div/rwi X/rwiSeen true N}B
/@rhi{10 div/rhi X/rhiSeen true N}B/@llx{/llx X}B/@lly{/lly X}B/@urx{
/urx X}B/@ury{/ury X}B/magscale true def end/@MacSetUp{userdict/md known
{userdict/md get type/dicttype eq{userdict begin md length 10 add md
maxlength ge{/md md dup length 20 add dict copy def}if end md begin
/letter{}N/note{}N/legal{}N/od{txpose 1 0 mtx defaultmatrix dtransform S
atan/pa X newpath clippath mark{transform{itransform moveto}}{transform{
itransform lineto}}{6 -2 roll transform 6 -2 roll transform 6 -2 roll
transform{itransform 6 2 roll itransform 6 2 roll itransform 6 2 roll
curveto}}{{closepath}}pathforall newpath counttomark array astore/gc xdf
pop ct 39 0 put 10 fz 0 fs 2 F/|______Courier fnt invertflag{PaintBlack}
if}N/txpose{pxs pys scale ppr aload pop por{noflips{pop S neg S TR pop 1
-1 scale}if xflip yflip and{pop S neg S TR 180 rotate 1 -1 scale ppr 3
get ppr 1 get neg sub neg ppr 2 get ppr 0 get neg sub neg TR}if xflip
yflip not and{pop S neg S TR pop 180 rotate ppr 3 get ppr 1 get neg sub
neg 0 TR}if yflip xflip not and{ppr 1 get neg ppr 0 get neg TR}if}{
noflips{TR pop pop 270 rotate 1 -1 scale}if xflip yflip and{TR pop pop
90 rotate 1 -1 scale ppr 3 get ppr 1 get neg sub neg ppr 2 get ppr 0 get
neg sub neg TR}if xflip yflip not and{TR pop pop 90 rotate ppr 3 get ppr
1 get neg sub neg 0 TR}if yflip xflip not and{TR pop pop 270 rotate ppr
2 get ppr 0 get neg sub neg 0 S TR}if}ifelse scaleby96{ppr aload pop 4
-1 roll add 2 div 3 1 roll add 2 div 2 copy TR .96 dup scale neg S neg S
TR}if}N/cp{pop pop showpage pm restore}N end}if}if}N/normalscale{
Resolution 72 div VResolution 72 div neg scale magscale{DVImag dup scale
}if 0 setgray}N/psfts{S 65781.76 div N}N/startTexFig{/psf$SavedState
save N userdict maxlength dict begin/magscale true def normalscale
currentpoint TR/psf$ury psfts/psf$urx psfts/psf$lly psfts/psf$llx psfts
/psf$y psfts/psf$x psfts currentpoint/psf$cy X/psf$cx X/psf$sx psf$x
psf$urx psf$llx sub div N/psf$sy psf$y psf$ury psf$lly sub div N psf$sx
psf$sy scale psf$cx psf$sx div psf$llx sub psf$cy psf$sy div psf$ury sub
TR/showpage{}N/erasepage{}N/setpagedevice{pop}N/copypage{}N/p 3 def
@MacSetUp}N/doclip{psf$llx psf$lly psf$urx psf$ury currentpoint 6 2 roll
newpath 4 copy 4 2 roll moveto 6 -1 roll S lineto S lineto S lineto
closepath clip newpath moveto}N/endTexFig{end psf$SavedState restore}N
/@beginspecial{SDict begin/SpecialSave save N gsave normalscale
currentpoint TR @SpecialDefaults count/ocount X/dcount countdictstack N}
N/@setspecial{CLIP 1 eq{newpath 0 0 moveto hs 0 rlineto 0 vs rlineto hs
neg 0 rlineto closepath clip}if ho vo TR hsc vsc scale ang rotate
rwiSeen{rwi urx llx sub div rhiSeen{rhi ury lly sub div}{dup}ifelse
scale llx neg lly neg TR}{rhiSeen{rhi ury lly sub div dup scale llx neg
lly neg TR}if}ifelse CLIP 2 eq{newpath llx lly moveto urx lly lineto urx
ury lineto llx ury lineto closepath clip}if/showpage{}N/erasepage{}N
/setpagedevice{pop}N/copypage{}N newpath}N/@endspecial{count ocount sub{
pop}repeat countdictstack dcount sub{end}repeat grestore SpecialSave
restore end}N/@defspecial{SDict begin}N/@fedspecial{end}B/li{lineto}B
/rl{rlineto}B/rc{rcurveto}B/np{/SaveX currentpoint/SaveY X N 1
setlinecap newpath}N/st{stroke SaveX SaveY moveto}N/fil{fill SaveX SaveY
moveto}N/ellipse{/endangle X/startangle X/yrad X/xrad X/savematrix
matrix currentmatrix N TR xrad yrad scale 0 0 1 startangle endangle arc
savematrix setmatrix}N end

%%EndProcSet
%%BeginProcSet: color.pro 0 0
%!
TeXDict begin/setcmykcolor where{pop}{/setcmykcolor{dup 10 eq{pop
setrgbcolor}{1 sub 4 1 roll 3{3 index add neg dup 0 lt{pop 0}if 3 1 roll
}repeat setrgbcolor pop}ifelse}B}ifelse/TeXcolorcmyk{setcmykcolor}def
/TeXcolorrgb{setrgbcolor}def/TeXcolorgrey{setgray}def/TeXcolorgray{
setgray}def/TeXcolorhsb{sethsbcolor}def/currentcmykcolor where{pop}{
/currentcmykcolor{currentrgbcolor 10}B}ifelse/DC{exch dup userdict exch
known{pop pop}{X}ifelse}B/GreenYellow{0.15 0 0.69 0 setcmykcolor}DC
/Yellow{0 0 1 0 setcmykcolor}DC/Goldenrod{0 0.10 0.84 0 setcmykcolor}DC
/Dandelion{0 0.29 0.84 0 setcmykcolor}DC/Apricot{0 0.32 0.52 0
setcmykcolor}DC/Peach{0 0.50 0.70 0 setcmykcolor}DC/Melon{0 0.46 0.50 0
setcmykcolor}DC/YellowOrange{0 0.42 1 0 setcmykcolor}DC/Orange{0 0.61
0.87 0 setcmykcolor}DC/BurntOrange{0 0.51 1 0 setcmykcolor}DC
/Bittersweet{0 0.75 1 0.24 setcmykcolor}DC/RedOrange{0 0.77 0.87 0
setcmykcolor}DC/Mahogany{0 0.85 0.87 0.35 setcmykcolor}DC/Maroon{0 0.87
0.68 0.32 setcmykcolor}DC/BrickRed{0 0.89 0.94 0.28 setcmykcolor}DC/Red{
0 1 1 0 setcmykcolor}DC/OrangeRed{0 1 0.50 0 setcmykcolor}DC/RubineRed{
0 1 0.13 0 setcmykcolor}DC/WildStrawberry{0 0.96 0.39 0 setcmykcolor}DC
/Salmon{0 0.53 0.38 0 setcmykcolor}DC/CarnationPink{0 0.63 0 0
setcmykcolor}DC/Magenta{0 1 0 0 setcmykcolor}DC/VioletRed{0 0.81 0 0
setcmykcolor}DC/Rhodamine{0 0.82 0 0 setcmykcolor}DC/Mulberry{0.34 0.90
0 0.02 setcmykcolor}DC/RedViolet{0.07 0.90 0 0.34 setcmykcolor}DC
/Fuchsia{0.47 0.91 0 0.08 setcmykcolor}DC/Lavender{0 0.48 0 0
setcmykcolor}DC/Thistle{0.12 0.59 0 0 setcmykcolor}DC/Orchid{0.32 0.64 0
0 setcmykcolor}DC/DarkOrchid{0.40 0.80 0.20 0 setcmykcolor}DC/Purple{
0.45 0.86 0 0 setcmykcolor}DC/Plum{0.50 1 0 0 setcmykcolor}DC/Violet{
0.79 0.88 0 0 setcmykcolor}DC/RoyalPurple{0.75 0.90 0 0 setcmykcolor}DC
/BlueViolet{0.86 0.91 0 0.04 setcmykcolor}DC/Periwinkle{0.57 0.55 0 0
setcmykcolor}DC/CadetBlue{0.62 0.57 0.23 0 setcmykcolor}DC
/CornflowerBlue{0.65 0.13 0 0 setcmykcolor}DC/MidnightBlue{0.98 0.13 0
0.43 setcmykcolor}DC/NavyBlue{0.94 0.54 0 0 setcmykcolor}DC/RoyalBlue{1
0.50 0 0 setcmykcolor}DC/Blue{1 1 0 0 setcmykcolor}DC/Cerulean{0.94 0.11
0 0 setcmykcolor}DC/Cyan{1 0 0 0 setcmykcolor}DC/ProcessBlue{0.96 0 0 0
setcmykcolor}DC/SkyBlue{0.62 0 0.12 0 setcmykcolor}DC/Turquoise{0.85 0
0.20 0 setcmykcolor}DC/TealBlue{0.86 0 0.34 0.02 setcmykcolor}DC
/Aquamarine{0.82 0 0.30 0 setcmykcolor}DC/BlueGreen{0.85 0 0.33 0
setcmykcolor}DC/Emerald{1 0 0.50 0 setcmykcolor}DC/JungleGreen{0.99 0
0.52 0 setcmykcolor}DC/SeaGreen{0.69 0 0.50 0 setcmykcolor}DC/Green{1 0
1 0 setcmykcolor}DC/ForestGreen{0.91 0 0.88 0.12 setcmykcolor}DC
/PineGreen{0.92 0 0.59 0.25 setcmykcolor}DC/LimeGreen{0.50 0 1 0
setcmykcolor}DC/YellowGreen{0.44 0 0.74 0 setcmykcolor}DC/SpringGreen{
0.26 0 0.76 0 setcmykcolor}DC/OliveGreen{0.64 0 0.95 0.40 setcmykcolor}
DC/RawSienna{0 0.72 1 0.45 setcmykcolor}DC/Sepia{0 0.83 1 0.70
setcmykcolor}DC/Brown{0 0.81 1 0.60 setcmykcolor}DC/Tan{0.14 0.42 0.56 0
setcmykcolor}DC/Gray{0 0 0 0.50 setcmykcolor}DC/Black{0 0 0 1
setcmykcolor}DC/White{0 0 0 0 setcmykcolor}DC end

%%EndProcSet
%%BeginFont: CMEX10
%!PS-AdobeFont-1.1: CMEX10 1.00
%%CreationDate: 1992 Jul 23 21:22:48
% Copyright (C) 1997 American Mathematical Society. All Rights Reserved.
11 dict begin
/FontInfo 7 dict dup begin
/version (1.00) readonly def
/Notice (Copyright (C) 1997 American Mathematical Society. All Rights Reserved) readonly def
/FullName (CMEX10) readonly def
/FamilyName (Computer Modern) readonly def
/Weight (Medium) readonly def
/ItalicAngle 0 def
/isFixedPitch false def
end readonly def
/FontName /CMEX10 def
/PaintType 0 def
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0] readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 40 /braceleftBigg put
dup 41 /bracerightBigg put
readonly def
/FontBBox{-24 -2960 1454 772}readonly def
currentdict end
currentfile eexec
D9D66F633B846A97B686A97E45A3D0AA052A014267B7904EB3C0D3BD0B83D891
016CA6CA4B712ADEB258FAAB9A130EE605E61F77FC1B738ABC7C51CD46EF8171
9098D5FEE67660E69A7AB91B58F29A4D79E57022F783EB0FBBB6D4F4EC35014F
D2DECBA99459A4C59DF0C6EBA150284454E707DC2100C15B76B4C19B84363758
469A6C558785B226332152109871A9883487DD7710949204DDCF837E6A8708B8
2BDBF16FBC7512FAA308A093FE5CF5B8CAC6A7BEB5D02276E511FFAF2AE11910
DE076F24311D94D07CACC323F360887F1EA11BDDA7927FF3325986FDB0ABDFC8
8E4B40E7988921D551EC0867EBCA44C05657F0DC913E7B3004A5F3E1337B6987
FEBC45F989C8DC6DC0AD577E903F05D0D54208A0AE7F28C734F130C133B48422
BED48639A2B74E4C08F2E710E24A99F347E0F4394CE64EACB549576E89044E52
EABE595BC964156D9D8C2BAB0F49664E951D7C1A3D1789C47F03C7051A63D5E8
DF04FAAC47351E82CAE0794AA9692C6452688A74A7A6A7AD09B8A9783C235EC1
EA2156261B8FB331827145DE315B6EC1B3D8B67B3323F761EAF4C223BB214C4C
6B062D1B281F5041D068319F4911058376D8EFBA59884BA3318C5BC95684F281
E0591BC0D1B2A4592A137FF301610019B8AC46AE6E48BC091E888E4487688350
E9AD5074EE4848271CE4ACC38D8CBC8F3DB32813DDD5B341AF9A6601281ABA38
4A978B98483A63FCC458D0E3BCE6FD830E7E09B0DB987A6B63B74638FC9F21A5
8C68479E1A85225670D79CDDE5AC0B77F5A994CA700B5F0FF1F97FC63EFDE023
8135F04A9D20C31998B12AE06676C362141AAAA395CDEF0A49E0141D335965F2
FB4198499799CECCC8AA5D255264784CD30A3E8295888EFBC2060ADDD7BAC45A
EEEECDFF7A47A88E69D84C9E572616C1AC69A34B5F0D0DE8EE4EDF9F4ADE0387
680924D8D5B73EF04EAD7F45977CA8AD73D4DD45DE1966A3B8251C0386164C35
5880DD2609C80E96D1AB861C9259748E98F6711D4E241A269ED51FF328344664
3AF9F18DCE671611DB2F5D3EA77EE734D2BED623F973E6840B8DAD1E2C3C2666
DD4DD1C1C9C622FAEAB9D3E54476B49A2A026565F10A840322879C22C63777A6
E26E1BABA0F629CCA2C5464B2675AB61BB20305FA32443EFC9F0E3CCFA7E5F81
E60CAB78F60E272040B932FBBFA1785CD4049FDBFD652E60FE7C1101ED3F4417
C4189B3C45BCFD0E42CAADF391BF194C89CAB7CF693D360F240F5469C187830E
72394C6574E14292EE122AA07C19283A11D626A9A52B59EB37DBFC183A457B2C
0018C6B109969D9DDF89B250DD1C209445B08997FDC4B4597AAF9FB7A8ABABAE
00ED058CB798E57D0BC850078FCDA3D07D2734DD3A90A380D4B5D851BD23EDBB
D75820E12396581C5850CD9BBE6550B3DEEBA7AA6A85CAB1115EBA877F4921CB
959147FE310B0954B533C1DC320911504B3912A6DE2F525014CC3843506E48DF
CE4AB5021B4C6EFC73F53FE4BAB70FEF7BB90EC340B0A04521157A7E8A580246
49B4D24BDC04BF7838B3A369B453DC7D872C8BD6A569E8CF7A5E3935A1F718E7
782CE204E5ED5306AD81D8B06EC865BA1E64E4637D48A7A5CF88DB86D5BDF976
05A4F8C49F9C9A8A11CBD1E05B930F8D9DA4D6583DDC42F9BC793E382783710A
989B5ABB9CA4F996C63EE9226B27A923B3700FC5C4B2E0D1BA8A037C438D3AD5
9F3F356B1C5E796B0DB3FC1762749B26436218CFDF896D47951CBEBDA57C0AB7
61EE0A85086FC2FEEA95F07B052C24E49944E1D84D4EDCC402598656072979A6
61315830D48FF0E566DA27DAB5E88BB260051366AB5392CEC6A568F55FE74E6B
0A1556320FF4F3FD190F0003F4812E9E82D166DB7DFDB1ABDD1A816B766674B8
83A3E28918519A4009BC3515F6DDC3706889B2EB006AF716EB123EEB
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: CMTT10
%!PS-AdobeFont-1.1: CMTT10 1.00B
%%CreationDate: 1992 Apr 26 10:42:42
% Copyright (C) 1997 American Mathematical Society. All Rights Reserved.
11 dict begin
/FontInfo 7 dict dup begin
/version (1.00B) readonly def
/Notice (Copyright (C) 1997 American Mathematical Society. All Rights Reserved) readonly def
/FullName (CMTT10) readonly def
/FamilyName (Computer Modern) readonly def
/Weight (Medium) readonly def
/ItalicAngle 0 def
/isFixedPitch true def
end readonly def
/FontName /CMTT10 def
/PaintType 0 def
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0] readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 42 /asterisk put
dup 88 /X put
readonly def
/FontBBox{-4 -235 731 800}readonly def
currentdict end
currentfile eexec
D9D66F633B846A97B686A97E45A3D0AA052A014267B7904EB3C0D3BD0B83D891
016CA6CA4B712ADEB258FAAB9A130EE605E61F77FC1B738ABC7C51CD46EF8171
9098D5FEE67660E69A7AB91B58F29A4D79E57022F783EB0FBBB6D4F4EC35014F
D2DECBA99459A4C59DF0C6EBA150284454E707DC2100C15B76B4C19B84363758
469A6C558785B226332152109871A9883487DD7710949204DDCF837E6A8708B8
2BDBF16FBC7512FAA308A093FE5F00F963068B8232429ED8B7CF6A3D879A2D19
38DD5C4467F9DD8C5D1A2000B3A6BF2F25629BAEC199AE8BD4BA6ED9BBF7DABF
D0E153BAB1C17900D4FCE209622ACD19E7C74C2807D0397357ED07AB460D5204
EB3A45B7AC4D106B7303AD8348853032A745F417943F9B4FED652B835AA49727
A8B4117AFF1D4BCE831EB510B6851796D0BE6982B76620CB3CE0C22CACDD4593
F244C14EEC0E5A7C4AC42392F81C01BC4257FE12AF33F4BFEA9108FF11CF9714
4DD6EC70A2C4C1E4F328A1EB25E43525FB1E16C07E28CC359DF61F426B7D41EA
6A0C84DD63275395A503AAE908E1C82D389FD12A21E86999799E7F24A994472E
A10EAE77096709BE0D11AAD24A30D96E15A51D720AFB3B10D2E0AC8DC1A1204B
E8725E00D7E3A96F9978BC19377034D93D080C4391E579C34FF9FC2379CB119F
1E5BBEA91AE20F343C6420BE1E2BD0636B04FCCC0BEE0DC2D56D66F06DB22438
452822CBEAF03EE9EAA8398F276EC0D92A7FB978C17805DB2F4A7DFBA56FD6AF
8670EB364F01DE8FCAFBAF657D68C3A03112915736CEABAA8BA5C0AC25288369
5D49BD891FABEFE8699A0AE3ED85B48ACB22229E15623399C93DE7D935734ADA
DA7A1462C111D44AD53EA35B57E5D0B5FC0B481820E43222DB8EFCD5D30E15F9
BA304FA879392EE0BCC756CB5417F6F05EC7BB9535B18C91B14572544D4E8834
E38772A731EEA8F581E571A878C8215B9F542D8110341824604994ACAD02DBAB
7FBCE39606B19569C83F1DF93D5A272787C65B3441FD1C06D2EDC0FB1D1015FD
6A95C3F4602BAB714A362DFB9B64A5B0B609A05207C4B5DE6D4C5D330DB525A6
3557AF6A3ADC9659A71E27CF7D783BFB714016CCD45751F69A627F13CBBB5237
C677B302D6E0920E9A29B6DAD323E4695C2627ED8ACE7AC72FCFA3AC8EE47A73
CE1EBAFFF1CE45A564352F139811CB2C006FF7D08ED56A35184EF3E9A3ED9059
EFEA45F3081AED8FEBF88698A2BEE49737A261593EBE98D542BFDA09D5747479
C76842C6D907C469B30D294DD0C76F03413C6AC2052181FF359A0CC7B41420E5
10EF2F6D125740C407A0ADD9A9D0A8CB27C7EB2B20C343EC11B044A4EB7B7B60
01CEC0516D543D10FACB7B54DEAB92939A6EEBB40FF325BF5C31BDC000E9868F
55C572F8F801CC76D1C9DF82487BE643C42918FAEF4D7BC839A4522E37488018
C347364E91C1E81A53C961CBAA0E953EEB991A95F8781577C8003D1962E4DBD0
50785A8BC490D4D79996D3E2F7C1D9E03244FE391CB6F4A6D9BC1EE992CEAF91
10B33EE68E0CA9F6F392DB61F47A1A9CEB17DFD1B3747CA785A8A55640FBA2D1
D8B43B1094F41575DE834F474760A8E64CEB653D6BAF11A675105E72F77E832F
1D86D102EFE83389CE027FF44BB213A287971B525E8AAA740A8E4C00F1AA3C7F
17A7332B63915A1F80BBC6CF729CA2BFC2593ECEE71331D4ED21AA82164A318C
60C14895AF59F80DC1404C2A35FA7244CA75845EC6C2172B76508301A849837F
1B19AEA9589701DBDD1F3C2CCDE72F12C198B84E1495BBB202368A2980A24054

0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: CMTI12
%!PS-AdobeFont-1.1: CMTI12 1.0
%%CreationDate: 1991 Aug 18 21:06:53
% Copyright (C) 1997 American Mathematical Society. All Rights Reserved.
11 dict begin
/FontInfo 7 dict dup begin
/version (1.0) readonly def
/Notice (Copyright (C) 1997 American Mathematical Society. All Rights Reserved) readonly def
/FullName (CMTI12) readonly def
/FamilyName (Computer Modern) readonly def
/Weight (Medium) readonly def
/ItalicAngle -14.04 def
/isFixedPitch false def
end readonly def
/FontName /CMTI12 def
/PaintType 0 def
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0] readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 97 /a put
dup 98 /b put
dup 99 /c put
dup 100 /d put
dup 101 /e put
dup 102 /f put
dup 103 /g put
dup 104 /h put
dup 105 /i put
dup 106 /j put
dup 107 /k put
dup 108 /l put
dup 109 /m put
dup 110 /n put
dup 111 /o put
dup 112 /p put
dup 114 /r put
dup 115 /s put
dup 116 /t put
dup 118 /v put
dup 119 /w put
dup 121 /y put
dup 122 /z put
readonly def
/FontBBox{-36 -251 1103 750}readonly def
currentdict end
currentfile eexec
D9D66F633B846A97B686A97E45A3D0AA0529731C99A784CCBE85B4993B2EEBDE
3B12D472B7CF54651EF21185116A69AB1096ED4BAD2F646635E019B6417CC77B
532F85D811C70D1429A19A5307EF63EB5C5E02C89FC6C20F6D9D89E7D91FE470
B72BEFDA23F5DF76BE05AF4CE93137A219ED8A04A9D7D6FDF37E6B7FCDE0D90B
986423E5960A5D9FBB4C956556E8DF90CBFAEC476FA36FD9A5C8175C9AF513FE
D919C2DDD26BDC0D99398B9F4D03D6A8F05B47AF95EF28A9C561DBDC98C47CF5
525003F3DBE5BF07B2E83E66B7F97DDD7CE0EEB75A78BD9227BF359D002B6ADB
8AC57A33FED4EF021A7085B1E2B933DE602F0FF71467ECD501744AE338AF29A0
26F7D368AC6F25CCB882DB7B7343566192BD687E1349225982823027D3B66703
3B0DB7A7E680A682B98023D39C7FAE81A5D5B867A0A66C8AA0DBC83B1596A84F
0436AC6A7900B767BDCCE0060A4811003C79FDCC71D73F7F2D0A6675E93AD21A
56B4CD8EF75EED3DE8C0A18BEBF7B9D1BE72504872D56EDB272F1E97FC726CB6
68C85C713059DA19F6C2E0F3E12710A59B6FC4699AE883DE8C8615B7292AC25C
D5714B6CFB14EF0EF11EB13009BEBA4F345A5D3D6D9926ABC2BAD7DB1328651E
437BFB3C46DA7B62219660FC368CF3D3704DAD3AB461C28F711665BF484BF61C
052093D231CA65618EA463D63E406ECE858D180A6C0589B2FEDC321371C28E77
DE974D655DF5FF7D41ED01FE717D928A885F6FA6CFE4D2C0807F8E7F937916E0
96EDD1A3BA67802B1F4A49100E75613BA0356D9DCBBAD4DAB3C59E70A47058F5
2163D1730F0EE4D1F87C3A4AE723A23CFD7986FC4FBD399347E9F5946354E013
D860FC446AFF0B0744F5DA27CC777C96ADB388D1E835DDCBE123FB517679B9B7
EF696E091A9D51510BE264701A41C04FA8125A48F306ACA7A83E35D5BA0C296A
BC594ECA2CB27E92FED95B595C21E5BF0DA724D40761CB377BDE5FB98C9D152D
6C0DC98C4083E9656321BFC445CD6FCC142DEF16E27DD6FAD0B3185223B1A7D6
779F39C70793184F2C3B721FD0AE6D8E063BD47804785DAEA74AF8C75483B713
65061653E6889C2D878C3AD50E8F3FE62C0EE5F6306EE48FC1F28EFF3AD805A0
36490F65C915FDE7054BFC3503AB98CD632A7BE05C7A22762167E06C7052D501
5E7D52776EE1218818FB307DA0D27D182440541D8FDE17E957820EF12D11B5B0
75C38114A39C04993FD81E55BE830FA45599FD2FF1C73672E766EC8490F609B3
A83E142DC4443241C833BCD0CBDA68070461634A7867F7519000C5D5BBEEDD1D
6C3CBAC414FDC242B96E5BC05D7FBEB351092CF1EDB88DD666E30A130FA5BEE7
C7671C4AA21605A85CF11595D290D2FD7D8F252E9B29FC04C40C9971717EBCCA
862DDDC90223072DFADC51BA83CF8E343EA46D784FE08645847C884B8402E849
B2702EAF091A5C3D5B089A7A190CB4043EBD4AD7007B82C930521BC1DE1BC6DF
7B453DC6B239F00E92ADA493E42EAFEE08BA10A1230AD6C70F0474F2B7FD509E
31DFB808E9B047EF4B48C87BA882F3818902D327FF7460FCD20E7D28D7F7727A
92669BAC4E473848F6001B626E4159BD27958DFA571880418D4F6BA3B68A6A6B
9612204789EFBBEE992E158A30A906C8DA6C965C4DFA8501585F6310D64C5FE3
E0420FD7D710C9086FE06E7896441126F1C1A3A79172F6F0F27E69B117F9B805
080211B03E73A7460BA50B0E3266E8803C415048CDA6E3C29C847750C4C0A081
6FFB714A1ACFB3624DCE11264BE6E2372E20E7E0F7C339A50663D85E99B27EFA
7EB7F4B79ECEAF9E1D0A512673FF857FCAE00CC7BD9B5E6BA73E62D0ACE1F6E0
5C483D5B43DE5D9FCFAA2B10AC66B1386F31102ABCC9CD087E22A544ADAAD64E
20BFE89975CB2465AE80B7367A2379C2B9AAF7996AD933CA5E618DB5D442D727
3CDCA83FFFFF76665AF42672C6CCF815EC9C7D5B50015B1157133D6BB82E0537
98D13E0B7874F4D0993F6725955F940DB61B0C7F22494008037823E7EBE6432B
FA87907987E197C37D61C7B7562C7933087B4C1817E864BF2F221EFDD8429854
57CB9BE5ECC1EF22C3E2C10F287BBE294E07C34BA635F4972384C725CB10395B
356BCD2AD6AB97157C68FB007FC4295001ED8F5790FEBBF0E8A851023ED8DAF3
0DB68A30679B192EBD5E4964333AC5F8A6076A625FFFE58E184A5BC8D4CF49D4
C21CBEABD2C4E707A0DDC51B482A924E0BA254C5C4C09D958ACE2B4AD585952E
CA0E53D85444E6DB024FE26CE0653ABFC24B06595946A66A9EB1C881D805A043
ABCACEDFBD5A230652633BED61A634188675AF93E0D68AAE192632DE4D709EEF
325F9D77148546248EDDDD0E816203B37332808D5184FF27C4C808EAFFF39994
68DAD8B57BBC4796F2B3D0648EE438D90846CD0C253247D4B3D03BA9CAA3ECB4
56D303300438FCE9B5665929480DEA7E111F4639972478F7A724B07BA9C7B772
19EADC7AD7B511BC708AEAF5053C1DC49A5923D8C19808FCD207BEED1D700DCB
3F823BD824C00F0325A78F387A31253D25899EF6F6F7A1A05AD6573044311D88
F888BC052910430135A4DB43E3A72523FA7A7054248F57F769B68156A9D603ED
A11EA4657CD27E0B1C0AB6B23719E084807F3550A3DAF2A11A8E597E730BF7C2
005FB6AFE99B4DC5B799FD1A06B8D20F787ACB3B392E0978454A06BFDC471CEE
5A4BDAAE2C125E18432DA812C17DE79A941D1CCFE10280E1E2D089D1D6A53FB4
4FA07CFDD4A5BDF041CCDA6FBC404ADF29DB76E2D870B21BA0E8AA50E7042885
8665953C67EA2CB4CB76A6F346C08B3A30C9652C129B4C53268E3B30AE55F39C
3B0FC97A385963FBB7C5849875C3E9E8140A64A8468B3818C4A5DF602CDBF89F
B5AABF1E766D1B429E0B3AA0C1782C7CB37968A1D6E0767E6463DFE15673D290
C5B68AAE3ADD4829E49803EC002860394EA77E89E6CBBA5C405A6301278904EE
90D6CC95B95C214D02E18337EC10C2596F84F60B71C2FF99D5A4C4CA87171E77
5948A420AC3EA52913E9ADDA5E99BED5089189015282315295BC1C1E56D5CFBC
F6768D254881CB5E1743CECA4FF5431903B063B27B6D014AC1DB5D5ECA1DA5DE
3AF3754C13697BD817E7774BCE7CAFD584563DF90F606ECC71D276B8B5C7A2A2
4E628647B81AE1D2E68C637F52401274E0677806CA8B6BF2CE1B1C6FD2FCFFC3
B1210F95C320B12E00571CA7624D4B38C03DC52B116465F7E112E222BB24BAB6
F189B71F76E11058535560DA9BBC26DDE448C25B7131E7AE3995AA5A16739ECB
8C2C951CF47BCD5E96256A66152EEA272BD011746985492E66BF9C715848D32D
855AD54E0AB757F6117E1F3D3917ABC530F0C30F96C866901F38AC1697FBE8B5
72B2B8A96040114FBDBF2FAFAFA6DD90F915E7D28AAE913B7539C3C29476F9B2
1B5981838D2849B6C6F773A0D0A768D569B35A994CBA28750552D2346C3962DA
77558AED3DC0AD3BBA9D9D7E0202C2B7F2D2504762F16F0279CF2D8E977C4857
6FD68C2E4EB3D13D59EB8DF99AF2B0322098839E54D10EA77A69D4DBA19F5F18
F57252073C051595241099E1F1388E315B3958396336BF5ECC1E8A52E8789FE7
E85F075C3888E33FA32F2739F669E96C80DFC1EB7CAF4DF107FF2ADAE3B5CE63
EE57B5AD22C0CC95BA2462D9C775EB4CE28FBB49242CF1181724C3FA03183A21
ED69DE80CF3A5228A5B908FA04A00D4ADAA7A04C7B58164E0744EC54CA659C27
BD2066DF104A66C560F34597DEE89256BD797965ED2AC27BD35773FCA8650686
ECE9752EB2787CD6E856FACE0AEADFDBC1C5CB493E207563199CFD905B01CE65
B4BF670BC3ACF89C724D390A05ED2E46447F6E0DFEBB92B7923246A81A630A16
E3B01503B8FF2C5E953641F863040E5EC6BD49FBAD123A7D8594D0C8B0304B60
2742A68456BA17178307D7963E04CDA5BFE5C57EDC7D03822C602D15B583C274
E01A3D4010F614652B5969CD403056CB09CADBA97B2218B03A8B70A77EFC706E
D8CAF7071052B385CF887E11E90E3F3A9398E9074F3A120C913854489283405B
BD3527A6E49A7BDC776B6B12A2DA2F9DF6AA026E3911A8E5BBFD29281EFB9A8E
98C50E4F1C4C266C9A74A3F76A0C9CD03A50518559FE07C16875D355DE200657
B93981A8FA84D48CF8B506D185556A9CE69293FA1D24A59BDB8576D50AE97657
8BFB8C354FB5C2B1D64D6AD37261B69A4A7E8DB4E7F02E52428AE7AF2C2CA70F
9620FD8F846E081543861709B172F875906BC3A2DABCED9206257D45968F247C
9AE9BDB59CACB0572367606ED78EA505FF19A3A0B7A19EDF11F8644F2B6965F9
0AB44CE3CB65799BDF6680C761F719534C1863043067062C4EBE835E987F99C6
233F4C42DC4981A6DBD65208560E00260D3B7B287EF4727AD5080FF42EEF5955
C40E91BBF342F4A7315F497AC99838580DF6CF565AB1F2EE7D12A77B87C2CBB1
A02AADC6C50CCC9D2AB0720813D58D302A9DECA0D12E793E335141A1E2764244
35D4E2EA609BD5C76271F5E28F85301EFA39BD7C5884FF1339B52213B54BAC31
4E90233B8181C1B2FCB2669E8BBBAAF27B2C56BB265607E9A6AE78672330E836
BC86B44EB36BB909BF0CA5325EB3D4C2AA1049C26C6CF58BE473E00CA1A6DC55
292631C0E80A01D1A78E58FD4D995FBB909ED6C09C7ACE3FAA98EE10C86CC4A4
FAADC2126AF38BBAEE2AE3B1B093223CC741CE396CA463D1507E5811625FD63C
CF3A6E1B8CC347179914B24D0DA6971102D8091FACAD0FBD0A54D23EEDAFE2F7
CD40369EACDAB50F5A137F5F6BF81BF5AC522CCB710B483B277D12CD3DE20AD2
A1744FE9FE39EC273D51A5CDD077D5B47F35388961F6A6C5E3131FCC95FE8E27
A0B32F5F785712A00D4F2B23116712218FB9B5BCC62471C4DE857659D9B78017
F558348CEECFBACBCC94780C4D893597BA15930E1E3A368753008FF3125BA68C
96BD23D0D28502F9E47767F26485BFCA3359968733EBDF5DFC9FA0C45666A868
F2776F72126C2D6CA7C0118368747ACAAED33BE194C33083661C57C2FFCB2E9B
38E25E53332212CD688E4F5FCB9DECE8A27E01AEDC28E9B6EAD63F15AC23B2E8
369EBF8E0684D537F3CA7C348E02BC58691DEF9B4D958FC9259105BCC6E6EAD1
4BF88E8FDD9C69D534D853834EFC79F2F206006CB76CAE44C41614D5DDF1C42E
F8B4CF6FD785353911DCBCB83F41F6A4EC96CA5B4ED188C14BF776995B46B52C
B7F686DE15E159C393A28670B60D53DFE234A62EBCD158BCEF20DA94C9AB759E
11101902275473FC3C064ED62F8406F31F8BE08935F5125AE6BBBD8BA1CD230E
B716C88DEA02A138A2239DE16B1780A1F28A91E351C548CEC2466857350A2721
060295903470BE99F5EB5A21B9E7718C978998B5790CBCECBB349C8FB6096574
77A04001E84C97630999237186B4773ACDF81B682BDF623FED131A13AB5C33B5
382476C3BDC1ADBA142CF373D2D03E4BED1870090633D64EE55BEF2477DD2BAA
CF119CBCDAC0F095778882146A04D7AD76E4AE09C3790992A8E70B6125CDE65C
5324804E2D02EACB77007D01C6B8C600BD2038B9FEE3F62474CF83E4DBC80842
344E5E0B84D3AC9FBF3831BE300DEFC9F7779E7B9F44F40268554203B3C55482
053DBF47D69D88EC600390B1FEB0E6CD47C4623294DBFA26C1BB283923B13404
A3B67A20C57C448D4707D92A972649ED9E7BD86444FC89BDA757A478BF783761
3D7399A70B17F8E1AF5E20877B7CE863E204C86323D033C16719E17334E64760
8ED8D34689BC328329B1B30A86A7E10E7A6BEA5538091FA57B516285663E71D0
90B5927E2141F3040FD8A24E4A1A2F4E80009F17CF02F78E69F0B386FC72A171
6E4693407B9B8A380D1042F9F599982AC3A566D9927DAC9BA2687FF3FCE405B7
A772881795AD86A56CD7FF6818084F32AB59DC1ED5A7FA408C1F572285B46AB0
8533C2A0024ACCF4C460A3371FAFBB2B29CE763F162987B0DBFD0E79A1526077
AA79FE7CEC46D36B01170FE2D5E1013A4B1D3845B6420E07A37DC489D25F4667
541BD7134C59FAE89651BD89EDFA85C956FC4837D060D08F7A9D3B549F9736C5
A22DBB05243FF3953966A1876BC240C71B7E3091A372A805AD0803805B902132
2F023E1FD2F34890EC67ACCBB77CE0E1D53E7987779DBC2A89DE19CE8C204F60
BF57C1C2A2358190C51D0B95C1E08B7D9B32BA81BB971AFAD6317BEB0F5DB39F
B8E7CC509DF998723C980EFC5205615358B2180B55F2CA22BA7A635B216D8266
F65A54B9A6339D624C50148095A9A88551DFFBA639A74DF0830C62F56E2EF353
61CEC6C8BACC5976FF1F41BC625C5CFFEE38E3D465D91876E263C6CB75E2D0B1
C08BCDD935F6562CF750C8EC6CA11302C09BA48085FD807C6FC345400B6C86B7
BD54F07392D2EEFF540F164CAC20FAB1C3011158CF206650C537BEDD64AAD0F9
D73BAD61758BD11A00E83E44D1426A6AC904B1208AF82E53BE3E5A440FC75C21
96C79301BAC77B363BBDC04B1536249B9AE2ED3627B1298897D069656B294762
67B61457E4DD1C38433DCBEEACB57BDDB941C15C8E9349821996AF0B8B0003FD
46A5A708EB1F7244FFC67A5BDBF53DBFC7917902C49E100927BCF1804F93FD84
556E03339C47FA50FB76BD901D6D3853440F9E34CA4EC6DF6A29826461E71E84
688B40C73FBC98FDCD15FFB1619E2FC74050283057381631BC78C6375382F59A
4AB0815144D27E9CABBC56225CD8324D6D5F03D5CFC7A0CF79ECDDB011048FCB
207927B9317BE210B371B60C6752C44AD32E2BDA521380E2E9D4FD0A6A82C211
43DE60A0E272C6171415C3370898BBEA907CE6DBC1C2BCDA02C585ED5F762861
C8A417F9C1BD4D33F6FEAF591A7E8A761294DA623C1C85BF10F45E2763E83381
600E1032366ADCAC997867D140AA23706864B98866B0FD82C8027E817769A942
BAF42CF8018C8C3EFFEF43B317073594FD39C72DFAD12680C62E9EB794535504
779D6206754EA8BAE2876351C86AE5A2F94B8CF418CCDCDE89B0F62E8CF3F841
3F3FF536D8EB76C5830FF020A25B361411818DFDC518B2159BD9F46C742ED734
43E9E1028201341FBE8D5EB7A5F607CE84F4BA33C00824DC3D10DCC3D05CA508
77CF9280383536FF4F52BF62F62901201E81AF2824856E35F87F7416AE389905
A826CDB768714AB5A9291DC5E32295D0A8097CAF9F6EBFEDF52A823FF087CF44
F4CD436A938721359AEB37B5B915A9A27903C248D63443EB88D72F8A7609A11D
0911CA6070F14F869447527769AF3D9CC4967CDA525F97F698178019CACC1FF4
A87ABFA521AEC54FC0025A58CD0035145BEEE39BBBAE1F4543FFC928F4AD088F
1EC2F31509F236BCBC1466E997C94F60F075446B387C475CE657C479
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: CMTT12
%!PS-AdobeFont-1.1: CMTT12 1.0
%%CreationDate: 1991 Aug 20 16:45:46
% Copyright (C) 1997 American Mathematical Society. All Rights Reserved.
11 dict begin
/FontInfo 7 dict dup begin
/version (1.0) readonly def
/Notice (Copyright (C) 1997 American Mathematical Society. All Rights Reserved) readonly def
/FullName (CMTT12) readonly def
/FamilyName (Computer Modern) readonly def
/Weight (Medium) readonly def
/ItalicAngle 0 def
/isFixedPitch true def
end readonly def
/FontName /CMTT12 def
/PaintType 0 def
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0] readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 34 /quotedbl put
dup 40 /parenleft put
dup 41 /parenright put
dup 42 /asterisk put
dup 44 /comma put
dup 45 /hyphen put
dup 46 /period put
dup 48 /zero put
dup 49 /one put
dup 61 /equal put
dup 64 /at put
dup 66 /B put
dup 87 /W put
dup 88 /X put
dup 95 /underscore put
dup 97 /a put
dup 98 /b put
dup 99 /c put
dup 100 /d put
dup 101 /e put
dup 102 /f put
dup 103 /g put
dup 104 /h put
dup 105 /i put
dup 107 /k put
dup 108 /l put
dup 109 /m put
dup 110 /n put
dup 111 /o put
dup 114 /r put
dup 115 /s put
dup 116 /t put
dup 117 /u put
dup 118 /v put
dup 119 /w put
dup 120 /x put
dup 121 /y put
dup 122 /z put
dup 124 /bar put
readonly def
/FontBBox{-1 -234 524 695}readonly def
currentdict end
currentfile eexec
D9D66F633B846A97B686A97E45A3D0AA052A014267B7904EB3C0D3BD0B83D891
016CA6CA4B712ADEB258FAAB9A130EE605E61F77FC1B738ABC7C51CD46EF8171
9098D5FEE67660E69A7AB91B58F29A4D79E57022F783EB0FBBB6D4F4EC35014F
D2DECBA99459A4C59DF0C6EBA150284454E707DC2100C15B76B4C19B84363758
469A6C558785B226332152109871A9883487DD7710949204DDCF837E6A8708B8
2BDBF16FBC7512FAA308A093FE5F0364CD5660FE13FF01BC20148F9C480BCD0E
C81D5BFC66F04993DD73F0BE0AB13F53B1BA79FE5F618A4F672B16C06BE3251E
3BCB599BFA0E6041FBD558475370D693A959259A2699BA6E97CF40435B8E8A4B
426343E145DF14E59028D4E0941AB537E34024E6CDE0EA9AF8038A3260A0358D
D5B1DB53582F0DAB7ADE29CF8DBA0992D5A94672DFF91573F38D9BFD1A57E161
E52DA1B41433C82261E47F79997DF603935D2A187A95F7A25D148FB3C2B6AA32
6B982C32C6B25867871ED7B38E150031A3DE568C8D3731A779EAAF09AC5CE6C5
A129C4147E56882B8068DF37C97C761694F1316AF93E33FF7E0B2F1F252735CE
0D9F7BCE136B06EE967ABE0C8DF24DCBBF99874702ED252B677F407CB39678CC
85DDFC2F45C552BA967E4158165ED16FECC4E32AC4D3B3EB8046DCDD37C92FDF
F1F3710BB8EF5CA358ABACA33C7E5ACAD6BF5DC58BDFC3CF09BA2A38291D45A4
C15FF1916FE2EC47FDC80911EB9C61F5D355BEDFC9DB17588547763AC5F0B1CC
12D2FFB32E0803D37E3281DA9CE36C5433655526ACFB3A301C56FAB09DF07B5D
048B47687348DEB96F3F9C53CE56DDD312B93D3918CD92AF53FB9461864D11B8
0138918D0B1270C54873C4012CDE6F886DB11BCEA04B023EBB43E0D0A06BE725
741D08B9DB688731A6C9886C15A83C28DADCC81385EA239E045E8F3670CE03DB
9EE77ED067036595C9F3B1854343BE3A12E486B6E5A2F8AC44FA5378D28DCCEE
306B0E283AA444423F9A4FF38E2B56DCF67A39CEB2C643DAE86865517D5D0371
CB8797208ADEC637330A3A57902C9A88EDB75A7C16FA9850075D9F19578EC666
1353CC1FC512D59DFF847ACCD67EE90DFECF899E58BB6430D9915B21B801B7E4
58DFE32BA7776F22C7FB27DAA8DBD8C86084D4F81414B1928B8FED109952FBB2
221D42194DA295E0C7BBAC7D4120E0AF3C74F02A3EA55098BDEC46BA9C80250C
9D18FE2D51421A8AC02EEEC41EBA77C090B148B8C3BB242CBA50931DC2C43D58
3BA02A6E7B96151D4C0FF25CCFF1129E0C724FD5E59487038CC5E77D6EE5A4BB
0E98171DDFC6E8EB87AC41307E3BD4F68152F9FB3D389E819137D4228251AE4B
E4BE53D832D31B81AEC54B5E7C460544E7B398F243A5DCA49DB90024A40F0E96
EABB34AC7E1BF2974F125F5A630B0F5108E676BF62AD513A3C96DC55B175FAD5
7E436F20AEEA26C927D1C9F9AB31C138EC2E1262A67B6A61B472532A376D28A0
59174709261B270855FBCA06499D97952BC9EDA0D363A753414B8549E6A0D444
922F38DFF4A275EA919E8F3DF4E25C66D09E051525D83C50B63C833FA9213C3A
BCF740B86CC3F6BAD024D74420A4A9CFE1AC137B4219D8E7ED304054C80BE088
0051DE1699E0826E5DACCB4E70ACA33A9261FC6D3B4F5198B2B8D0ECB73ACDF2
8BBEA01A3B8F1652340E97D8EE95FF43D48F1A7A177A0BA031749AE7A37068E4
EEABC216DDEF4288A321D95363A76A4818DA2513DD8FDA5C3435A56B8676292C
826038C03B41FA6BCFE6AA2C5A4B725954670C3AE87B96B464049D11557AEBC1
A10D3E03A4BF556871B0D5DD50F85010E7B5E7962F7C4024943E448418593FC8
2BDFC7F942F00BC5062F39CCF90252E209BA9CDF2A6378C99797FF2957A3E162
D745E53D99E4EA92A80F710C094E0076ECF9C93F8F69B882CD8BABD304AA9D8B
65D2CEAF18F7ED796B427C60B868E84EE9B07338A1FD95B64B555D45C0AC84C3
FE9ACD792BC9764993D3740CAE1FBF5A40B838145E2801BCBE4B37570EFBBF70
9DD73E39CBB768521FF8AF4D5860D0D9693141C9A7B92266BAFE3A41F073C548
DCCEA27C14FC41DE661536D9777AAF09634B36030D4F8C0BC53729224F032D0F
D23E9866B4374E5D8FA07A2DB1AF3C06B8B1C0012FC5EAB614B5358220B090DC
2BA454BE9373987A5568142C3086C8A9AB4F47E23AAE569F95E028D0C2D2B182
4B01412EF6A25A6D09DA3F66B9A4ACC935B4F0AAC99949D0E5A833C08AD5AEB5
77D0CCB570B21EFD8C4FDAC4B880425D6F768CF2CD6E827A1125EEBE77CAD83D
28A72C230B84531D305C33286BB92820E39AC7EF45404E8A21673B7A723431CE
57F6F75A32C4432CA1BF093CEE771A48858420DEF8C90B444F49BE1B528D0AEF
5DC4A6A8D2D37BF18CA8A985D8DF8C2063F365621A40344BD3509BA078F8998D
47FDE2FA67E820B54133D8F15B5DA8EB9353AA8BAB6FAB37CE0AF7A159B8FDBA
CF8C7549392088BBFAB6C171DF7357947D2A7D5FA09DB56C03413A1766CC97B7
FD60B8DE5A9318DA301A97AFF548ED4C21B34D7A11D42CC692ACAC42E826A9E9
61A2CE5A76F0DB6884D65B0755E3FB1D2641FD20F1D61AF4D618267256C4AF2C
B5FC7709F5073D3E627A4E5A2BC741703167002AA5FF2DA8013D1157F9D2A36D
4DD35D9722C98BBC50381C9F3A3F41C76A6CBBAED0DC781D41CE02511E467E72
9D793FFF95AA019E4437294EC73E6BA08E3BBFEC9123562EEF1E47FE7DDF1020
80F77DA29313F6A4769CFC8D501F53D2FF3F1D9A7B70258FEB132A199D700DAA
EE6097D6AA8E8572CAB5F979285FECC645C9BDDEF3115F493F4923DF49B43119
ACDEE7BBE6EBE115B8867F5CC33CB01FC3B7C0E5D64FA83A2015F67C467FA273
8B42BFD039F6D0D336C1879951411DEC9A05CA23F36D1CC78071FC841487A854
F0B90CFC1E2785ABBD6977DB989E79830435CEEB873DD5E2633636C20F89A0EC
F307C2B318FF9135C9C81D977B61890D86FD3ED8655B2C6A70C196B505EAEEC1
EC409A06A2A37CE7D74C36243EB973B029A126131BD9389BD08F05754AAB9744
7CCB5E5E3260B0EA3607C8BBFEE55FEFDE0209FB19A110CB0698833257C030C6
4A3230605C5A7DA560979C6569F7392BCE7E03371EE9C4ABB658EDDA5DE0713C
ED5327351DCC9486BD9E495434DA9C4A7CA085E043E26282E7E63AA4307052F6
C4087FE4A0DC8C230EE438C405311D12C4A41BB642C608D87AFE468857603642
547F2E55CA2E4379149695CEFA40E56E7C84D1CAB505C0F7FE78366ECBAA7A70
BA1368488F25A789FB056E4C525904278FECFB6944DFEE6362D2A175482C3E42
BB2395A2061816EBDCDCDD8C554FD76F492D420D73C0273766BCFA6D67D35666
45608A960DB950EE6B1ABC3C969202A2C99BE8AC1ED02565A662F172A4C45FE6
7B16D1DC6880D03CF7C42DA2896DD9F46F5FD0412ACB69805D127B5333D04670
0EA181A309C2DC001266C2829BD34E35986F3F131B12CCB5248694A262ACF3DE
F456D8B9D3FA1E09D30D197800B5430A4770FC22D0EC3B3AD6D586D0FD3F16CB
C22BB3E70A05FAF08D0BDE3659508234AD25830F01D05E8AF00889897BF8805A
6D65333422847EB1F0F019E2C3B1032DDD213739817A6B1D7724AFB7AC36ADC1
7DFAF51A691E3D654BB35031EDD808472B5CEDF5CC4FEC57A8193DFAE0D6C657
501EFAC750A02EADC89856ADDD5223812BAF4C9DB0F52313C0609F25FE7C42C8
11FBB49334B53FDF8C8F00D17DBB703FE907F91FF207809286A18B8D95C581B1
D8F863F2C0F236C5F6AF276ED2632458A16FBD8B49B11B491782E0FCBC5F6FCB
B60AD95448D5E5173463EDF20CFD65D03D9A994CEBE8612EDB6B8563FEC512FB
5526729AF7A8CB7C018A0270D8553D96225CBEC220AACD6E8B54F31F63A3946F
B816595A5AC954B47346845B1B695010A54274171825FB067B2615671C34DE16
5DFB52F6C158602B41962DC32087A50446BC476388E57F12470EB54D6D062875
C36CBAD0AF3BA012D10CA07E1FD321BE43AE7398304F2994FB265E7E492D95AA
5843299F43368673F3A6CA73807906DF7ED3041616FE8E93E2871E0752BB8D47
6E735C7DF561C0BC340F48F91A0A1D30952458C19636B8183364A96A1B634B97
FE3A3AF09C2F9726AFF46AE06CCC51A2353D8381B3CAC891DD7C2C6D20A54BA5
DD67A3CACCF4A0EB64C170DA49A79E91FF38DDADF50B0C789DA690A08D46D5AF
1376F3A248CB2775AB144B2902F6F57C400711568657BEFA20A5F0856951F320
C346B24558441013D12325C90F9E324DDDD29F543C92632F8C8272235F733C68
82D777E6B9864F45EB3FCF97E9D4D833315D07C9F0641D7AEF962E148CBB0869
3B2D115C29B600B59C525F9E5775358DB4D2124B1F1AC3539D120A644581D74F
3FAD849F491B10CCB7412C76AB28B17E5A00E5D980AAAB9669A5A2B22B20A046
66E0DE0D77CF718808D719E318DBF84CB27EE72069A50236F2B14E2AC5D6DC58
4C58988CCDED1BE5235A4AE89661B604E3F98932D764E3610F1EFC8EC034463C
5591D065E48B6380E77EA8973C72579A2066AE8A91682C66DB4A24FD0B183651
870D355FECFE86E525F498F37553BB3F32964681CFF7AEF2BDF1E58EC3B09A47
372281196036CF5CE48AAE0D4606383F7D7F2B78907A4305BE361FC6CD69D6D9
6BB90D0A29DDCE5331EBAECCB977ED5DAF8AE54E2593C227EF0F21927F25302D
070B5E7E7A134AE4261FE998E02E7A844366DC495F665706CF2FE6DEA368E7A5
7763785845A2CC2A23A8718299BFC5BB3A6972D53E88CA8209161AA48E2C1F38
7B41A4124E0497A4BFD529A42341A1CDF7605E3EE616B5F8BE8A1881FBEFE30A
81C67C2035C3B257C5B8747D5053D66C8764EFCD7FACC33012C9E9E46347D202
52826BB1845D8F8B87D1BF886FB6BFCC668B6C1204B0FBE0A00537CC77254811
2000D4FC3F249E014EC10A598136A0DE86664FBABE7971F5C06DE2A3E068E679
55837D509269093FECB58C04BBFE9AB3A56B2BE1D6F3E7CB2C982F667042FF7A
E65D913C7BE73C2E465E10888D3E83F7A47368ABB938FFB098A4D083A410289C
F15743F16D50311CBB73C0BBB00DDEED00937BE0B53125842731680EB6163212
2A5714F42E2CEE822D0A1F529D25560A64C477292A382F55784070FFF87CABA4
38C90A96C4A50B28B404966AE781026620DB9E5069705CFF9F85AA091A3CCDA2
208F60F9490BE7F53A9895010458CA3D4E60C07FC8B9A9440EEEA3A192228EE9
61E968C5F7641F534B544C06EEA6414338F1ABD67FF7469D10C0C2713AFE21BA
CC19CC424B5644087F365486E65F4DACAFB05504F436B7911F37DB1233772A79
302B944A49D183DA2C893F2D3862F1D703E663494D559EF967A18D86D03EE666
51D29D62C82345D90D553A58877C6E2E6AD69D236568D73D84FDA838F70075B1
CD1AEC5A19F0E186AC88D1E9454EA7E290783FEF129A0FCE68DCF9557D2F303C
8C16DB7AAA38B247CE602EBC518294937F99AC6D4ECF16109716C8B14D2D0128
0795185753E5F2E95C23835855AD126884852016C9C12852F9D9A7035B70FEE1
786ED1FA184C384036BEB96831DE2E5CF1260AACD669CAFCCA68A31FCF3EA4DF
4603CACCEF1241CF5AEF938D180D351A2575D5105FC534FEE83648D6D90543B6
20545902DC7E7E987F71B730E783F539DE5B82538B749A1D561BA53317CBC5EE
856EFCF890CA77ACF68EBE806FF8927C03F60AC1177EBF20A170F395136DA6F1
C1088534C2C8852157F5E66D5E12B7F475268CC7C438C5161CBB092A24AB36E3
19C2BCE0B92F943073D48D2D8C4D4CD7DAD8C4588280F1EBFD9D004DF2DB2C7F
8CF1C702B539A8E9C006410D249B1C28C3E151B42A925EDA39721B9781694D10
0B993ED6998D8BD422D4282C07F4C9CD5ED68EF97E093D59260C27688DD84225
DEFDED33ACDCD4060DFDC5D475D48409917AB125108D249FA9A84A4CF6FA279C
DB0F8BD000E8A5647C9CEE67D9D305BC83B0FCEF742C7E9F3FB7ABAAFF741CFE
0735090A76C7E8296685ECEFEC6DF19B1CD05D47FEFD465ADF11F58CC4E93006
F3BB759370C23967D2A00371540390B730604F68DD373198926E590627A8F972
E1EEF686A94C6142E77B3C291FF1675788BF36168A024EAF6A4E162F81DC1A3F
C6E5733096EDA913E4C30C2A7464EEEAA78C824528F0BC856932938FF436B07C
817F34555C44948837AD7D0C85FF8779C64534BF38D02E57CB86143E5261C02A
8097362A30F52EB851628A5FC2B3F3B1DFA97FB82D8A614E52F61A7FC35DCDBE
B623627E77C7AFD2EF5964324AEDD1DC38034B45956A0B7E45B0AAA843D8C028
6C182A4D7766CB8CF59EA575909C4D5A2A45B2945D30FFBEB1E68FD65E515E66
EBC60740494972AE094EA7837E037389CDB34AB151FFEBF848BF39A466BDD7EE
2E231AC6A12365C71AC02F8615657448AD3E909E523DF021CE5C2F0916A226C2
0DC71E0C1CAB1299488D9F4FF54087561C2474A75B2BF8D9AA3B714EEEB1072E
EA4229A4D2D3162139DD01D8BC8C27FCE84735CDBB62952C9D156B877598F2E6
8580211263943B3F631F6FB5C1BE067616EC0E82D05FAF325708F575D2333CF4
6FCC9E348C223D2A2E0980AB6E6A9193AA5B9214DB4DACA01B32B11501651612
CCC542CBF3A4F1CC1107305FC81DAA9E356FFC0D775BF234729DDBA5BBE31E59
62E029A0E971FA91E88E32B34D12EA17FB9041FCA2F6F6D90A18C27C41707772
BE8E591DBFCBF97ADD8621AB9913B7B690BC06A57597D800B8D6CDD52A832782
5DB46EA0B75EF04E81E33878FC8A619226012B68E064E91B87426B4283F1D5A2
4CCE2C6080A55A6ED14E675E0C910D1F3A5C1BE47F7C304DBA290BF632F95376
FF97EDF06F4205E8F86BA883019D7EF02E3063E8ACE92C93CBA8638F6A408AFF
D23854DC12DE348FD583AF1CB92A422E43CD75C67E3C97D7D36BC0C772FDB1F1
9F99F296B3A22F61C11AF97EAFE5FE1EEBC2C8858824C2372C19D997510AAF15
5421F725C4A7A2374F21568AA52569A1585422EFA21D65CE3859FEF04799CAB1
0A54D09E44754DDF8D36DA56F4C7B16F1766A9961AF2C63A1E7EBA2958F9E1D7
9A96186ECDE103FC7DD644F710B0764B82CC5AB1915659E3FBF182B5F85976AA
B826A6982740CA7A8B9F71244E15AAD0AD01B8B8A1D0640E1165A22E6A8A4EBB
66F05AC6F1AC9D7F2BE63D53C030608E6AA97370577644010AC34AC50CFD5671
BEB528AD11C18AE63C2F645D60CFD41FB005BA1EBC884720F68248D0BE61BADC
D782EC2453A29557A516946C725683B894F96E55672B010A4688DCA4CD2F5597
217A89C9FC30CCFDF33AC095A5CD24AE8AF63DACDEA5960608A120E6EF4D0948
E43640DB5D17E563BEFFC6ABE04BA437FFD6D7F52F7BE009E7E88DC03F4A07CC
4CC2A49A9586F55757F3F28490757970509709D04717163F90DB86895F563BE3
49B25EF1AFEBA99FB82D025BE1CE16041FEBCB812F6DC24ABB364ECCD8CE4A15
57A2E836A51EE299E9653986F5CDA6E03EF34CBB71914D143DC112BFC56CB237
C232ADCEECFC40750A82107CD1ADCA608B60DF2A7B19CB2F45F4D76920D0679C
BFB0B6B1FDFE21105CF040BDAE26CF3235070B2209CB69AA6150BE34B78C22F7
DA7B7698E279BDBFC00193BC5C5DEE39C288F20D77A27AF0E765B549CE99D731
372D05E4E951C8E00132ACCB5A1BB4342EBA3765A4E22B747D5FFD7C15CDA8A5
2A68077C45ABC878CA8BBEFC9B929B8B9AC7CD7888BDA4D5DDA1096BCDE17A03
6C2D877200A0B3EB297CE84D557F2A1341843CCF11497BAC6CFDDB20A8952B68
2DCDCDCD0744ABCC7CEF59CFEE3EAB57670F92517FE3AEFEDC6ED95BA23C84D2
2B8FCB748F4E7E88AB4FE86618E4C3C3535259444134C95C2801758E0DEB6DE7
7283DDD0E30F122EBDE0415EC21819D937D85ED13565668ECEC86DD418151032
0FF931C64E3062C679FF5D08E7FD60196A09A13F56A3E231778F67BD1F04C1A2
38DE4C838850C209DB4A54C928E3A0C4336BC45E1D66CDCF04CEF25182F5A793
64832DBE9785E07C543050A15E8E88C63EAEC457B5005EA0F053772D07BAC299
C3D70146916BAAAEF24698B7152A038364502B0D1CFBDBD67232FDD97215983C
A2CF41FF65FC4432A74A60D712B3E26C4D52AD60EEABE93B66C066A7AB25EDEB
8C6F52B33B7DD0F2EE38CD5627FE3A2598A6634FEA583060FE3814B43BC10222
76277A630A366257B6B48ABBF746263C688FB47DD22D72C1B47DA4FD05076589
08F1950B2643EA250A5DAA1C1D74B51D69FDD7D33F44B94206C4ED410D9B1385
F40E9C0A8E9B8C2258DC0E57CF1CB352BAC817E5CBDD29A9F7E145ADD9B77286
B436604E8B9C13528E52A210A4F151FAEC0F53D3E329A2C0F73E59DFDE29ABF0
D9C462A1061FE64EBE64A63BEE37002E9C502A44452C6C5FB8C0AD7BFC197AFF
CE7354CD8280C6647BE1033242433A36CEC99B8A28020E8393A74A685A760AB0
8F7A44294C0EB65935F769160800AF6CC10FF7A5E1CAFD5F965CB2D0F84291E1
925A9FE21051584410467A6ED9281FDEED808F39AC3EC33AF62920F13BA62BD7
2ADF0EF5DF5D0AFAFF325A1D3FFEC55359A329C420B1E809EDD59C7B1883C9CC
307464E7B655BC3F2CF080E499DF14AC161F2575EA57864F98A39EC1C58DD7AA
7DFE88D8D955398C29B95BD0DEEA637AE24312953350B5D8D6AE0F1DB91E5D70
DE55045629676A590D075C9A9B58BBAC33AAA4EABAE4D8216285EFF941F72BC9
74868C148552DE7C661EBA8B04AFBF73D44272FF5549AF0A19B7E32EF3CF32B9
A5AAE421969BBC928298825CCC685C5780A5E0F66F87F2B7E127AE20007CBB0F
E53D7DAF2856F3FCE844DD321A56627DB6DD02632545D4AD868768186F464A97
C839146D9B4CA6F62392194D480A17578C9370625B4D457B0E079C68720AE8D6
2D8845EF248F984175CCE0F61E3D61D9C930C8E36D335F7E16F750DEF7F0E8B1
8E3D453D03E859B54E52E5E5942654100C30E18B34525B2AE19B859BF619DBD3
B3EB15D61AC560BF
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: CMMI12
%!PS-AdobeFont-1.1: CMMI12 1.100
%%CreationDate: 1996 Jul 27 08:57:55
% Copyright (C) 1997 American Mathematical Society. All Rights Reserved.
11 dict begin
/FontInfo 7 dict dup begin
/version (1.100) readonly def
/Notice (Copyright (C) 1997 American Mathematical Society. All Rights Reserved) readonly def
/FullName (CMMI12) readonly def
/FamilyName (Computer Modern) readonly def
/Weight (Medium) readonly def
/ItalicAngle -14.04 def
/isFixedPitch false def
end readonly def
/FontName /CMMI12 def
/PaintType 0 def
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0] readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 58 /period put
dup 59 /comma put
dup 97 /a put
dup 98 /b put
dup 102 /f put
dup 103 /g put
dup 107 /k put
dup 110 /n put
dup 120 /x put
dup 121 /y put
readonly def
/FontBBox{-30 -250 1026 750}readonly def
currentdict end
currentfile eexec
D9D66F633B846A97B686A97E45A3D0AA0529731C99A784CCBE85B4993B2EEBDE
3B12D472B7CF54651EF21185116A69AB1096ED4BAD2F646635E019B6417CC77B
532F85D811C70D1429A19A5307EF63EB5C5E02C89FC6C20F6D9D89E7D91FE470
B72BEFDA23F5DF76BE05AF4CE93137A219ED8A04A9D7D6FDF37E6B7FCDE0D90B
986423E5960A5D9FBB4C956556E8DF90CBFAEC476FA36FD9A5C8175C9AF513FE
D919C2DDD26BDC0D99398B9F4D03D6A8F05B47AF95EF28A9C561DBDC98C47CF5
5250011D19E9366EB6FD153D3A100CAA6212E3D5D93990737F8D326D347B7EDC
4391C9DF440285B8FC159D0E98D4258FC57892DCC57F7903449E07914FBE9E67
3C15C2153C061EB541F66C11E7EE77D5D77C0B11E1AC55101DA976CCACAB6993
EED1406FBB7FF30EAC9E90B90B2AF4EC7C273CA32F11A5C1426FF641B4A2FB2F
4E68635C93DB835737567FAF8471CBC05078DCD4E40E25A2F4E5AF46C234CF59
2A1CE8F39E1BA1B2A594355637E474167EAD4D97D51AF0A899B44387E1FD933A
323AFDA6BA740534A510B4705C0A15647AFBF3E53A82BF320DD96753639BE49C
2F79A1988863EF977B800C9DB5B42039C23EB86953713F730E03EA22FF7BB2C1
D97D33FD77B1BDCC2A60B12CF7805CFC90C5B914C0F30A673DF9587F93E47CEA
5932DD1930560C4F0D97547BCD805D6D854455B13A4D7382A22F562D7C55041F
0FD294BDAA1834820F894265A667E5C97D95FF152531EF97258F56374502865D
A1E7C0C5FB7C6FB7D3C43FEB3431095A59FBF6F61CEC6D6DEE09F4EB0FD70D77
2A8B0A4984C6120293F6B947944BE23259F6EB64303D627353163B6505FC8A60
00681F7A3968B6CBB49E0420A691258F5E7B07B417157803FCBE9B9FB1F80FD8
CA0A265B570BA294792DD2FC75CE2C83DCC225B902551DBD11E687EAC6E85D2B
02C28359A40AE66A6A6A8862CB17815B41E280313F0EFAA9981755611F7F683D
35603984D60BB0C772054355A97A5E03C689E23B04DA79080CE4579CC90EF38B
1A64CDD92B907AE83192C3C46C5FC40BB412F6656DC6349E6D29B5936DCE94CB
98E3B465FFF7574095F57BB3750F1A55F20456933FCA64CC1B060E260782BEF6
721D38BF65DF1F1DA5439DBC802B4A9D803BD635C05B9ACA4D26C28195A1F4C4
CC623B30B076D4861E89B93E2CF26F6DF07199C03BA5466FA3EFBD7F77EFE068
E55B7186855063934C5716EDC3F5056BDA963B6B933B546475BCFF91C512F411
8D14B1C32C9735281E536F87ADBF1AD9AA04D7DE2096413AB8B3C9E8B1F6F338
3B80D637D761A7A992CF58188FB0A04FD6C6886A60F27EF31C45E92F4717D8FB
D4A0844A8D9036D5F2BBCA2C170F3042F22DEB8D151C7135AB91DA289886604B
70B9F2A25A7D576FA1D70DC935CDD3E81915E9BE11CB03C9FDCFDE3700BDDAAE
D61CD52A78B075FF4FB8BE949FCC4B04813776A3451FE65A47D57D7B66499E99
B97C5141D2E05BA86C59535C34BA975381F96A4EC47EA032C6BEEF9F2E6565A0
0712528976CD8FD94E2F8F2607FEE1B55382A62B35FA16C62707F805DDD68FAF
F18133F16F5D312246BE70BD7BDE367A314CDE17E9E69A7D63DE373262D397EB
122EDC39FF38293491D4EF9CB678EF04084272B32E458BE8D000DC45CD6405E4
C58C77F4D100499847E1102CC075FA1210881D95D6EF60256BC7D144CD4193EB
D65A905E50DB692AB573334618AC445D88D9659B81A1793927F359319269D09E
D9009C0F464678859A03070758C38629FC34410FA9D12117091EA58204F935EB
454FC0099D03A9B6B8C8C67347A049AF60C860AA9D845C3EE9692A939C59AE6D
357F3A83C3FE75EF379DA24C26B4B97E31235093AD466573AF8B04A4B6ABAFF2
36984D3505DAF82D52F0239A2269EF36D81D184D3F50C1E694BE6350D1AB7514
7E8B4CA2B560A63AFB2103EA40E39B83CE1D6DD8BC767589B551A2A42FDC93DC
AE609C96C9FFEFE68F6989473FF33419BDC75BF5578E520F800905161E7F02BB
F5886418235DC202C6DFC07CC791BC2AE4B5E30DE983828BD93C19B81A92DA6E
075FBF97581EC40CE0C714249F828C26D44D37EEE221E6F0BEA7FC099EC71795
6A7C8B3A644AD297D52DF3C7BB3FB92A7DBC12DBE7AC1DB907B5F74CFC908BE0
4108AFAEF8D2CA9B5103DE61DB658D532E03113DDF49B0500B57DCEA604FFD3E
0C1158024FBA09B9D9E14F4ED4B2B743493A0E2A4A18641525A15B1D291849C3
D85BCB1E2FB109A749E8F99D93461EF5D0EAE6C18C169DAF80BDA2CCC1926E06
CFA601C5FE3BA2916B622D5ECC90FF246F902FBF9B2095306515627F3FDD45F0
E5E3476BBF5DE7EE71FEF02E5968F911484D8D9FEBF5AA067D9EAD2DABF5D240
CE8181E42ABEECF13BCE8BCEFD9A2621409D4B42FE6914BB2AFCA7188F3D3AC0
90033BBBD28333EB7F5D1D292E26A8F7098E0945454ACBF9D4F736209B3BE5C2
7274BEC0CEBBAC2E6AD3A40004E7B3E17C6B42161DD71683D936681D67AC2BD7
1AEF84EF7148EFF2C271FBB5975C4856C0BDF28C476EB3234D985B2AB82EDC0C
1650205123D077D86C3F1D35D9DFADBF0EFDA00327F04448DA6E5AC34221DF31
CB1E6C6E696A68A8381D3320135FE4681CA89C7AD91F8B4FD6C8D48FD9075F9F
D214D7EEEA297C9FEAA8C310BC92C886E81F0E470B9D2CCA72BE40529A08E957
817F067EBBEDDD4B6C7E86DB9D2E6515CA445F790898E64C922308E19FCAF885
FCF3DA6B26EB06CC223C73B75848523F43716F055E9DC8130FFE72B5A6FBDAC8
E3488B3CE53BA62D16C2F50C6DE39CB72E21F1E10C2A3F288E3379A686D6374C
4EF723B0DE44B316348D40E8E132F2A5FBEF03726F9F5309B8126FDDB868F51A
64A720D1E0A85F13FDFFD2C44D7665A40FB2B22507EF15A1CD59A0A761DB10A4
93D0A7986B523E77D5BEC9CCD6518833527C3F77BC283431D82205195FA2FB18
11ACE50EC04FD9994BC46CD4969A60FBDCA9BF5AFBF49CA693F35A4844AAB2AB
31B2BAA91A2049AFE83ABBD63CCAE58F98129EEFD1BB318F1C3A57A4E5B3D34B
58A035A7EC957E3DF35E8D9D98D8F3C3DB5747A85DDDBBFF700E23CCEC8CB046
86E41393C00C28E7A8DE9B4274408308AF4E0B2D27E3856C38A1878713F28F7C
BA5E7EAA4289DC72B244EE0CB08E604532083A93BB7AB4746BFDC50CA089C83C
538F77248B89F4838DA5A30B0B0B91645F31378885010EC51A0F5AA0248C9CB7
48F0ACBE224872B242A72D0BD64F0D92E23630EBB091D4D29C41C880A438F482
7E6A674E1ECCB30E872F568AB9970ABDDA54BB23EF91E066740FD2A9DA981CF8
B0BB84834E327234F4E45B5216DCEFDE56528CAED303D8A4E5A6C6BBB0552255
2D1AE5D1BA84F2BD824389678C9D0CEB8E3F7D84968601009DD2B23BC08D97E1
B64BEF79682E7C2C94C9C4BF70F1651800ACE3A9E935D7408BB4B41EFA04FA54
F1F0CD9B3DDC6ED298DC18AFD1F0BCD7F80984232C30163F918B6595B9CC8314
8D58B416BB9CA7CF173DE8ECE7A0BADAAF114B95CF34D0068E041D8F4537702D
4FE2DBEEA7498B4FFB20306891907D0DA1EDB961ADF7795D30BB484B824FC3A5
DC6F41D3EDB718B80FBFB6ADDBD0C7DCF70785E9BCEC472A571A570F5680E9D7
84B03F2333B1195DBB91B1B663FD74C562F9B345FEE4D13C64BDEAF35576ED74
45F0BADB9899853A750DA8C4053B085C9120E6BF2F777723CB5CB331D0FD4C6E
C1CAF785D6EBABE617CC46FE7C556D55FBBC3217180625C3F73854E6D7F3429E
90BB98FD4CC026513C08C0AA68B440027C1DF7D70C262F86BA088CA3015AA40A
31D37E0FD125A45B50845C15EF05D4668343361FB552CF1CD46C8A73A3CF75EA
E8DFB9DC1CC42F9A2FE5D7E7B7E2F666B16816A0FEBC65FED3532973E277DCF6
D6C88F346A43736AFF31D090EAC73421D4E580ECB417E3431B7967225043261F
FB82EBC1FD7F6D337AED919E7943304F5D284BEDF186CFF21168B59613F9FF86
2801E9DD367CCEE250293DEF4D0B51BDC58046CEF60E6FD2AABF9EC3B9829F48
54E357B5C69A239A1D400E4E30480D27E08101F1976DDF046CD6DD4036923ACE
0510E9581AF73B3EF413D07AB6FA071C8CCBB58E96E71ADCC7AF772E7752E84E
DFC3C2164DFD7C629E0A9185195B7B91FF7D6AE1FA69EFD45C3B415AEB10E6A2
95C053798BF7AAEDF549AAA6B9B0FDFA2B090A3764AC1946269760BEDDC90973
79C205B587DE7BAE21DEC49955F3561126B7EE17BAAFDBFBDD9BD610931A2AEA
FB018917F2DA1FA6A02A83599A96768708D1EC73D1DEBB9B5EED7F55DC712D06
650580270622168F8731A30C843E679B3A04536414BB080508D33E4B03C87518
68A06831AAEB8AD647B8C3A6C4D679344BAB5CCA87F17D836138EFE4E13D3340
5F7E40D114E4694757EB6071606C894D920C966383AAD259ABCFF7A5902BDD8F
5182BEC5D3D2BBA3AB62049385A5600AAEA625E3EF4CA1BA6E1D74AEA9BBD68E
A830B2F7719CE91C3507108123012218E06E8106414FCB48F4CAFA6ED78705C1
132FE1476F16F5F8CA3FA65EC43C0A5FA49A6D2FBF7CA2D3579D408EFED2B94F
9977CC1B8792BE2F36B98C436E2B8BF4BB0EFA9E1C50450E0679E9AC5A2FF665
44D23110330D205F7583FB38EE4C6535C70E999561F26676DCB7A8B188010B72
BA41C00BD2A304B6F891D0134D905A63B74378E3FA727DE7F599E79130921303
1C59E8203C3D9221886A6BF44969726426679231E971A1C1A5821370477485D9
49C4E1EF811A1506E814DBC305C99D508ED6E988E091516C71D50E5C8F8CC0F3
7ACCBAFD2DB7195C5D66F547071296C66DE0AE0D1E9633774E848CEE1E27712E
57D7E099EA36360E18E477CA085DC0CE93B48B6E6AF84668530F72F0881A6EB6
22C133FC34B5A5439941A9C7D3DA4A24EC3E85A72C181A8A7546
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: CMSY10
%!PS-AdobeFont-1.1: CMSY10 1.0
%%CreationDate: 1991 Aug 15 07:20:57
% Copyright (C) 1997 American Mathematical Society. All Rights Reserved.
11 dict begin
/FontInfo 7 dict dup begin
/version (1.0) readonly def
/Notice (Copyright (C) 1997 American Mathematical Society. All Rights Reserved) readonly def
/FullName (CMSY10) readonly def
/FamilyName (Computer Modern) readonly def
/Weight (Medium) readonly def
/ItalicAngle -14.035 def
/isFixedPitch false def
end readonly def
/FontName /CMSY10 def
/PaintType 0 def
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0] readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 0 /minus put
dup 2 /multiply put
dup 3 /asteriskmath put
dup 15 /bullet put
dup 20 /lessequal put
dup 21 /greaterequal put
dup 102 /braceleft put
dup 103 /braceright put
readonly def
/FontBBox{-29 -960 1116 775}readonly def
currentdict end
currentfile eexec
D9D66F633B846A97B686A97E45A3D0AA052F09F9C8ADE9D907C058B87E9B6964
7D53359E51216774A4EAA1E2B58EC3176BD1184A633B951372B4198D4E8C5EF4
A213ACB58AA0A658908035BF2ED8531779838A960DFE2B27EA49C37156989C85
E21B3ABF72E39A89232CD9F4237FC80C9E64E8425AA3BEF7DED60B122A52922A
221A37D9A807DD01161779DDE7D31FF2B87F97C73D63EECDDA4C49501773468A
27D1663E0B62F461F6E40A5D6676D1D12B51E641C1D4E8E2771864FC104F8CBF
5B78EC1D88228725F1C453A678F58A7E1B7BD7CA700717D288EB8DA1F57C4F09
0ABF1D42C5DDD0C384C7E22F8F8047BE1D4C1CC8E33368FB1AC82B4E96146730
DE3302B2E6B819CB6AE455B1AF3187FFE8071AA57EF8A6616B9CB7941D44EC7A
71A7BB3DF755178D7D2E4BB69859EFA4BBC30BD6BB1531133FD4D9438FF99F09
4ECC068A324D75B5F696B8688EEB2F17E5ED34CCD6D047A4E3806D000C199D7C
515DB70A8D4F6146FE068DC1E5DE8BC5703C1951831CFD3569BF1CC312382F4A
9021A39FE4F3E8146034DB384C29524BF88E4BE6048C63A48BA6C80B9ADEA258
203123AB85F27C3548508980376E50637473AD666499BD57B178429DE1DCAC99
01E521BBCFF56D2023091D1F29D5CB2949FC70BC80359E6CCEF0296BCBDE7442
E5D77CCD58BDAF2E768D1777D0A6A48F2769E3EF25CC092E09B448FB6CC9B404
0E6C14BFEC147483162C5F1897351F97B8081278AB7DE73951DABA1C6CEEB687
71F9893A4740CA52124801C07FABB1DD4AE916F69136AAC8161398B663D17C5E
EBF3161D96496BB4D6FC34AD0A084A1290F6D28276736BBE8E0E79B1F5CAD0A7
399E0F7B1F1C800CF359524AE54113E646AFA53873BEFAB77AA736851761AC32
6E351C04A704CCB2C3A4246D643C81D849E1F9DD9636C9E6D03DD6514FDA3F80
C3E0B141E32E4D5E4D1D55D3F2B07C4FAE80DF1879B8BFD9D2D8F3A2A32C5023
D3515D985246D4A58ECC79C6ABC8EC8707CF8EC81C501C062CD8E519FBE4A6B2
B629D5764485806BD6EE337C502507A8884FB4829ECAD2DB01290E7EE00FDF4B
F972C690E15C9002C7B3A1DCE7B428C98B91134DA80CA323FC68467255732EC5
B192DC81AF83006480962513F5905F64E4025386FC300579FEEBBD8E1F70CD9B
90F12534E2BDD29933AA529A1CDC5558E053B06CB86B72EF9F6D75C298A3D291
2CCA4C03C404ED77F74B2BEFA01F253BEB6ED9C9A96D4443D897CA32B8454DF1
9E2636531780474467E8BF339018C765D3BE8A8D8D0A073563E11A01525B614A
733E8852674B797A1D6C5F88BBA0268787DDD799F759C30836D3BA9987182263
633642F2791C7181986FFEB3CAE9EC236BC69A70EF2ED747793AF9A3F8EC5B62
35065706B6F18FAA89635E96249848757A0CBD4F64FC664BE21D214EE29C0FDC
7EFB6CFF1D08D15EE89AB2F4B48C90A99FDE2E9F114B7C7832AA3D00E2CEEA3C
0BC9F127CD5E4B0BAB8B6268C590A369BB7BA0B1EE7A3E0F6EE1896B212E239A
8949B8F7353DF2BF84CFBF473246CFB4B2447F6B7AFBFCA6FD8760DC28FFB44A
4AA889664195923A75F1A80B9D469085F9734F50728B53382BD36DD0BF21ABF8
142554B001F7C332A3DED97E30CD1326449966E9169C18E55675347AED30DD19
77609A1980F746389BF39534623E681AF08E2BC01153DAB370656B6E20EC89E4
F78624069269D64F5FE726D8EC96A95C367A500519DDFBA7D36B4A20AB829527
508B7120058131FB86712B393B1CCC32ED747D334FA2EC45C17672567E81488F
5C3DE4CC6F6C53C5A0C5014B6E5B9CCB364F8156CEBC4FF5C02E44F5198C60A0
8F4169C58B1082407F4C30DF5D077DDED2492F55E60F03AEAB5FD74FF6356093
50B5F418634D74D8EF5EBA26377C9D55DA35F9874D243EA2F41D7FB3AE78A518
E56F83940AEF454821C06DFE0FE0335C5DA367D0CC5E80806BA13368F2DDBCFD
E4EC52EB4DDE28D6CBEC050CB67DAB134480014C9209E8490B82BDE9A56B002A
015BAEEF9E08A5B471F2CC0F6C1464758274F6A9FF41BC8C2AE2FE9FC0E865BA
3A960544F320F7246FB5AB91DCB15C84EE1CA2A984E3902568DD7D3C18546E78
64BA38FEF4A2DB91F802BF7F0D340DFDF88DA12243835370B74D75E5D89B9419
1900CD6B7CF19500DB6E5D4752FF351235BD13D93015D4CA6DFCA5E997AD356A
361B2BF56197719DB8EA560822462DD823B11A87F8A04E7EDCD87FBC1E64450E
F4144119F1973D576865AFC698872EF550FAE2E618717B6A2BA3BF111FEC7F97
15105DCBE50CA0A9A0754D7E088ACB60C7494DC023AA5627B1728E8195CB1BDE
34F8FD21A0910464665DCAA57C827667719ED07C2340EE0FBE21F5981380CB82
D77140F7025492A7DE0800CD
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: CMBX12
%!PS-AdobeFont-1.1: CMBX12 1.0
%%CreationDate: 1991 Aug 20 16:34:54
% Copyright (C) 1997 American Mathematical Society. All Rights Reserved.
11 dict begin
/FontInfo 7 dict dup begin
/version (1.0) readonly def
/Notice (Copyright (C) 1997 American Mathematical Society. All Rights Reserved) readonly def
/FullName (CMBX12) readonly def
/FamilyName (Computer Modern) readonly def
/Weight (Bold) readonly def
/ItalicAngle 0 def
/isFixedPitch false def
end readonly def
/FontName /CMBX12 def
/PaintType 0 def
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0] readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 45 /hyphen put
dup 46 /period put
dup 48 /zero put
dup 49 /one put
dup 50 /two put
dup 51 /three put
dup 52 /four put
dup 54 /six put
dup 58 /colon put
dup 69 /E put
dup 70 /F put
dup 73 /I put
dup 76 /L put
dup 80 /P put
dup 83 /S put
dup 87 /W put
dup 97 /a put
dup 98 /b put
dup 99 /c put
dup 100 /d put
dup 101 /e put
dup 102 /f put
dup 103 /g put
dup 104 /h put
dup 105 /i put
dup 107 /k put
dup 108 /l put
dup 109 /m put
dup 110 /n put
dup 111 /o put
dup 112 /p put
dup 113 /q put
dup 114 /r put
dup 115 /s put
dup 116 /t put
dup 117 /u put
dup 118 /v put
dup 119 /w put
dup 120 /x put
dup 121 /y put
dup 122 /z put
readonly def
/FontBBox{-53 -251 1139 750}readonly def
currentdict end
currentfile eexec
D9D66F633B846A97B686A97E45A3D0AA052A014267B7904EB3C0D3BD0B83D891
016CA6CA4B712ADEB258FAAB9A130EE605E61F77FC1B738ABC7C51CD46EF8171
9098D5FEE67660E69A7AB91B58F29A4D79E57022F783EB0FBBB6D4F4EC35014F
D2DECBA99459A4C59DF0C6EBA150284454E707DC2100C15B76B4C19B84363758
469A6C558785B226332152109871A9883487DD7710949204DDCF837E6A8708B8
2BDBF16FBC7512FAA308A093FE5F0364CD5660F74BEE96790DE35AFA90CCF712
B1805DA88AE375A04D99598EADFC625BDC1F9C315B6CF28C9BD427F32C745C99
AEBE70DAAED49EA45AF94F081934AA47894A370D698ABABDA4215500B190AF26
7FCFB7DDA2BC68605A4EF61ECCA3D61C684B47FFB5887A3BEDE0B4D30E8EBABF
20980C23312618EB0EAF289B2924FF4A334B85D98FD68545FDADB47F991E7390
B10EE86A46A5AF8866C010225024D5E5862D49DEB5D8ECCB95D94283C50A363D
68A49071445610F03CE3600945118A6BC0B3AA4593104E727261C68C4A47F809
D77E4CF27B3681F6B6F3AC498E45361BF9E01FAF5527F5E3CC790D3084674B3E
26296F3E03321B5C555D2458578A89E72D3166A3C5D740B3ABB127CF420C316D
F957873DA04CF0DB25A73574A4DE2E4F2D5D4E8E0B430654CF7F341A1BDB3E26
77C194764EAD58C585F49EF10843FE020F9FDFD9008D660DE50B9BD7A2A87299
BC319E66D781101BB956E30643A19B93C8967E1AE4719F300BFE5866F0D6DA5E
C55E171A24D3B707EFA325D47F473764E99BC8B1108D815CF2ACADFA6C4663E8
30855D673CE98AB78F5F829F7FA226AB57F07B3E7D4E7CE30ED3B7EB0D3035C5
148DA8D9FA34483414FDA8E3DC9E6C479E3EEE9A11A0547FC9085FA4631AD19C
E936E0598E3197207FA7BB6E55CFD5EF72AEC12D9A9675241C7B00AD58FAF645
1297991B5D01701E82228D0313FC7C66B263BC79ACDDF9AAC48A3CBF42B96E38
583E1D059953076D68148DC8B6C9527B3A74CE7DEF788A11531F44120BDF0F61
0B2F3ED94EEBCDE4ACD23834C242AA4314B9EF98E4BE72DB76EBDD0A028CEA9D
B4C38C1F2D24B8FDE686832FE96204552C820E45B6BAF0C3308742AE2E071B1B
EA3AC8852A244A3DDFA721781B8B57FEC2806E0DD7C58C9FC2200622CEE32CD4
EA1661D7383FF74BCBF8AE06848FD5A9D55BB914C79A6D9F1755D69798D03655
03B7F6DFA24333DE3A06A64BE1FCAAB289E2EF97368C7F022235180373EC5F30
EBC34BB5CE7A775CDF27613FB3B5F3ED9550809A417B8B31B1D2FA65A09A9159
8CC302479678174A2F92F2879E9CD4EFB9A8EF2D17629754FB144E6894C17FC3
5B9E83D8E9D955CBDFBBB19872F06351EA2279E5BD227E601913AE54444D0C5E
B449D0C287406E9DB907C9B2034A9326EB62E14AA88FAD76327C2A155B006B41
67023DB4D2BFBD225C05893849879A7CE7580C0857F100778268773FAF497229
0DB84133FB205786E25C13EF018305A5DB774EFEC333BC98375192001BC8B2EC
CA17EC8B17C833386FAB90C62F7B62EA7910FDD732C79496A61D585B6792D3B7
BA13E670DB97400159500B9F0EFE99F23878786B43D7BDDA6CD791E4D5E080BD
4E206101FD294AA9AAAF8133D8E42216CB7131BDAA3FC71790523E6EB9886F6E
0F7EE5A37AE3BA111C930654499F76AB89A0E6834C8A40BB86B34A980C09E49F
6EE6EBFB4496AC65BB48C5ECDBD16F54CF3BB78DA230DF406A5986CBAD63A462
CCAC9E9F440BDAF52A0673B5DD23C6E5DB7696FF682EBABC57DE406FCCA3A2C2
491A1984F74D7A0EF28FE3083E14ECD27479BD418A8D7F1D2293BACF68735865
6BCF6AC44E85A6C2B803CC9774E977B6579718DDE6D40CD3ED0186FB119465D7
D84619CF99DDE3479C3FB5A05D69C478611D707F9934C0B32A0849D7B62BE0BA
30B1370BF8981439530E7E9E0EC8495A210A372F08B8B77EEE14D29D1416951B
BE2EC1CCEECE0E105528F684759603C7C8BA72C4A913D535C256EA932DC00C99
389A4DD2AA3CB4B0A39A6041E949DF32EEEE5AE1417BE7E2C9C18D2513155A41
6B406E60C9D888E08FA309DD4855741633EE18E6DF53FD4EB35822306C8CAF0A
933E3E3389990C3AD09B676C0471A1E1B153CC7A457C874A2BE8A46CD098B8D2
C70CDE739564314687351E54AB0BBD2B501FC6FEF036A7A4708DE8C83120EED2
BC5AA3A681F967F55216566EE5A38C28C91D024A040A5D127E8C18D045B7AD9B
4A9A31BD47285BCC95CC36FC743E8B5D7C05E30DAEE52987CDFFB9BB3F00189C
3185F033D8B2634C627CAA17DB034C5D1E73A91E98FDBB4DDB65AD2F4ED3857F
C6CE76AC6B2FCD0AE130C5C4C377CAEA879D1EE3D56686D500F6E8E2A19D3675
90FB180933450F50184D5230460551ABF7EBED3CD0CCF939A9865231C3078C4A
CE4A669F1751F159535DE228870D6EA03F568744E90660D78A247E08130EA4FF
42B9061BE1B3E5D8023BBF4DA03169C5FE26AC435931621E64F0AAA1EC853E42
BE1C0A378D981D183E52653659F9033454443D9EACFF52A7D441197A1B1B5049
3662B30FA9639EE3C9A2EE14BD96EB9C18EE2773492D4369B3989D5311EB02A4
D2AB2BF6E73290DE3629BD94A5345678B691FAB787F9077977517A4A4E10EB9D
500F0BE5138757F7736600076BA28995FCD44FBE027235A421E1856A54D35A66
FD408DEAE15DB1EB72E4B9EC6A888D8B946126B8BB56FD4B89487A97A61F982F
96620279E8DDDD4AD991F0E29BAD8B4E76D5A28694D20771B4DE1596610D084A
5C72FAFCBB9CCE84737614455B6C5B29DA0200818945D1F5218F36679E45C844
67C44198F0CCC8267F6CA348673F8A6656BE3FD4A71BCA0870B682A5494F3788
5B5B08A98A05A888D509813D06E152A80EB57F84B44720218507F9BD6B8B6303
02D6AB31E40703F828AA0243D1214624232079FF9497230266B37D29BE36F15B
CB878683F145252629ACE74E51B7D323013E84356EFAC4983FFD0AE6E20666A3
6C1E59E59B728BCBFCE520889C3E609083750D1B9628534CACF072641C4C5B38
BA0CB576D4DB0DBA645FF8870E3575A76BD4AE4FAEF10D379C58C548A68F2C93
58BCCDBA6E9B14A5BEF2E1FBD1A380D5D53E26330AF5EB3317DB5F180D2360AC
188FE07BC1071F66FAF73C97BFCB91EB06C75BCC324F709B8FBDA96DE7813792
79C40DD7E9C18038B6F4676153ECF9BC91C6D08A8FDED0A2E0FA5E4B829D0E3F
078CDDDCE3A9CD4F69C418EC0CF062C5AB8666A9A3276A237312AED539143EF4
1DAFAE496D8ED80497693D2FBED5991AB381D323D6A7EF3DA5736BA42B69C18B
EE390B6F907F843BDD896794E40A045BFC170617EEDD1C196472C05B13D6F7F5
D3B0D5DECD2F92D06826A317405C1EEFF0961CBC5B2352E8D1F8ECB9DD19C9FF
D5FD1136B87DF07663C4D202919270545896477454374A1CB968F5D5917303E5
3B63C687655137576D01DEF25FFA56DCB685C1FA7A3D0C2564761745B1161277
0F6DDA41DAB8F6D9615EF0E7EBA58BF911F073D1345310655B33CDBC119892E6
C4C944A8C0806E641A804229D06E82E0170E9BD68AEDD106C4947DFF65804EBB
B25D2F41B9174B30FCC7A5113168ACC1DF921377D1B537441B46E7E63D544D1A
81591509F3049E04B50FC6AE07AF82C859A753D1A4A999F0E79FAB3C8B6A7604
7125393FE9FFEEB6BB05690D0D60412F347304B19B957080AA4DE03F7373EA94
2FD735CC6723BCC73033B75C0362445024F510948953F36F14E96A77309F5FC6
358466BACEDB149A32701B16CF33A0E159C784441503BEB5053B3051FD75243B
8825440ECC66CB36DABE41A5986C7B7564B1CDB8035A9C5708B8E7F02B9A7C50
E07BD99C2EFCFF3FFA9624637ABF7EDD555E599E07BA5A1FD2ACA79B6BE91829
75D454341EC0592B4A751BA773D18D4157CDF71FA9FD2F2DB362236F40B3FB62
619E46EA83D2EE3C57E71E39F57C915C1D724AF2352A36F65D01ECC626C4241D
6AFFFAD3A955D3ABB17AD3D0BFFE2770F1374617436DABD35056704247861F1E
BD403185625881BEC854684D133CCB198C5B5FF824E9F74422490AEE68FB0435
45A06719DCC8480CB573D93779BA81758308E94A40D67B46E5C2B30AAA8BD026
CE72C1874A18C34D53A06FA21832E9A0FFFC360AF89DC3B9371985791492F4DC
24EEDB2E03668EA3F4F6511AA6B5C1ECED7BF1B488CBD0292E0386D69F9936E2
3F7378B1EFCC28810237C964FA3B9EA7E7E6409B3C0F7171E583370C424966F6
70241E87638F31010BA30C775EF04DF2743ED5C98C6764DD313FB6C91D95A7E1
6AECB986D7803686B554F1A1F6ECAF53E3156ADF20D4388D485B3AD93B78277C
AB07300BE3B754D94F9F7D17577AFBF0AE7213C6BAD69EF4B468EBC733783CFB
70244762E6485407974B70C202EB77F11FF9261631E52CB29B8E1F59CE885F63
50107BEF4340A10E187C47B0F1830C9930427584E38C85A89D59C7C5E1C9D610
2F3DB0AC3E3B5B68ED556CFA5B60A36EB69452E607B6F8C860DF69204BBA60F2
40123471B704B7601EC8D6585302E65EE87EF7D0A61DA11FEBBDFECA80C7AB70
CC8FD4890E2A14C146420B8FCFA42E42C94B3659B45C2F4B0700ADAC9D7426AA
6E47FEAE5F42D1717C2930CEE68EEBCE5BCB769031AE89B477B313632AE37659
EA49561BF5BA899021D5A946BCAF7AC5B8E01C19210FCCDBECA20C29A151594C
3E5B1C8330880D0070D36D41D3960C5CE4E201D39A7CC16A2AFD9DCDED7E3538
7085FADC02A11A0F190F2C1C0671DF496A5B09374E0EA2AE845D75C1996AD321
38F5D211DB05FA93A17C924970D4DFA3C01717774ECFFAD7228DD2DCF6B88852
83D11DD736FB5C0BD5221BF87DC8239228BA4F6041040CCFC0702B644FCC932B
E2889FE305C0EB263F3E9F9C969B615631553FB6F8C1E3BFA1C2D87AF661E8BC
DBC0C4B1AB60CBCA56286672476B1393D106A6262B460D3C7CE14E08A7273D37
E1A5C36920A28404797ABFE2FE71EB63522F1F9607180925286D5530D8399466
9223B451F9B48B5C9306F641536A545F0AA674019BFB80572CA33CAAC49573C6
5859F9C64D456770B69E1F6E75DFCE5650DEDAFC74F79B2B827D8DB5C92278EA
21E99723194C3F9FE76624D36B30E7FC354B3D23D3D20A6664E4F898494DD504
69547359D959DBE58B07F09753303D9791D04BF45A2BA6A0717539E6E6547723
1E14AF0C3BAA518523F1974EA179BFAC0B2A651E95674E127289A95C3C6B3CD2
728AACD6ADC0543095809560897AD3FD2B0A44C0CAA75C52BE48547E8CDDE0B7
086FDB02B1A867A91ED395C1502927A72B3519458E3D770EC53D17FD03B1AA50
E3137A3AAA7C2063129E020E7D67BDAC43047EE867DA92D505E44896A4218A75
78F6F9BB397CF8D6BAA787B750F9B854668072E205AD0EBD01E383534EC7086D
C72E2262BB3B13C25488C43DBFE42EB7537B2914E89A2413D6E22073CB6AA5D4
BFA8915BD5A43B62AF2AF2AF9C947154614C9F3897485F96FC947E9CC27495C8
9CC7BC986BD42ACE38FA55F3CBA19972260C0C203C3C3397FD6318CEC49AD66D
7F1D2DBE78D45D6D790870A2CC08F6EEB925078C19E82138240A1322CBABD8F3
15A928FF056294C034C9D0D0BA909EA15BFCDCFEE45E34101A02FEA1FED01FEF
A02EEF5861CCBF8462EA441697283FEABD39AE493F472DA263EDC475EA4ECDE2
DD883F052EE5E14851EE7FD4C9E0D0B7C9845419D28C142DEFD5D2CDE631D156
0CF71013B3FAA9C4B87A44F2D86C6494F9F60471FF077E37569A6324A3F8062D
B5575585A2560F01A60F237646C05D4CC25436048FDE6D02AA09C6716DBDDFA1
C7CD6E1169680B167040F3FA6F7A5F53657C8E02FC0EEA9F47F67EB9C15C492B
D3D26B4425B3651D4E4E215A64D0B3E1E363272425231A07C5F447941D20EC57
EB505BA1903E204A626D061E6000984D45A01570F38D2228A38C8BB3D978E112
76BBF15D6B3A2F5AE69CDB46006B28850D0B18C0E6E9518D7459227FF0307731
7FC85F38A3CFC6D5EF8AAAE3DB2D72B7C9F44AC36608792DCAC737B288BE6F4B
0EBF8A432162F06D79AA1AE8829333A2FBC361528A2FB73FF41571EE62097FF4
4E723AECA8487C4DF078EC698A824D9AD387431E264DE3B922BB60A65E061EB0
13B9DA4A043FEEBA950632F62C9E095A741BC32019AEB7EBEB7A044DDEC4109D
F2194C416BFCC0279DD4B9CB90644A490A342648F2D2BDB8BF594B2668BD5FA5
65A8F4AF1CEA92C42E09675386DBBF586F7D139D325E8CBAA1AF023270D128E4
4AF7164A4FF8DE8EFC52A84DE1335F365A81651799FC8F445EF41E69FE2A28AE
8E5AED7AF0F54420B27DB6AEFEBE13D43AAED321FC395E4DFBC6942A27346645
1BC73F067D231B980722C18B2F0CE48856BAFAAB8DE45DD96F3C4D9614A22114
C89018601B3F1B5077AAC781F8819B552B61E3B8E2AD0CDAEE12DBCC3BB782F7
AFEBF45DD4A2BFB33DCD251F95ED3B15C67C3C1422F5BABD476205D33ECA6054
63A2FF9E179E981968914D99C021823C72DC5D82895C380DDFF82FA0E3751663
C8AC29BD84501263EC6951A77CABE4B6A4F1AD872EE383D9424831CB0A203B50
68DE1C5382D8240698F4588384BC9649B5ED009375DB423711F154F77F9872D1
E54326DADE996BEBCB0DCF7714DD13647F5575B7C573B2283553273DF8D0D5AA
33653DBABE58D55A9F72382EAA6952E2B5904A3A14D987A0B160B83ACCE97BA7
7A603F62EBD7B90CDF73E6E1D2599519ED8EE92151E3FDA4A14A166C274D98C8
003E2878ECE82903BA550A98B78AB5FDD62C859B6EB535CA026999B8A94B2A12
760FA38F6583AA9BC4767000B53CCE8EF83D729A76E36C7567A6B2D808671CC6
426AD82B82B8F06C6BD770C95368C42AF4AACB32602902ABFCBF12A01FF885A4
673A3A879A6347A179B13830B3178F3F1C3E3F9B4357B1F2A35A4A51B4433FB7
4C7617C52288AE2C90D99C9FB3967909C99D93DA933C323719FC19DE9209A323
5B6AAE6208986C3E43AB30BD711EE8D1CCCB80817AF470F41521DBEBD54D2B3C
8D1F33946C14412B41A8363571904B51BE2C7FAB40A4E33F0797D144797A0317
ECF864539DAB9667847A3EED8FED0547AA1C8D2F211F40703AB6665D8F29A00E
A24EBA0353451B591A4DE2B8DCF1F645916C0CF2571907D230204128BC258390
78B07BF7C44E67901504B21599C52E3628904746BF693BBDF24BB9CA12FEBF52
AF0B82249F29C447360BD66754BD246EFE22A97EEAD97772A526070BCD4C0A64
2E8B59518FF93F9A427A0FE1FDE5BD4FFDA0956EC64BBB2470D3699F7FCD17F2
66F909CDEB9675552A4742A47CDC22DED47D9E0F01737EBCF266962E0DD86492
8C3084519EE6370CAB98BC23C004F6201EEBFA346FC1A9073912A5F71CFB40C9
4262BEED88C4B5C09F64384DEAE72F65CB3A18A4636902D1097012738A30A99E
7F680C4623A0DDA9E73D911980AB1DEB2697634B7AF18958EFEB8228EA18ACFD
A3EE0C5C757EF5B42A3CF940E39CE22B2FAE92E5A809E14731EE0A9AB0D86BC2
23BE1E1010F0C6693BC785C103838AC5995C9ED47C64E7E903BC95A7A4D198DA
59A1DB1FAD21CCD1A1D4F5F529774458968B879DC5A5B45C62123872D828C84D
659D08E992398ECCF23015CF9515DA1E948AC961DC9D839C7734FDF9FCB34B32
3FF543BCC25931C0613F6B19978E980E719EA91C7F6B064CF1C2DB27B3351756
4104DC3B34109F80022F595497C88F641BB93DCF78453CDA2363FA9D31109E7A
67D8792E74DCFAD36270C71FD2F92E4FEE5BB8E72A729A969EB0C29D4210F2D0
CB9DC70213F5391A074691611E329B608BF47BA961DB31615BD2785B588986F6
6DA1DB41BE74C44D24F7CC16F2BA0533EE7547365D40141438CCA4D5C7A35239
183FF69F3284D7F720CA9C04C56AB1BA682254A6BC813CCB7BD37660E1F9C556
B94E85E7DFEF7D07CE6607662B76632FE2597DD47C414DE5AB7876F9DBD32931
055610AFEE25389C7F20B4D8E34988F50916C262311B381FA9F826FACD341A0B
F7228A4C8E0C59FF914653A6828CDF7BA26B22BA2605EE345CFB4968FE819DBC
075B173984EEEEADE9E3E01E602CD75C13E266CCE35D1C57D08CDEF16739C808
92EE59D38FA5287A733E2467B6F740E22B4887406C9F5AEE8D82E2BCDDD9A8B4
376E36CE4700D0E0779386822CFF3C5DD1997E14839A8C0A909A65E61D2FBB9C
4D9EE54518D772349D6B4796B6F765A5922CD279FE4F9CE17AD2E9A48F4A70B8
3E6A43028838475353F33F459DE86E8B1B8C699D1E1BF94CBF4FF7DA3E907F4C
EFE9648E9A2743685CE4CB099529EBED0432EE5707603900E392F9FA156A87F7
B2F54CAD9AC2B8B726AC41E00566527778F3888C6EBEE36E201F1E2F1FCAF3FD
3EF5DAC30145AD7FCF028CFFC92DD910A9E7391C5BB8F51ACE4197F607973BCA
1B21FAC7CA754C034F6558D243A4A445974C5BBF1ACE0AAE9FA6E0BE67B98E1E
C3234167CAF0057EA0F3D493952131D3890159570055559C58510CE4DFA47015
3402FC5C519A940F56F4816DC60A2844C3F80B7ABF92B46217BC1BF253250055
ED18677B45FD35E7800CB01FC3D63737D93E6C1267BC7CC04786BCF5C93A4BD5
6F56736AF8CBD32E4417881801354ADA3508CCF1CA0A15ABA81B9BEAF1F3A6CB
0814735F6A571C255DB92821FCA859FB377EA980AC09F2D354E352826334AD5F
9512CA9B637D67DC8A2B24E29C0558D3BFC3A8ECF64B8DAF05C17E897DD4BE9C
622B4E9E589BDD6375F60431B292116CE6423404D541DE39B5E26D044A39E138
A336D18484DEC0BBFC053CA3626BC4DA04F1258D6ECCB572588DF9A3C3B1E865
A105384D9502F85D027D1F02B72A1637C206773D0A16A86CA2C89C56C8AF51F0
F463EF68E71A70AF72F0D76E193EBAB3A680959E4FB90776269FDDE9ED3225C3
F844B3935959458A03BC0AAB7C63F69858D678DE447A2E785BFF7B847FDDA13E
18418F63F048197A9908341A38D7BAEEF11270D7B8C8A3913088B667D584B8F3
FDD65E115A313BD2A7A83B6D48683A856BA8C9C296DE59C3F86777C6FFA3B436
18B6FC3D5BE9582CC9858199B8EF1C0DEE4C0863201B9C1967BCBCF530C03DC5
F80D458029C0D475272C06B7C47737AA73B166C41BDF16C2B65F42172D12B661
2AA15FFC302D4AF073C5AA67AD1D2DF80EE0CD8DBFB44FBEAE12F25D0E2A98ED
A2A2230D06D86A5C1263D8C8A6AA523D35C394820D1E3C18578BB0A26409B012
F4F34647A44ED30E940BB7FD75195E44CE20BA89F69E37A9EEB929DE23BF7EE2
01C7374D030DB55FB8FA3AA2D015D0BC4070B807C5ED2321B4BF72B6243D6314
73638E391A3CBAD828672F5D57C896ABBBF2574D9870185465C993CF39AA118E
D5DFA79218F4F3A882DD5F3AB5F21D9D721357FE58D37D5E86E23C811D10B3D2
A24C7493160674CBA2CFB258758F1C7C9EF72B68D8D0003E5355B11492
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: CMR12
%!PS-AdobeFont-1.1: CMR12 1.0
%%CreationDate: 1991 Aug 20 16:38:05
% Copyright (C) 1997 American Mathematical Society. All Rights Reserved.
11 dict begin
/FontInfo 7 dict dup begin
/version (1.0) readonly def
/Notice (Copyright (C) 1997 American Mathematical Society. All Rights Reserved) readonly def
/FullName (CMR12) readonly def
/FamilyName (Computer Modern) readonly def
/Weight (Medium) readonly def
/ItalicAngle 0 def
/isFixedPitch false def
end readonly def
/FontName /CMR12 def
/PaintType 0 def
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0] readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 12 /fi put
dup 13 /fl put
dup 34 /quotedblright put
dup 35 /numbersign put
dup 39 /quoteright put
dup 40 /parenleft put
dup 41 /parenright put
dup 43 /plus put
dup 44 /comma put
dup 45 /hyphen put
dup 46 /period put
dup 47 /slash put
dup 48 /zero put
dup 49 /one put
dup 50 /two put
dup 51 /three put
dup 52 /four put
dup 53 /five put
dup 54 /six put
dup 55 /seven put
dup 56 /eight put
dup 57 /nine put
dup 58 /colon put
dup 59 /semicolon put
dup 61 /equal put
dup 63 /question put
dup 65 /A put
dup 66 /B put
dup 67 /C put
dup 68 /D put
dup 69 /E put
dup 70 /F put
dup 71 /G put
dup 72 /H put
dup 73 /I put
dup 74 /J put
dup 76 /L put
dup 77 /M put
dup 78 /N put
dup 79 /O put
dup 80 /P put
dup 81 /Q put
dup 82 /R put
dup 83 /S put
dup 84 /T put
dup 85 /U put
dup 87 /W put
dup 89 /Y put
dup 92 /quotedblleft put
dup 97 /a put
dup 98 /b put
dup 99 /c put
dup 100 /d put
dup 101 /e put
dup 102 /f put
dup 103 /g put
dup 104 /h put
dup 105 /i put
dup 106 /j put
dup 107 /k put
dup 108 /l put
dup 109 /m put
dup 110 /n put
dup 111 /o put
dup 112 /p put
dup 113 /q put
dup 114 /r put
dup 115 /s put
dup 116 /t put
dup 117 /u put
dup 118 /v put
dup 119 /w put
dup 120 /x put
dup 121 /y put
dup 122 /z put
readonly def
/FontBBox{-34 -251 988 750}readonly def
currentdict end
currentfile eexec
D9D66F633B846A97B686A97E45A3D0AA052A014267B7904EB3C0D3BD0B83D891
016CA6CA4B712ADEB258FAAB9A130EE605E61F77FC1B738ABC7C51CD46EF8171
9098D5FEE67660E69A7AB91B58F29A4D79E57022F783EB0FBBB6D4F4EC35014F
D2DECBA99459A4C59DF0C6EBA150284454E707DC2100C15B76B4C19B84363758
469A6C558785B226332152109871A9883487DD7710949204DDCF837E6A8708B8
2BDBF16FBC7512FAA308A093FE5CF4E9D2405B169CD5365D6ECED5D768D66D6C
68618B8C482B341F8CA38E9BB9BAFCFAAD9C2F3FD033B62690986ED43D9C9361
3645B82392D5CAE11A7CB49D7E2E82DCD485CBA04C77322EB2E6A79D73DC194E
59C120A2DABB9BF72E2CF256DD6EB54EECBA588101ABD933B57CE8A3A0D16B28
51D7494F73096DF53BDC66BBF896B587DF9643317D5F610CD9088F9849126F23
DDE030F7B277DD99055C8B119CAE9C99158AC4E150CDFC2C66ED92EBB4CC092A
AA078CE16247A1335AD332DAA950D20395A7384C33FF72EAA31A5B89766E635F
45C4C068AD7EE867398F0381B07CB94D29FF097D59FF9961D195A948E3D87C31
821E9295A56D21875B41988F7A16A1587050C3C71B4E4355BB37F255D6B237CE
96F25467F70FA19E0F85785FF49068949CCC79F2F8AE57D5F79BB9C5CF5EED5D
9857B9967D9B96CDCF73D5D65FF75AFABB66734018BAE264597220C89FD17379
26764A9302D078B4EB0E29178C878FD61007EEA2DDB119AE88C57ECFEF4B71E4
140A34951DDC3568A84CC92371A789021A103A1A347050FDA6ECF7903F67D213
1D0C7C474A9053866E9C88E65E6932BA87A73686EAB0019389F84D159809C498
1E7A30ED942EB211B00DBFF5BCC720F4E276C3339B31B6EABBB078430E6A09BB
377D3061A20B1EB98796B8607EECBC699445EAA866C38E03ED7D4F3EDBCA1926
2AF6A41F67AFCFBF3630C943FA111E4CCD988A7363F7C2B75EAF5830B049460E
0D2B337988F150B9182E989E7750C51BA83DF37685483F86D1F47478883F3F6A
4B7F768DA5AA89E8F163029ADD4A9209DE8A4F285766C06EA859639B92CCCDCA
F59B1C2BB8D588CA754D1257BFF76B53984DF4937093AAEF79009D32A29A4C16
FB610C7D6713482C48D7F9E8410C0F00AD6E67021056B6035534E79F05D14EF2
4E82E3CA2BBEBEB999628E247CA8937AEBD6DAF81C08E3B32456165ADC4CB893
DE62CBBBA503B30A4E64918A6312A2EC889AEA7753822F97B3C9AC58A6F57EAD
FDABD1FC49CDFC6DCD651427911942585170132232513D5DAA061E9DDAEE72C6
B33280B2C0862ED6B6C58AA12CA71F01EB58F8E705E5446EB273E19DEED523FE
09572BC6E770AC33D17BE7807C757574DE1AD825E4D14AF52052EB91A5EB1797
4CED8B2760F665C41390C3F0D8C1DB723015BDE03CF777F2FF0A3686DF5A3F0B
719D484E09AF5EE9200D3CB41CF0F9097A48F837B89CA5004449327D583281C9
1898742422CD181FB87943488F51664A3A31A8579845D17E79D19B01F5440B69
53A829F822DE4071F2B3828450344ADBE01886ED15F5499DAB1CC9DBF45BDEA7
CFD3E579D2EECEAC177D58BF7555B07970530843D2897FD67495093D817D8A34
1E75291AA1D477453A397E6338818AF3843227F064C671A3D07DD2A18B3BDAD2
E669041F327956A55D4BF0E407DDFAA60355FBBF32C727A2BC9484F9D0E5782E
C71102F7AA027D5E3A03C4D7307143C9F499792F4DDEA5D9CFC495871E4E4211
1D77437986B7FB6F9DC9C9043232D1F43DFA51C3E7776E87AAD1BCC907A64AD4
AE0FA020E2298BC1C4C1C1185BD41427AA22D52500C85EAF6C523B57B921D0B6
333DAA1610EF6ED674D4D8C90931423CC3EC83F069F53FE2D330E78BA7284C49
CD8A3F4F92B8DF41D9B1056B1D306C2D920625256638EFDE5157F0E96049C374
6A9684215E09CD67EB5A7B60BB9BA29EBC65BBBF10D784EFE2F57992A46695AA
99E89587B1D557541A7E4C7FA0162E0915240D473E0C89C90E08E7DC98E8CD85
E8E74D5505316F1A3C31CD3D2F0D614F272FD48E9B7E1B9A42E9A347FC4D8725
B13E438EED532453CF28F26F23930EF2CB622DD4BFF0E98121D30BAAB6920011
4C764C1957BEF516D14CC65FC9E2FA9381F49ACB5E144D3C47EB6DE572EC211D
1FA1BD809084A0F38BF85B19E60A4EFB8DC7386246CA5895CD4C0F96B52DAF69
D537E2274AD40DB619763A12E46F6430A927FED7BFF4ED4C8D0A335B55609156
AF709DD7FA615EFA6B0B5794964C5BAD00B5776FC6B22B25C0151CE452B02609
F30BC5B8E0C3AB7013E5B4019E7B9CAA8B4FFB98095D39476DC0EEFE77B2296B
0DA1FF0A4BC5739773D1B5EE2FBDAC4E9C2F93BA5F803EAC33D366642E00FB79
4639D1EE2CEE7C54371290FE57E6134AA6A1B174CCEC45200882079EB237C6A2
3A720EEFB86422F81323D07105AFE1D0BC5AE2307BAFFA9ADD20D23653F386A8
9B79FA5F80AAA6944C6AE2B165099F2331DE6599F9488AA1FD74CDF68CF126A3
A23BA83DC1FB0F6D9BC2D23E60A4FD6254E98A294F6346EDC77DC41157F57B63
8167FBE6D86AD2507F17137CDDE8AF1D854451A172BFC3548EBCBD953AD53629
F62DC56B17A66F6E923BD763C118C0C4BF7CAAB1C12EE14EF6B97C7C14401141
17087EBE3F2B5CA336B5EFDBD7C1C295BD7EB9C4862ADD602C7436C240AE5260
AD6766DE5FDDDF1BB1D1CD14A44CB5082D9D5B99FD34EE062069E8B7D2EB2D0A
39B15CBF02BD966566FFE422975FE2F7F62F71632846F5147FE5E3F45AA1716B
F439BF808BE9907016BB1DD9D2ACB9BF2C2B1BD057C29A04788530F9C09DD3BB
F69D72166E3476911B57242A95B767DDB3D3B40090FE10E0997025E77F9BD1B6
07009EBA0E5BB9C3D6BC9E8B6BDB357C3D53EFD3C2D14264CC3761B58FA10F83
50D6552F91F03BC10A7DD14B94841913E7BB802C7A5191D6B991A509FEC02159
95CC43681C51EF32BAF9F35F1D548401FE99862B4CEB2639B0F4876A7402DCD2
6F9583D524D2DDA62DF9B47EEE2B9FC96365EA4B193915AE8E32F7B3ACCFFEC6
B0DC109B66BDBC82662A36693730B38875B346EC62C1468521BA4C01D6ACC221
DC6BA42E914674747C3B1B8F0CBE7A5EFC1CF43CD53520ED7429FC1C7E090D9F
CAD56BECDEB29EBACD49CCD38AE5F5D9126EE139F2DD1566840D87EED510F491
C21E16F8799410F611C3B142630B513A0B02A586252917356D58B522D32B6F0E
9FC7B7EE26A15ADB59EF78B846ED994D780754D69FBA4891AD75EDEF236A8521
C60127CEF050EB69CB6CD67B0F21C716DB1DA3351DDD398EB15C319E5B890347
3CE0BEA718AD67BF9D7F14C82798DAEA224BDAF7A1BD541ED4BD8872F7253E70
9E67CA032BB8DC8A8263B16C04052A63C62DD1A043E49B910DD5F903822865D5
CB733E90D484F69601D0532E0DE990D12CB0B633043764A484FD3B1DA7B70E5C
8C85A82DCA0253309AC693A6AEFC0DCEBD69DD5B6B690D490571ADA489F59B3D
321045E6F86CA0D571DD516D9847D48C9642C319F6FB5D2CBE9EE9D760809E33
3404673C703A31DCE0C739321C3C4C164A4228FA09F377837AAB0ED6E1D87CFB
B47CD12F25B2CB7B7630DB23B141B2C1F3AD6251A6F0BBD2BE91FBB6A3AEE67C
ED762283318A7ADCC37B659D7DD2A799BD068A24388269D07CDFD2B376B97255
4C793B1122A3C52F13339FC2FDA0ACE2E0079E134886277E1D35C8B805CDC7DA
E6B9DC667100E566ED133EAB735716DA3ECD21A69A902A948EA71E056B57809D
C74D4A771102761BBABABCED6411022E00920A9FB35EE793132539D50782E38C
E301B6DDBD5CDABBC6D3D698357F5F25484BF53B6564409CEAC833E012BAC6C5
EB497B7513DC48F0A6B925B989C2CAD640FD36AEE179790F8AE8177D160BF519
8D716A2ED4F69F1875530D15AB6323CEAFAECA637FD6243435677BDE668AC0D7
0F1418FC062A78EA21D6E50CC417DB9BE710F3235CF419B4E94C50B3FBB53583
11879BAC11D4D53AA8EF30120057577E40E6511B6C37DD879C27D4FF1C7B1606
BC660F8A37E9002554E1D8DDB54555698F091AF84BAFE3908D024D4E2CDAB8C6
AB695B01B7CA03C5F6D6D7B3273D20E776E4CA979FCE48B2423E25EB29FBACC9
AD9683CB88202A3C62B3624301274D01FD269A64FF7974778C2320CC6A2F4AB4
6AAD48B6ECE3A0103BDEB49569EC7D9FD03D944B3F4F7638F734C33D870B76C1
1463F5C35981B767575373B4BDCC25B8254486B27DE26DB4631FC81DDBB6C3AD
944FFE29284F87F661774FEB98202EFB7A6772CA2EA0E5C3FF08A675160F9942
CD18E69E891FFD844622D57931D3E6ACF25055DBB379E4C3D94AD0E6537083BC
5DDC1CF7848EA27BA5927394F29AD83AD9D8945A1D4BD1171E7B1721BCEB0B84
6CD6229555AFAB403E0D63522A26387C3BEE608EF3DA7571C71168FCF0EF674B
B5A3F4CD9AE372FF1AF285FDB875C57B4DDCD5B82932E6C5986930046134F215
E485890A8461E331EE902AC31CEE9F0D9701F835A3EB443C64945BE1052C97E2
CC349CC5E4D8C7592AD50B071717EEFF34A51F9AC0B7C3809083ACB8698C7026
D7CAAACDE4EABC3CB647F0A9F8966D2DA26020CDA8BD4D51B88884CD1D3A8D49
26F25A38766E2AEBA8AD148D27EE516F07B47E685A98EBC31D454E68D4E9E493
A73BDD0AD0246EB6D5B961D2932B715B08364E55F05A2B98BDF08E29503ECB21
5B90E4EAB89AE3BACF146A703CD519EFB21C19A3AE86BE5F0E971C218E1D3778
7260E234C67501ABA6E7132BFA74640676C27BF43839392186CB953367169E2B
43BEF1B8866E1979B45BF131258985531E2685B4D6BEC87204418F47BCCBAA1B
AC6D809F8C1BA881FE5E65ABE40E5DFBC1C29896D9084D3747D9B3844AB1DC21
3C76D4711BD22B22132F2BBD0C8ED979FF791D281001803DC5608C750909F67E
DBCE542924AAEBE79A8CE77D559715B824A10075844FA99571062B0EDF6CBF09
C2D628E8A0AC5EB64A0D99A774528D4012B6429F8C545AFDFAE7DA3C4DE3425A
F3134E17B714D5DBFD45FD7E2E9EAF3CEB96649F1E900D201A6412DB93BE746B
6F6CD42A4415A996C93FE855BF973F38CC5890FE52B16E3717B1FFD806A725E5
BAF011A10ECF36C36EF06EEE3B03AB68A15261C47CE76D41AE60E4B9A65F308A
AFA99720FE0CE687484C0AE8FB957DC22E63226E3CD9FC00B99AD9D3D518CA48
16E98D380862DC76119813EBC9A6DEE22DA99C4045763C2842C858AC97DB113A
C95695D430FFECC4199778AEBFDB8AEB183691FE9009EE474C7B05B7EFDEF3BB
DAD97654CB95F059910603B69B7A7D36D6BA1127606132E7C29E9F723F3D6D46
7E51723FCA4EF4CB03840AF4FA704BE75D54AE84F40F267833A1EFD7D3270B38
B113D1718DBF7296B07FCE65E50BF9C6763F9036EE84E8F711BD864FD98B6C8F
F55A143053BE2297905D3F7388DB07E607E0DB0E54BD60C92D5A8BB2C3209E35
935DD44425D059825B78BC351CA5CCBB50FE740093C637B27E0F62FDE3404C59
D72E41314AC130237ECBF619B6F7528CB3635039E1FC2C74A6ED5D56ED1B4850
889A812F85218CB9488D9F124D9CA83AE3BBA181742F896E6A898A0589ADB30E
D511D5641DE820FD673C4AF1894D2614CC4CBCA1866BED4BDC45C08D0AD14284
6ACB0BF51FD754CE4BDB420E6C53AD81B44E9D3FB8CD629C2933A7CC5CAE2043
B81987761BB30F5B95CA4F193289CAEBC363F94B643E7CFBBE022D69F903FD98
4B7EE6BBD54DBBD6B8CD139814F467194E160A74E266B68DFD9669BBDFE6B054
3F2E9C2A24D0E4902CBB4C2FEA63BD405E1530869A7EE66E4666AAF5989591A0
E0304E061EB17B9389D35FBEFB96A9C24ACA2A45CE2FD00F5146B47394FA346C
E98BA4086ECD4495B6121D9F6668AC1C8DAE03719DC698CC7A33CE7336AF5BFE
7301393E85F9AB0557EEF1AEC4AB4D0B980E1935330CD8A669A9A8C7CCA18477
1301F19DD59A4182642FE9E37F5D478A354DE9911D671FB763F499438EF18832
9D2C01E7AEB705688E24ABBA04644EFA3792D75612C7D38B21AFF722F97D87ED
E0924CC8D418E138BC4E0C0812309B5CE5F94A5F69EF38C5F06E58833B38CD2E
162024F200E25B1B167470FA1B71C35753F0704B2200945DE4AF1EA5DE775DC0
863F753B77D92F192EE49247636AE5D09C0ED7856BEBAECC5B06374576C65857
B059B162712750A1A219CEEFDE76499FED44334433F4C3CE7284EB30E2D4E844
D110A63A23DA78308B415B6EEEDA0182B32FEB0D4D94ED3B5734F5E2618FA8EA
9B3EC6ABB1068D2255A9EAC9ED18591C4433482142CA897F62596AA91E4BC79E
565A68C0EB346AF569DA6BF730112E8226F8DCABC44C1D54AF2E3E90FDF4E1FA
5185179167486A39D38D4417D0B502288B5934069102012819476F1E8F7C6189
A77379E3FA11B35997A5FE824B2D02551189C9EE62C017D682804B880D6BE193
031BF7CCFE008BF84D97DC73E4657F14F6DB6B70E6206D200603A931B336D4E2
F9F07D9EA9ECF63B1624D20882D34A5F6EA94D3C4CA046B3A7CFB49B155CB503
10ADB375A416B71D6D0E86C0B0374BD49747B555CC5C8CB860524C003CD6379B
598AEB923F1761211E0A83A6B65939DB7914BC328DF00140CCE49550136071BD
60063BDD2A203E4165904A638EC3B6ABF65D1B57660F8DE95EE8C5A37C180DF8
8E3D6EF843599EA455B3D5674F6B3C8145A364EE8CEA8DF423F68231669B51E8
D054748378CA5F40704CD2CCBA43BFE90D52D55C6FFB2918C6F42EB453AF2CEA
DF4837D5852E02E9C0C4C7BD57538EBDBA30DB0759F1AB157016CB381CE97A88
85A50DFDEC6F9961C9D9697338D52497D4CF28FCD219785F033C1CBFD507EF90
FCFBCB638E63231C59C1DCA65E24B869E30F206EC6799AAB9A7DC8DFC491FF36
2F90CBDF569561188DC50601D91F60CAF7531D31DF39EC2FC0C1C57E58F850FA
46F544140F2D343F00440BCAE25B1EE75B631C446B29046E58C31CF4D171A09A
A128BAC221BCE0F355BB4928C87E9474D745A368F3EE9971AAFF808B8ED70C2E
9AAC0BDDF77636B7CBE76FBA46183C45AEBD6ABB6110273174996D925BC24259
DAC2FE3AB3DAEDD54002F4370DFE19B2109FE36F8DF2B33640336E70E8F9BD3E
887722003D4AF23BA50F0B50947B4E23E72113279EBD731223B9333D05F383BB
6F6DE6D146D8AC0D7BB0CAF264DF3C78DCA5B7F74B28C5FD567C34F30A87523D
B85F5F7287D4E6F0411F5CF148060109ED69B7FA3542B1CBD9260B74E492373C
103C05CFD1AF7457F1ACF2FCBE2C565605B59B3A10E3266EA91949C274604315
54EFCA94408B2EFC90E7097F097B59076A6851C48BA1321F4E9EF8FD2C6173C3
FC143D418F379DF0AF2FBC3A18BF6F9C0F34D5F9640FF193720B415D72904713
7ABD5015B4A87E1FDCB23D32FE11440D5692EFEB714A6C315B965349B8F9460D
A17B7555003E49612EB69A6DCABAD19CAB620F374E4AB6F5C3D63E7D84BD4082
8046C50FFDDFD7F2E7D022AC1B11B57BE5776E9937BB8F0E8FAE2251E475B24E
3DEC67CFC6842367CDF65E3A59682CF6A474BCE73251E661A27569C3DFD77C8E
A0F5651EF7261DAC1DFDB36F8E14CEFAD6F09D6F8B9A7098AF77B41D3AE9F80A
25D4EBE141EA833A47E3CD4C15F5CC64FBC6822EF5E1354C71B6D5B01B1AFA55
E73B8A6E55D374595939464631ED840FEC4311E326384685D623AE449D864505
C8781B201E63BCE3B2CB519F81123A84C72A64B5D1A39B0FE7DE1516C9EB564A
E2759690466D442620260B38E11ADD644676D3407EA49335BB5A65B0865F61E8
293E4C6DD9C3A44AD5DC1C3722EB3025E2D6E5A42819DDD5F7A4E2B31A2AD37F
F164CD203E1AC54EE67D91ACF85AC0FF3BDFE8B9BA20DCE14EB222096F3332F2
92FDD897AE0A48500573D9B5989462F9188E82CF0E084C4362CD72AC798ADC70
A79D227A6211773D45701B9507992F4FC949FEDA9E7E139D5A33C08CF1AE2C31
B491F939CCF5B823E66935970BF47D19D12283859BBCC8742D4AC7CE22B410AF
B74873EECA2BC1B7CD673286869761AD05E2F3D28B755040EACC5849C393E703
8911C0BA4F31552E1C831D6221955831DF31053EF35343DE1AB03B66408F548D
F667F920D7E380835FD3B71ACD8EBD9E42C13E964CF142E35C50ABA8F186BEB7
06157079B6D534DF1F89D69789958CAEB55FA2388639699619AEC325B89C5C79
28354707DC7B148D9AA41BA2E5FFB64489E1CB7B9F91A607009E6359172DBB36
490E2D79AE288F83225B850C62E4BC1FC10A4A1025119D3B9DB9D2AB0743E54F
687362FC775ABDFE7BF9C7D3A6EF25071120063359424EB9C16602EEB461B10A
D97B5A02A8751FF1ACB93954C83696C2E99BCF718B5BDC88B1140CA695D367CC
75A09B795C78BA16166B747CB3742B7DA0EDBCEA6260C76B8AEE0AC2D2275DCF
14306B182BF129B82438DED34E8F92735A79BD258E5F987E1E3F06641B8F00FB
C60C7DA578BDF7DBA7083230011485D0BAB35E8813DC5AC8AE529E79618EC456
14E235085EC654C6F15E55A599E499816B0786AD47F901EC23A8CA4E6D0499FE
76FD4710913E257D3D2AF2650FA53606BEFDB3A4D09296F0929FF7E5F249ED39
E39A14FB05A09569CE31CC07C2F7B17B4F24ABB6FE4FC023369FD0055453AB4E
150CC241E2FC1A3DF6636D839FB1506A3141EE7AA483844E7B5732A7299263E8
CBCC73AA623D8E6329DD4FD4F0091DE83A969D4E6BF15A0F0B80485126FE5C11
A1E2D0271C7F8C006590992B7F38B32FA033903FFE55D34200CFA4AA8168691C
3FA918AE0480ED801FC03CDD349E69960F674E31ECFF103A22A8A553DB9B0676
F9F9B1136B26E8D43DA39A87AFDA7BFAB6A98A0EE0DD94B1E94AD101B840A299
D25191A11509FA710B81F0CA5330B1C577BE6E69B66343B0E28D971CEF689B9E
B65FA0BF4AC54F7823A106B5CE58B6659FF43B2C7404B749D841EDD5BA0C103F
F1A9D4A81B7745923BF4FD1BBBB9807D62020527729EB11E2A8CEA8774F4A7F5
55D92251C92D08C0313CDF4F353B366C404BA258028942C2E785C0EA2FFB01AA
20EC1A435DF9DBDF36436F116595A890B45E9FB5E9184726A08BB9EF71EFFDCD
7C5177E25351500B53A045C9CA1CB3BB95EA030244C80EBCFA032C8A5274AD1C
ABB10EC101935C75355EFB533A939176EA5B1ED3CBABD969036C467C67EB2093
54A36EFC0489AEA9F8E92211C33C9EE2FAE70F061F1F4EF0D6C54A3BA31C22FB
93EE5D07E6775E5F8B377725A262079C8F844255FF2862897EA60E28A62BB307
C77782FB06F55C03A2153CD234C7709F88298DF93B84767A845EB8B541900C73
1637BAEC6A4A911C509800CB689B9A51522209BBBBBE23FCE66923AEB4656305
FB8C6543A194547256E17C4DC31AA245052CB16E549D8C4A27B9E5AB05789C6C
0857D48FFED1BC8D6A729BA20C59312C030139EA2B5E8E08EBB6211CCFD94157
B0CAF4133BDF21A0495AFFB8D9804E450F58A4A258B85461A7F11E2D2599E036
A4A111253F971F369236108848C03DF31E849F50BFEB447D03B99282EED987E0
17110FC3E94FFBE968287350BDF96118D7D6200514238EE31906DCEB0377E6DE
7EFBD37479D077384E583D08CE09CE01D14E7780F95C2B4300E4C315E03FADA3
B395A60744973E0AE90C9891BB9C2CF9AD73B17FC9391CD30703D527CE130133
967EF9408F7C588AFA3323F4960683D660FDFF86DEF54CA5DB7A25E14BBE0DDA
22DD7A577FD470A1C8276B0A8883CECC523DB7AE7648FC3E0DAC3106D9FE2C85
5A33BBC0BF4ABA28C371ABFE56C059A1311EC41C617226D257C6F94EF6036AA1
6436E5BC3160C1C38B7DBAA07F7E95DDFD98F3266796B95257FE3270E6AB9898
DECE524E81B92FE3A3401FDF3F1E70063D2059E4BFAB40198AF24F272C2B647E
F8CA2BB8788FFC278FA2665A87B6B33F6F3B435DAC398A28A5210D43C179D287
80795057053F7627E31D41FEC653F154BD198AFE0CF0CE04D8A470C748A23D0C
3A0250CFE48644AA022882231F2FAF803692B8A3875AB1F96F503C632792CE5D
4FEC4A5C432591D3AA94B61EF8E478C2933F2ADF66AD8007DA452E6E1D877EF7
C5119D6B3D7C1DADBFAAA87B08BBE02AA7AFDE669A2977304E3CB4227FE31878
FD29A2ADFCD8BC2B75A5E28EC0C3FA3349E97E2AE57706D560F477EBF79BBB83
1D455C7A579E891D0EE35EC53BFDF9E3F0A6EAE974D84150D040175CED21F047
81DFAF59B258D7948DC87EC7BB8444D5DF563397B6BA74597942698AE27ADE19
2B158CE39562B29AC7F86FDE06DA0EB7587E730A2C5E581CE14F366C4F9F2A4C
8E30F9002373F997465D10B3C1139B398CA28ABB659641BA6310179AD5283C01
D297F54050F231B19D1EA0D81E7B343FF6F1B9EDC4624E2CE5C930A70FDCE9BB
8E31878AE5F4213E22A612AA89D4BF04EC8CAF5E120985FF365E0D1A7EF99B20
8C799D1BE595CFC55FE2968896445DB9C21BD142ABB302DE1F0A0D8768E3317F
C3DCBDFA5F3BC428143F3F48F893AB8A792104D9F769333058B2DDF0EAD28484
78BD60C996A0AADC18BEB23CC240961BC25BD8B145C3FA658ADB39128FDE2CCC
67369EABD4AA992DA1B6189CD09E90FFEA0089FC9707AB0F95492B952DE0A648
F5E94BD5A463FCAC0A7487369165904BAF7FA4A7ED3C83326426DC216E2E4CAB
DE387E0ED3784FAECD5866B93C1ECBA88C3F1F89133D46D7C7B4959C1BF42E95
0C4E311975AB817FAEC5FE066857378BF90BD55AB02CF1AF897247652A53B494
AD47F6E50A7DF0AA97BB4B442FFEA36186F4490376525B56039C6FDC1CDA1A98
6BCECFEE5B161A4D2B8568D78A0B09E4DAEE992E3D04B8DF44F96A235DEDEB77
A4382B63CE8E4C29F851568429633538A52EE2E38AC395277D48B8D0AED95143
FB1BE64FF3DCE78CE9E7FD22BF3B5920659B9CF2EDB8EAF96365BE288CDF0DFD
590DFA92A043BC71FFA2ED8CEDE89818F4349D00C7719614B6CD2E88D49C0877
C44BB37B2A0B0422FA5B2554933C400A96236848D583C2E25EE41E67FD6E621A
0FCE134AFB4B6809D8F63CA8B2CA323D9C3FBECC9DFCEC646239D8A5473960F8
4F83994E8920E14B2C824DC33249B4E6D014266558CD7A5B31CDB804524D3E04
964713B61B4DC3214BFD9804552C69C109546EC3ADAA5D300B9D6820333D78AA
B28F984163209D2150E0FD4649AE367AD1171586F69FFEBD336CEA0D71359401
E7AF4ADD5B853FFFB91F022729A1979625E07CF2360A27A8A050E251FF09D9A7
C541C2ABAE27BF539FC5F15F64D702ECD55B12417FCBBC6942C82A35FAF52CCD
AB1CF511B43EF11058E98AC2CAF02F43C4BF09083FA3C5CE7CA69505AA3E7F6E
1807FD38D9A80DC8A9DCCEA366AD6CDFD625BFD7E7D0378C205073C39AF08273
3993E493C9598DA2C7813250B1EF454E2B3E0816045F9479FB74B81D2534281F
17ABD9D422DD5B647B749A8EB02616FD3DDFED6DA971443D99AC349DA4DC434B
162F669253F5E2D68AAE581D2A1C7917030DBC7F37CEB37490A88C99463B8783
E797D7501A4707DBF1BADDEC601333E494E776D703D265987632A8B4619DEAE7
21831AF5253B5D4F9EEFB2B34F5389F0EDFAEC191609764F16B2D71FD300AE32
707284C2C0D313CE013DB1EBC856222DBA5C39256D1385F8CE095436EC4D6457
3A7E49460421194F69D092CA4E869E3DB139FB0D0ACF49FE3C5B51866D1F7DAF
DB6C7F400DFDDA0035FBE821D41DE56297A5EEE5D75A32A5CA1F325C37AE7F60
45E4892BA80BB379FBFF350268C07F822D75657B3B02567AF25CBECD585EFD53
4A8C4F2AA363A67DE5A1C1C357F59E987BC7CF8D4370C7412B5F4BDD49577E80
D4D9C7CC86876452D0AD3EA17311F8FEA10F54082F6992D89D8E2A1BFF9D841A
A12B22A1E4FC3ACEF71C77EFB40F2429149699858A5AACBE97FD18AEFFCCC0B4
B84000AB75C804897423C52171A4658D357D368201B5FCD25E2D707DECA2C578
8A906797F01DB10BACD2C6E40C1BD677CF96DB56C08687F986857F0141967A44
FFD1EA73E34498F4C2A64F82BDDA93E4D359E2E2636FDEAF0FA899CD68D61FD2
90591D3B04173E15801834BA827A4F0FE0BB79CF66B71EAAE131620337B68AF0
DFEA6317123FF8CF87C798D233CBBCC7C8DD25075602E38FB8C68FFE0AF34218
2353A1FF07C6862396F1E0450AA1695414D63D8622A950A3A31F60FAEEA38C85
E4E455E1A0B1CC9E18D31B9164B42BA21C4DB1863FC8FE8049F2A6B91CBA95B9
55D9440525EA195D770AE25BBA66C4475D972C7102966C80A33F8DF7E0874A34
EA4219C7B6ABF70619A7F4B7DF6566E84B97B2507B8810DBC86DF50131BCF60C
AE5F93FA2E8A61DCCCA87A0A04B03240A21D200C26B816F9ED82F28613373701
36A33F1B3FFBC4DF062B37187A8DA72F2C35A0DB5DBE06DCFBED45784D8231D5
F320477128B04608BC838D8C5CBC6DE7AA1F4752021882D4C7535D70FD686116
7DB85F61C71F5E715FD6BAB59E84396243FF6A90A5F1D143BD6A6434A102C563
39FA94F71379D6289E26C7004306D83CEB600214776C2319A3D66D0E054BAC4E
D3B43C9588E13D640941CE2AD093D095BB2B1067B0EF6E3810FE0C413FFDB126
9BB76CFF89A9FE00F781141E0FD085700EFBEE7D3AB837E52D9FA7CF021E99EB
AB569E9E18204A2067D87B5E9E0194C97DE03F648BC6E6F13BB6089485B83876
ADC885008AFEC1A2173D43B3971F3BBD5C4FE88EB66E1C4CC5762FA46F49D357
E455CCB26CDB3764065E3762C4065BE856109DD1E104DEDB038D549CB9B8E037
05B80EE0DE6BFD3DEE1DDA3853E15C9F4536A8464E3A9C8EEB0AFF4A2DB3117A
F27CA478ED954522F39640AC4DBFD011DCD86FCFF2F733C0403B41B9CB025D01
B10FCC3E72DB78A873F12A9374EB221C4F120811091C9B89410D4D6088DC0023
A42E598416F20BEED52F9FFB1A88F15A802DCD59183F2540EFCA9112D45C7416
5EDC36AC21B5C6F53FB1C4699BAB2609C3BF8EC60BC8398EB7E5D973BE574AAF
46C6E3A4F7E97CDC3789F94DE1FE77B2C22DDA3AD354F4D723BE8FB8B21200D5
CDDAF6F3D35F7569CEB4B7E4892D2F3C9EF4E1DD9D6A94FAC8FA8B1D39BFABF2
9C1A979AD971B08EF4DCAE66738FC4FBEB8083D363571D32A770DFA1E02A26E0
A2BBCEC8CF3FEC51BBFEECFA6CE2200A1F7F298CB32AF1D2C1247AE8032E8196
2B64854CECEFA1096D683EE1707F5D972DC985E1D33F4C82C9ACD347938E1469
9BF86896E91EF7924529530151374DEB2A4D860B1F21B564C873E91063CB071F
DB919F6F04E298045C088A1A52A24A49B654919B8B44A9FC877C02E23BA64B0B
C289B178C7CD70D5029D051AAE028CC3EE5044D80CE5FABAE6032C2CAFCB27F6
010ADC045494BE0753D53ED36C060DC92EA2C94B803F63450E4FE754BE88E032
36D1564E52886B205B3B71C111E95406BB4844FCD435BA1261FC63BCF7E325AD
B9929FC24B08CE7954C84E25528D469851CEBEF5B6EB7BC9A1259FEC912B6A25
A6D12F423120DBA4876894B3B2EC539EBF80CBFCCAD3A1216FB2697271C4CEE0
15ADE52D1E9D4530239DFA8A78688C87E500E53D6418988CD34BB5BFA490C813
408E912395012086C675BAD2E52BFB20CD0083714EDB51C7B15B01DDA5523996
9DDA32B487C17D5596B2FE2E6E276A1A62D3918472AE89D612E8E1712E0088E4
316FCAA5916F5C86F254545FC58CD5CA53776F16082509C849AFDA55B378118A
2FE7D89A80EA4AC910DDF6C65889520010771B1A4834B39FD37F17AEC0C791E2
950C2A4B4760F917B5107109724756EC06A5950B2658B5990AB81F2885673220
BBEC085365ADBBEB473DE1E8DC3DE5350DE64722A1E26D18224244CE671479C5
0800363F0250E993E61E1EA2DF86CBB1EF670B8E8DA5F4C78D8D0817222B74B1
D27C4B68C57E34FCB2D4731AFF6CD7C98B8579DE77231A96253DDB2EA380056B
DB2B1DD1E7A731EAA8352C2D3BE88E2679221E30D6E6AFA638FB4E3F47043E5E
7ED5C32583493E31433E72A326276015FC0BDF5C3B1A7C69B069ED0C97D1C52D
46C2327FF31C08CD8F5457E28A2989163108FAE286E655B2DABA00B6EF71C2EA
4773AB8EE05590F4366339BAAAD8ED843790348A800DDEF2A9F1A166D58765CE
884E8DDC91454BA1907E72D9B4427A4F395904D77F0EFA5AC08419E401C2677F
DA6D63BE5444FB1100C0ED47F4E55D36283F1E01BA170A7699A0A734310C9882
11DB98023CA7816FF34F4B3BE1DE5F5CFAC7A71CDE9D519C9E0908305433C792
799138C285F9293D72DBE9F94BDDCCB99F24332A1550DDF0520BB87F9BBA495B
F70C1A34888522E6B677C701CEAF276585E2CB9B95828EB044E4F802531F978D
DC555F2FE03D47295BA666029DB0DC278A8CDA6BA3F5E4106A986535D1E2AD32
C2E16FADAC1CBA9FA10EF6EE267718BC5CFAE39054E8278388B4805055B4FE93
C7A57C2D35200AFBA36754BB727979C6F7D55747BB64DC31A37DB0F2F9E0BD5E
5F1052B881D56F4139CADF7287E926FF13470CB226FAB9AFB0F37523457BD866
CFC539E0EDF8EB6FF441D44E9948E511A2542F0959469FEC5818033ADF80B95B
576C9EE776C5A61C2A31368B134E415B11205A6CA7974ABC986500F78D58B220
C94CDFB4F18C9F78DAB720B03EC38BD3FDA936897BF3FC5A4E62E131BFF7ADE4
1E36F2C53B0C753B8B01B5EE84ED035D9013A5E596B3E30D75EC307227E1B071
E4BB9076431FE41D71D01612A7020CE38115B54BA2877C9AA27C060652D3E00C
78C40A9F6133E51D9079856EF02E520DF72680AE05CA73C815271875375DDA81
5A4D65D013425365EA73E4DA40F890D6C743F0D210BFE8FAD38A8FBAABDB374F
A7B1B3C7F0D220C82A1FEC937287DE2EAE5F165AF830FE93DD2B17CF3FE59288
A7345077087E95DE0C62744DFE16F989827AA342355C609E6EE8F94D4654BFC2
E9EC09593075567BC22AF337360F4353BB4669EAF2833138E92EFDF3921D3543
F19C68933DC9900F805A69F9648F5FF3FDE3796334A5314AD1A44E6569EE8027
565E0C6C85B2018E16900E184CAEBB087641F3CDE0B889ACBB835FC4EDFB3070
5FDAB96205241B1A7EE1A300C36B5D9929089D3028D015D39F11E4BE6C6643F6
609B494CDE8AAD73ACBB8EF57CFC19999C8C33549D36CABEED262E3773790483
C66D1B48057B058FD3515AC6BDBB72AFF88CC3BF73F52A9E335960DDDBBA641F
6F69CEAF52F9C49B6F0BF57E6E543398F9B314CD5B7636A67E2ED30356FF2E6F
DEF9D47F60C918739D1F399A4D5651037827F76818FE0032582C3DBE6FE4EF80
2E4A2C11E93DB6DB936AF09DDF649682273654C01C8C4EDDE12FDCB989EDBBE3
BB912AE307022063C2391C9A1BF30C18F4F45E31DAC1793E1DC426F607CDC497
C347D35ECDC929B9C20E08E3C36B042F1B0609F70B1F9A7668D84675409ED62B
E210887B31195B4849DB58274842F5DE91757EBEF5FB1893BE082321505CE497
5555682671813981F58F00B490A56E09809B9B1FE6115E3F294817B89F868155
B50EB0837D75E0C1D9B9E5C2B0169576235D54D2641062D4F682D11E00BE04A6
B1043ED59910EA9621FE552735B131704A31DDF48522FC7231927ED4F9A47745
E83B3DF0289DF5C37E00EFB31576FE538156BA51069A71EDF1426983E6F90D6C
3D43B5FF7A1EB26AE3CC2ED23DF9683369B83854294DA6251DAF3ADF33B97048
9638C55EF620776132D25B548F7F41868BD8406CDFCBBA5B6FA83F92605E7DCF
7A9F7DFC86BFEE4B69D099CA4469C8136AA1C9A9A3EDA16FAE8BCCCDC24F74D5
9AF1FDC38D8C426FFBE34B48441C81850BAC8CF2B8FA61B9CD28F3FA5964A401
2460D9E568FDA53F815E0723967652BF51F7594EF3464D00107E3B149402EE67
CF5E10E612508661D5E0D7CFCF14F1A34305946AA11880C7E5E2B1F9FE4E3A6E
ED4644794EE2D78F54C19494A34CDF2F1821101B0BC4C31FD7450FEEEF569B61
334427B2F02CB7292462B0603D2B4B59B4FF844BF3EA026F022BE94C47D16C4A
4F45D7669CB6728A400A0F97DF21510DE3C2EAC3C2BBB1733D678CD22898822E
B0F3D13CC485F41F90000DA549211E2F924ADC155D66A5C058AC5D5EB8147673
DF9CB4D57F0E07259837B0141D03DE104ED7AC81D0F4E0994F63EE69A3EDA08E
8F3A890735AA35D34C3683A9302AD89F7AC3B3D7BDE6240D3FDB84A404552792
0FCFA6BC4654077E78F30F330047DF676CF0AA0F0CAEE5CE08DE43528A228414
39ABDC224D8B8D6093FCB2E687D96062151F03BCE3D628EDE848485C75E0C5BC
C43B93AA51A4E4866CD4F48BE9EA801C3B2B677A329AAA92F762BD943EA3CD71
A91D709577CFC3C2982A7A5872CD67530F74DB576BD975019073EBE2B4074E5C
4AA24200A2DAAED01CF7CBF265AFC1804935B16AE8923C041B6FD3B534D618DA
90291B57B4E04E09BFD98CCBEDDA276247189E9C741B9C3DC2600228053060E8
44010079BB8B213CB388A854D2F094CBA64151A8C39B07E561F95E51A2C557BF
641FE8828B0261E51AD77FC1751D398B035ED8501A7BE1F25FA7D9EA72334D81
8CB12818B44993119C53E65707BE7B0C8B1440950FF3055D4898F6D44A64BE1F
69C3B3C2344878AF568AD18B6E23D6119B7DBEE8241D529E37C7FA17DD9A9005
87D5F20E5A1CF055F9CA49271C50A94B4286B0681A03BB07E02B70DDC9D0656F
98BEF0FE5737AD1B249F755A6190D04445380AEC831F42E5DB2FB2D7E5006FE8
4F1593133A6D549A3AF72DCE98A81CBE35915C5BABB4F3B058CDE76FFA58CCE9
F7F80D868F744D1E6F0860847ACCA27D2079217150D2516138DB72E1B90182A5
DBFE6E9372A12AD82599714C0A645394C78C547500BED678D5F69C66FDEF976C
8F8F8B585BE90856D2B950A10478879F636312EC747B35891E1418619EDA3AEB
667D8E8D0176BE50E2139A117665BD3B0E6F939831A42468FB167AEACCC4A12F
934D27C1BF30F36D1117520D7CB35B325BB8C6403882CD20AD649AB2CE26F1E6
677D8DCEEE8A700CAAA35E3CF228E9581B41DD35D0A23A3C9E723D6ED9550A07
FB023663708D8C5AD50B5FD125DEC74B1F0B92D0EBDEFB5F68D0355087D74673
B0442F408E9B22B56F42734F3C798AA6DEF14CDF7576B09177217BEF7856AC4A
0E7DB8B5D1B866FD049CCB2BDEA9A6B3425D65DD7328F415514812D1EB2990A6
6A15DC322F7B8449E5D072DF21E220CA26633DDE384E31CCC5EF12BE317FD5E1
DF81550C698A69328C25754D8AED38673337225F54556035DAE32FBB85769873
38C88D313422DDC1BBFEB77F8C44CCED1B5ED2CA1B38999902714F8689E4E51C
718AE7D6DE7AEC302865B389414D51FDEC2EC4452703FF11FB179C027EB4138D
49373B7AE32446D46058BCDC1C2D4250E987D9BF38C2A48ED65D222808D7365B
498CB76A8487649DEAF9D03EF6A9C94B1F7DB42E0C3C2797151EC0BCDBA90436
FA160760AE6FE2705E4D7A14708CEFEF17F2683370C3D43CB3EC37F78E37AB62
26A5810A859136C483191464D1E3E84500B7CAB73CA38DEB5C39E931D1266013
BA5BBDFAEBD8FFC3DF7D0227BCECDC907E577B142D9BB19E638D34B99B7CF448
EC6DE591A464022B8E3A41F45ADCD3BC8F1BD67B85CCADBFE624F9216DEE1A7C
32E19427F1DC48BD8B902D50B443971747B2B5B7E1D839BE00D05F5FC4117A79
94B749007733EF9400C4E3DD19069B24F825702853C3FAD2C164A8FEB920CEBC
13CC13F88DC60704B545CA50983B9FF07D9FF7B56EF0D39D745A717383EC0AF6
57C411799C77AABC639492933628C8D4BB5FE41B707659CF05A292CDAA570A0C
2A37DC0CE6C2E0A705EF5DAF87734AFB8C437383D4F42333B23873DE4D2A6A82
CA2CEBD0E8CA6360F76A8AF9E345E0DCB8DF16C3550D971A0EBC230E03142B2A
B697BE765B8CB231175920A3760B2831A24F6A8727F06E321FA07927916A16E3
801253AA39AD031448861C7F89DD558A
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: CMSL12
%!PS-AdobeFont-1.1: CMSL12 1.0
%%CreationDate: 1991 Aug 20 16:40:41
% Copyright (C) 1997 American Mathematical Society. All Rights Reserved.
11 dict begin
/FontInfo 7 dict dup begin
/version (1.0) readonly def
/Notice (Copyright (C) 1997 American Mathematical Society. All Rights Reserved) readonly def
/FullName (CMSL12) readonly def
/FamilyName (Computer Modern) readonly def
/Weight (Medium) readonly def
/ItalicAngle -9.46 def
/isFixedPitch false def
end readonly def
/FontName /CMSL12 def
/PaintType 0 def
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0] readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 48 /zero put
dup 49 /one put
dup 50 /two put
dup 54 /six put
dup 73 /I put
dup 97 /a put
dup 101 /e put
dup 109 /m put
dup 110 /n put
dup 111 /o put
dup 114 /r put
dup 115 /s put
dup 118 /v put
dup 120 /x put
readonly def
/FontBBox{-56 -251 1102 750}readonly def
currentdict end
currentfile eexec
D9D66F633B846A97B686A97E45A3D0AA0529731C99A784CCBE85B4993B2EEBDE
3B12D472B7CF54651EF21185116A69AB1096ED4BAD2F646635E019B6417CC77B
532F85D811C70D1429A19A5307EF63EB5C5E02C89FC6C20F6D9D89E7D91FE470
B72BEFDA23F5DF76BE05AF4CE93137A219ED8A04A9D7D6FDF37E6B7FCDE0D90B
986423E5960A5D9FBB4C956556E8DF90CBFAEC476FA36FD9A5C8175C9AF513FE
D919C2DDD26BDC0D99398B9F4D03D6A8F05B47AF95EF28A9C561DBDC98C47CF5
55FBD18DCEF738EFB8E96B4B61D9C1A24F5FE2B29EF89EA4320BCB1D16E30E22
AB926EBADAACFDC5784740982ADC9619BFDF3586F8C12E6F6E588B44226DCB87
DEFC33CDC78D0E39CE42F3CD39130758A1DA6723A3BFE0FC6ACE02389569609D
E0A2F8219BCA30B5669A6EF48E4FC32BBCC3CA7CC2C7615DACC771E59FDCBA30
17F349B2BEF4EC6B45905D23BDEEC669B3BF525881857B942BF724608CBA8DA8
37CB92A472B89421D4BA156248D4F4F7AA90DA4EEEB4B3D57A4C2F0F41B7E669
9AA74D9F4743AC680A1EA18B567BBD8A2BCCEAC1795CCB5188C77C5B199027DF
F158135941CD020826973194789ED9B5279136A8B9D0D9979E5E80F95A223851
BC17E0EBB94FDAE8F32FE889774D72FA17E179F5AF39385406FBA973734BCAE5
4DD33DEA30B1BCAA9207D96BDBC6AE9519E3603AC39A09B2A52ADDF935FE10EA
A759515DF32688D0E95B1D37CE23E9F45A114572761B088BAB7464D8A1BF7BEF
EDFEC4E472006F678C5E2F6E61AF9E5A5D6DB85600E53818535889F6C31061A4
9A6C369C2680CB769A5540D5A62429DAEE4E2AF5971BC12DAF37B3DAEB66BA94
2998AD18DD63DF3A15EB2FC41AC343063AEAFCD5D2E1BB23C444D4671A954A93
D554797F45A27AC629EF606552DAF0A70B539A55D6650446540E197351E18723
1A81C4DF4BDAF4FA2F411723FC05B9C2B63676B9AE9013902CF9687200FE6F77
30D33F2319AD36876F2F99783468B94DC015433E24640A767F249797A7B240A8
3628220DFE56BF68BED82B9FEA11E4051191DA2A8C47F96F335DC419013B4E02
384093D41D434DE4C9E72A949A01735F973623DD906841198C0916348D047C41
49DDE6929C791B1C2F6F90113F2C7DEA7665E7BA702675E9F9344CBA10A10564
D95E78D9E8F2BF155C7499A4D4D702C827314E2CF1D41E33B1B2A8163F7B3188
4BB3B3B86F8033720E8F95334A1C35D3588D0195E66783364F1463410DE9EBF9
E22A5983ECF9313E8B5C64E0D8E7501C69A0DA47EF3CC6C0C90DEC51B6014D77
08798CE96AAA896615225927FDE217C0846D46FD31C5D9630D53B0EFC0D742CB
5B5C5DF1B5F6C16B864B1DBD9F81D5F542E011A14F75328CB52C923A10043417
C90155E764035FD8FC38BA31E49E2246672821E833379A367025B77BC6DD9C87
16E95E988A4681B8B33B08657E5E83D6CD84C3D33976364B843BB6E9AA2588E4
4D0395DCBE94B72746548CD17CDB3FC225DC04E4FB7A98B899C85AAF485B73E1
C41E9A00A15021FB20A7EE0142E01717DE37A033C232E7EC3A6D302DA99B9676
F0BFA75EA4D07BF5F99554D4D8266A45B6927F695FDAA4D5255DF3CAB797F394
CE3F4ED936168BD40671A68F4CD840805841464E2B147E3DDD2DC37B57D3BD57
60CC0C12C1D3E32D9FF2BDB12740F5A1C50D9E1F33471901052EDA300720CD55
29BD21C1FA2AAD46AA32BA3668E31187214050D9911C6050F4DA4120CD21E848
9D5AC93D0F723BD623DC52EA267D010EA0E28C306612B81C2FC0B4480C384EFD
A627DB877C2E3DCAB386C3FC375299DA87BF72D59B49D570005E329B7A47B864
C26700699A6EFEBFFF21C5558C6BF3B566C24A02D40123E105E2FB838891774F
0290B6B60A6171FEAD4BD474D7ABE47105A4CF4B49D2B4B3D2CAB54A50818FFC
04F6A8C9C842DB4C28179BE397889C18F53BC458FF234C11ED42067F63583E47
8FF55BFEB4BE5A76FAFDB3735D5B24D40674266AAC71BE7DC661037FE7F5588E
801FDC94B6FFFA71A27C678BD80B665A237FDC8459670B04770661800306DCDB
7E10658446B12949CECBC33F56E2DDCD77185FCA0F9FBE27A100F3652D387582
12A0501B80313280A06DEBCDBC941D322FE5F02033C25FCCF012293E99583A6D
C496EC8E9B2F2C376376FBBC5BE0524DA9CB92B745406A71AB0D5E48DD973C24
126BA82F8DF0EAA5A238FB1681481F344994378BC2F05091F8EDCFE86F376063
C868989033B516F3E844FC8FE3D21A10A88CE69AB1D385365EBF854FB48E2289
E2AD4197EB984720E3FDF4DEC0CA8ABFDED0D60A62080D84D85AF2185D281A8E
3653AD4EDBB5B20AB93DC986156F389169160FC68190B8A0E384A137A83085BF
1054AD621522793FF05ADEC368650F283DF27B0CF05168FD7291EF50D2523D15
D3B4EE63F568252728991588DAFCA296E364A4FA102A751995B20C89B9599642
A70812C63A2BB6436339F461571E303C6AE38C41EAAAC5C0FBADFF90885FFC35
DF3D2E4481ADA8B5C0EFF6FAB8A2CDE204BE859AE5A383407F68C0E295A53B57
CC7441B3B61F4B29CCCB089D41FC188C2E9532301B00C93CAF744B8736469091
26FED34DF34FC92BF93456B61CAC099B9FA35318DC3B7BD81BFA2D57531764AC
2FA62FAA6F486E7F20D7396F58C68A2051CA7B43D58F06B4A8C11B34C7D161B6
2A5C56175BE91E4E6B1CE0ED610C273881004ABDD4C213FBBCFE1752D13A9A38
A0858C1B0682A836DAA0E45CB295838B8C1A63403FEAE09C7CD6DB341D809320
919B943B0BF41AA27C60EF9E1D6DE887552804B6CEF8FAA4EE2A5F565A221E06
51B89984A75775D9DD0D9D11DC41BA771BA3E0EE0D3F3CF8C34BCF6B59D52FDA
D937758DBB5780E4BAC73C1682B5A1506CA45C9F89892D40AE5CE4941FA553EE
4C15F2855B03F48FEBB6EC03EA06F8C1E61036F993B0C4E80D8EB9DB3517E2AB
C0279388ACE8AC8697DD5D1BB51DECE0C3AAA699075E46D45A453D07151A26E2
A89355DFC12A9445237EDE758A846B4799403FF6885F0ABD286E5B9CCD59E565
395979FC77FB8B676D5E1D05E8B8DCB57FB83632C37D7C2E5ABB42B0495737C7
915B77E96DF26F47510622E296E4B79C12243F1334061E375D5C7CB7A90A4E77
FC9826A96F01E7C664C09E04D850E824A11961127293A890D3EEE9E78B582294
1600017281024A9AD344CB053B6CA0BA284A3D3763BE1CB373CCC14067BB5C42
605177F523A7BEE48F106AEB1165567BBB8DB9D48ECDB35286CE68FBCE7C2613
7D84F10C0304C383DF547399F44C76D80D076D3A2BAED88468A5A8CF6DCDBDE7
A07085C6D7F9A6D3A6EEB8FEBF9B0EBCAAF5F2F8834831801DAFFE5CCBCC7816
420185896ED1B1ADEE0450E4AA17502F3E809E67EFD3748B029F375A076B3B80
4E078699DD0A461C443D2C2F063FFBEB418C04C9077715F428C6C647D37BB070
C3CC1D015C4FFCB89DF07EEE947C4794B821940F9D4EAF4BA8F8B6C55B628AC4
6B6D99426FF5D738774958CE41EA241D7111D50FD20DCF57BEF9BBC5C90C6F37
7C5F339AD5538BD089621E4B5457F3050B62554740CA63454B292973C22BBB16
49BD5519A23E286E8FE8C3E471786D241A6C3232F011D2C68B075E568866CE11
34303D16C42723D4FED862A3084A7C6603A763F992FE8374853CA289CEB5DB78
3E9F188C856E55B0AECFD10A80BBE90A87136168DF00B9E2682E7F8E27BB6BC4
3DC6D7CD6C768AE96E5E792D294A069FFDF7E55CCE09FFBAB556F45D0AF5379F
F064823B1C4CECC0989A4687E7EB79BC9F83C5C3BB9E3525C7DCD093B14B17A9
18F626E852FAFE63D86EB3F49B51593CE282EBC17B28D3CBEE0713123A3D6278
0998E3E22A28A314110FA7231ED116053314811D98E4E1333077BB773DFC89B2
141F61EED156ED842D127A2EA0761F25E130BFAF12E9F9BE954ABCEC1140D91A
B4DD26499AFFD7A8206B54E983000F6524ECCBEF0F63348046C7CDD58C37E5E0
ED54A679B7FFF8930539F69A3BAB610E619619B4A8D87287C1DDE7625F6941DC
5E4AD118D51540D531DC1A6F269290F0AC34F35B5C705ABA9312CE292E23B07D
20D3D8CB9AE8A77C03835B802CA55DD085DA3E6A54DCABC3A1AB7585D1B5BCEC
D93CEB05B04DE66B47184F4D84758B75E6EA4884CA36D6B79221B9F191E9142C
93AA1AFE8C3BA715BB9252D01453B664D9AECDD291F52006982FA8321B400DD7
587ACCBF6FF8E65CE1F3AFDD4D9CE95C79CFCCEC5E32F8358914FDE8A6B1178E
700D050870E24A5F8C85477A0CC3054B19A3485C5B2FD53CC5D91F5308F96304
E4F6FB8505F45AC40F07AEFAB1BE068EAE4FA449ED9EDABFDB2C71BF2B26A50E
689146E20BA3923B09E06DEE13BF65A09F6484DF7DD1E650CDEDC8152F84CC3D
0574E8FF11ABE49A8CB7B9F1E406F54CAA8CFD3497B65E2AC10A2FE699B7365F
102513FAE4B6CEA71B8DE42823DB7DEA5838DB07CDB34DD13760DA7B52414C17
1CDB742B1DDD79150DDE57FA865CCE0D0B1488A4A25E48E67FEC038F612C450B
CCB1BBA56014DEC79DED89D4462EBEFC0A3D0D2168A4005FEF6D6F7D268BA8DC
809A9A4771FBED36BA3DF5CCCA41FA8CE6AAEACB29A8E3117211CA5A9717CB34
FC92FD0AD1A726425803C4402AE96455224E7A12B2D2BB9E2BBAAF8C5A8D9011
26908E2CEF9D666F927C4FD38FF3DFCB79EA0882D4AE4D4C1018E6FD66D741F9
D55A5FC294DD312D26A57E18C5F09316AC55AE1382FC05F740DD21985408F01D
194DB0FB02BFCE76C1902F750BFF6672EA5B6CAAE769E2203E428D775EAA177D
5C6344EF11B8A386E5C0B8919B82C01359C01FA24ADBA3E55A2C44D303901625
CD
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: CMR10
%!PS-AdobeFont-1.1: CMR10 1.00B
%%CreationDate: 1992 Feb 19 19:54:52
% Copyright (C) 1997 American Mathematical Society. All Rights Reserved.
11 dict begin
/FontInfo 7 dict dup begin
/version (1.00B) readonly def
/Notice (Copyright (C) 1997 American Mathematical Society. All Rights Reserved) readonly def
/FullName (CMR10) readonly def
/FamilyName (Computer Modern) readonly def
/Weight (Medium) readonly def
/ItalicAngle 0 def
/isFixedPitch false def
end readonly def
/FontName /CMR10 def
/PaintType 0 def
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0] readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 49 /one put
dup 50 /two put
dup 51 /three put
dup 52 /four put
dup 53 /five put
dup 54 /six put
dup 69 /E put
dup 70 /F put
dup 72 /H put
dup 82 /R put
dup 90 /Z put
dup 91 /bracketleft put
dup 93 /bracketright put
dup 97 /a put
dup 98 /b put
dup 99 /c put
dup 100 /d put
dup 101 /e put
dup 103 /g put
dup 104 /h put
dup 105 /i put
dup 107 /k put
dup 109 /m put
dup 110 /n put
dup 112 /p put
dup 114 /r put
dup 115 /s put
dup 116 /t put
dup 119 /w put
dup 120 /x put
dup 121 /y put
readonly def
/FontBBox{-251 -250 1009 969}readonly def
currentdict end
currentfile eexec
D9D66F633B846A97B686A97E45A3D0AA052A014267B7904EB3C0D3BD0B83D891
016CA6CA4B712ADEB258FAAB9A130EE605E61F77FC1B738ABC7C51CD46EF8171
9098D5FEE67660E69A7AB91B58F29A4D79E57022F783EB0FBBB6D4F4EC35014F
D2DECBA99459A4C59DF0C6EBA150284454E707DC2100C15B76B4C19B84363758
469A6C558785B226332152109871A9883487DD7710949204DDCF837E6A8708B8
2BDBF16FBC7512FAA308A093FE5CF7158F1163BC1F3352E22A1452E73FECA8A4
87100FB1FFC4C8AF409B2067537220E605DA0852CA49839E1386AF9D7A1A455F
D1F017CE45884D76EF2CB9BC5821FD25365DDEA6E45F332B5F68A44AD8A530F0
92A36FAC8D27F9087AFEEA2096F839A2BC4B937F24E080EF7C0F9374A18D565C
295A05210DB96A23175AC59A9BD0147A310EF49C551A417E0A22703F94FF7B75
409A5D417DA6730A69E310FA6A4229FC7E4F620B0FC4C63C50E99E179EB51E4C
4BC45217722F1E8E40F1E1428E792EAFE05C5A50D38C52114DFCD24D54027CBF
2512DD116F0463DE4052A7AD53B641A27E81E481947884CE35661B49153FA19E
0A2A860C7B61558671303DE6AE06A80E4E450E17067676E6BBB42A9A24ACBC3E
B0CA7B7A3BFEA84FED39CCFB6D545BB2BCC49E5E16976407AB9D94556CD4F008
24EF579B6800B6DC3AAF840B3FC6822872368E3B4274DD06CA36AF8F6346C11B
43C772CC242F3B212C4BD7018D71A1A74C9A94ED0093A5FB6557F4E0751047AF
D72098ECA301B8AE68110F983796E581F106144951DF5B750432A230FDA3B575
5A38B5E7972AABC12306A01A99FCF8189D71B8DBF49550BAEA9CF1B97CBFC7CC
96498ECC938B1A1710B670657DE923A659DB8757147B140A48067328E7E3F9C3
7D1888B284904301450CE0BC15EEEA00E48CCD6388F3FC3BEE09555C11E6E295
71B219B380EE9E5BB17AD84B4E8AED35880BD88E5AC7D9FE25C46889CD093396
F0E34A62F93E64C8E7975CFD617121244AB09FF9A4F73F8166197D0CDE2EEBB3
81AB9BD8329579C2122368F56DEB89BA6E42C5D9E20F2789CC4A89E4AD9B877F
8A0ACB84936F109D86211169257C19756A97E682601F4D1E7ED950A351C14DAC
4BEA7FB0E58FB5AEB55BC09B1253748B61B4E00C448F263458BF958D3986BF18
9636037E95FB425AAC96FCED5B4C766F93041FAA0DBB196B0A220B8E3A9FCA6E
B4F5C0C775C25AFF4F5099CD3A2FA59ACA735718F8E90B351B015320794A89E8
4C34F32B465E201008CCC0A15C2DEE572BDA14D8BDDFCF2743A15F8A93386861
828F6251F206B9131C951D1ED4364A9CCE507E2959A1DA04A777B592888D38ED
E68FFB3EFE83870BA8E04B88C9EEEB2DB80D4D07B52CE914D9DADF825A530750
23D143A8A073461519747D66B7E32B4D31FA860FB3D7A22E42C50628AA1DAFCF
8E3312E2C45602051A73839EA189B8A9864FB2735AA51DB9FE4620EF2C716980
F47FF2CA3D072D0E89FD7ABC1A8391E60EAE47DD8C5CA72EF31793346F6D6F9A
6C5EEA6C7DED858EA79EA7B1FDDFE76667D445E4008E182FA043886A42803C58
05C014E62974DF5433CD0E2DB31AAB2A473ADEC877E8862C76D9F8E69C9BFDC9
BC0EE263083AC6179548E140F53F9B36D7DA980C81000E8E512EF9D135FFDDDE
B195236CB74BCF236F2124EB6D5FBAD96B899AB12F54B227A0C18DA8A43ADB75
93E98E5E0C75197138FFF904C17DC217C7A9CA604CF8401B289C1AFE77829DBC
9902242F0363BD8FA39874B38A5773E679768C1EBCE1D7B9AD890D6BC64614C5
CF9B2479B4E7C3B7C035183FFA0B0816D47D5987B4965931B19DE133350482C4
60D3FE206326C214736B8A1711E07EFD6044AED521156C2CFFD8EA20EA384D74
D11F9273358E7F80EE2EBF88A22A6678C504824DA0F409D49B66743975DAEDCA
D6D586360D0ED39E2881697CAE4DA8094D37BD8D5AC97935DE4A74913B3C9D7F
90086F2BF4A4FD3B972211F91F6D1869E07333B74B94F3FA76B78BD2C6109E3D
5251B446DB0BB825457EF769FE27B79A8E9C913AB065AF9B9D9EAC0923E4EC29
35CB344477D7A651613323F209EE013F696F741D1041A336698BDFFD9A659C42
C1BBB7271CB3194F178AD02173E589C2E71F0433B9B822F2BC9C5ACE2A94753E
3444BAEA2B4632CBC356F5DD65503CBDFD70D4ABE210875AF8BB326D492C4F6A
7635B85ECF70EF5733EDB26731D14A01CD538AF24B2246F66ACEEC40E002CE80
DB9050DB5857ADA5B8C11633CDE746FA87E04A8BD4836FE1AA0DC9F67679F25E
1A53D3CB15FAE210FA20745B4B06F99E5224146E5EEF76A3EB45A509F9B63CEB
7FD7C2CEE173A69C849DFBD0BE62ECBD5E07DD620FE46403D104A626401F96F3
9B179D8EBD1EB6A6CD5C9CFFE459730199ED919E55257F537E9888B9599642F5
12CF2FBB8BD60DC42A1F594FB863F181084F3D694E6CA59318C013A81EDC1C2D
91AFEA1200BCE1F78E7A9CEAD6FEE47872FD79080C15CC4843ECBD3B3C5652D0
8246D25FCEFE7A357C4C7EABA8E0B6A642F633821915E4A63ACFFB6F899C6A63
B8998C59EC082B045A0BCB5FBB37E9688EA8B0A0EC7992DEBF1A211A538F6DC6
FB8DAFA232E8BF0019CC0AB00AA4CC34242774D084C07F69345140A3C2F2DC2C
9074B666FEBCE41E9B40C7D83E04D08B583D806CE9E4511664E8FFCF23B0CDBA
EEF96682CC1813F099FEB2C57306CCC344E2EC53C708DDD9A4176AA17A9239E9
E42AE28A1A1A834D0858F905D1F9060789C6A1B09BCDBC9A0B58C19518687857
3DA3B94F99D93C9A086C4BF45B113FFCCFCCC793D96F9CF37BF5FCAEC4F3FB08
933C53D6E2F8D6FC8754CEAD213F2029B140D4D88327C96F060E478E42D23C21
2270ECDF96869F2D1AACBA16B222652AD019B56792E690097387B6E2142017C6
0FE2D53F523C92A676C09617914DB7CEB2EA070A3DD20BFDEC7D768B1EEA0D59
C866B3CC25F42255E32D8608221074B0ABD0C591A73E60897573F8D4F0DBE75D
3FD5CE57F09796513E5B47E3305639D719DC36B3681F047571E27E324A9189DF
10788AF9F51F7EC805136978500703D29C60528CDA69BA4004C4011623EBCA94
AA9083DA7E24BA20C68098AB3DD5E2746314F3014BC47912A91930E593B15F5D
59945469A0072F0347EDE202FF9358F3044F58D1C41BC3406C1F7581D36E23E8
CED7B896BC292A00881DEE8C58E2359735670ED162AD2511E31CC165748AAB5C
8BE84BB47EAC2444699F7E89C0810DC2A5166FAB1FBF938098404597B5BE81BA
D060840221AEDD8C846FD9827CC808087AE34725F87378562D34A7D241F7512C
FD37A686AE3CD701E3D90BB9B5A6D59C95468E302A966C8545407D9F598B9A5D
B4AB123866AAFD03C670E224A2E4D2C3967CCE8C53EAFF26FB516355BD3BC95F
CE1995F689ECCFA248C018BA1A6893F3328B88E59A5F46A6E0201E0238F92CFD
ED61B1A5BE3085D69FDC23DF601C139C8FE067038788E3F79A72D7A2833E8C8A
0F96F8BF1219F68EE2E77B4ED9184B4065B741B6E3152477B768FC5CF050661D
D6428995BC6471E617C7EC5EFEAEA55716E21615D0487927E77E83EBCF1B1310
2209BC3C5C12930AFD2ACD854A8EF686BBF05393C6A1DE06652A5446CA92D25B
FC2F4FB5F9103E14001AD601DCF995FC176381DD83A0ADA2EA4F7A80A3BF1790
6A30A715B748CDE2221E4EF3242E1EE71D033CCD0B3E7B2571B3489648B41CDD
304FD0B3F29B686D75060E0348D5C5950C5B84CC214A9F6A38FA67B965B81B0D
CEEE757A7B193EFC963960D78AE4A22B9B53840F52B3316351FBED677197E5A7
9885179885F3808D77AC1C0DE3D9D958906A6353DFFD6D9980BCD86B0765AE39
F053A86AABFBA8F49A51D713523FDD4CBAB60D3DAE7F0C4A6D98BC7559469470
575CC542FD239AB9EC5403AE66A03E2538984DFC3BEC2A687EA841461ED0D815
3CFAA9DC6798A19C0C21229C6088A30302AC3FFD3D197A3D8280B9824EFE32CD
D2AEC9F11F58753EE4CC17B4080FC54F174CB9DFEEE0E1E3906D5DDBA2073F46
5648B40E8838FD2B44F29184A7E5B8AA85EE10E04BF1046774E12F7C1D870229
893F380B3004C9F0ABA94D603E937B1B5FA9AC68C1BDAD7BD305884A41B3E0D9
561092F2E3895F7ACF908607FB33CAC44109D470EF9B971611214F2670380C1D
A39B9216C9CF68C4254A2D1E25B3736048A9ED28448EBB3F9FC44064EF5831E7
FFF28C9A9EF029BA1E213670B13789073F69BF43075742D88F118EEE3E5AEDBB
DC8AEF5A248E4D4FC271E3F2B99AC25F953AFD9DB484733DEC0F9199971EEDEF
F9F5C9B9D2CD49EEC644657FFA1CBFD5AC6AA9C64C582368F6DDE598EBF45791
C0DF4AC641E3075DEE56DAA57000E751F067E568B30F4BBEA5D2B859B7768B09
39A830E0C7348299665E3E31F0B4D42700A457C1F63A187A27FCB06DCC896FAD
B88B01DB9D32AFE5482929E785E40560F39AA3A7DACEC36C13A36382B8B318D1
4EB9CBD0FA0BD3850CE8FF65A89FD9D3D3CF83886D28A51EA4AE8088459004B1
EC1195CF0244CB71DF2BCD9ADBF2644BF1E40783609D56EC568721EC09956845
99296EB38103BE8D196724A43012DFF5955EF97CFD307AEA89CBF0BDA6E8EB09
92F7C8662BD53740645A118F7A8C6DE32B7FB589F10F738CC650D05C8DF30947
AEEFE0FE3BFA6A16F8E4BEFEC8284C3860A59B511D72814E875BB8DA9D75115F
BE4F744CE71C22125333B7393ADFD5E16DE6347B45BCCF72883ACD04C2F3C79B
358E524644EDC8F3D771A5A43C6AB91AE500856E71BDB0D7D328A8164517A453
04ABED8F3066CFB944EC3C156F87270CC299CC24C0594E18F4FFAC1508588B99
ED27F0D029CF2CF04092FBBFF75AE70EE0F2FF2118C32B861B9584612E39D8F6
69591D94EBE05E0F8477E9EF541708028F1A8260A12DA6B67C9F1229D55D2E89
92B99552766D80C7703C19173EF571C0C4212794845D9806F7DC68A2B9FBB97E
431A3952C77EB78D4D3BF455866578C1FD2C7D384A5C74118936CF87599EF7A0
008D4F04E32295EB132B2645B0C3A5BD863C35B8553E563B3A7D653C46E805F0
0E9A0BE8A4CAA562AC8D5B4C3B8BA669AAC0AB939707F259F80B669CD5D933BF
A523C049F715CA29BC2F0D10E542D1B2C54DC669695604501C1F25C1C62B0A05
00542E1D2CBFA807C9D9B84B102B9F97D7164F7D9A278817D07F34A562BEBA2E
27EC242E5C579CE34B59C9EDE1BC9D5CD92130EAFE70D3CF31575E1906E6BB03
84F3858E19EC5D35E779499BC537A71B325B07AA411FE50EA2332A3D29B846A2
E0C064D6DBFF96656B202CAD95C857B6249A1FAB6B14ED8A8F854453450EA188
3A67EC1B1313F197516B8092B7B8ADD5E31135C91B14BEC57DA7C2FAA477FCF8
80CCCD6C3B158FA903A9C3D8AEC7027EB2A34411C2EAAC8BD0E05DDA1DB1D98D
14D95EAA78B8FE6C664A0F8CEF0DB2AA2F1236F15DE37CFE165BD2D0BA88376F
41921214C8856C6288EC39A22D410796F5EDD8BB7653BE633D85DC44BC40508B
CD6B9029ECC573C27D86EA4CDFB6A5B5DA0ECEE1F71D008DB5B89E3743F3E161
FCC0A602FD6BEB244542BFBBA18C6B815C58AC8947331A1012C464BB96BF76D0
55B52F0BEF06D91C215D1A3B6DD81CDC8CE95886235F08D4C9F6E7BC271DF48B
AA9810D3B710019B476F6418F17F961767AFE252C5DE8E08C386805B4FB18A93
701747949B33EDEDC0368FEA9E7D4E06013A06990B00A95A38ACF0D1DDAF23A1
EE26353B7E1CF0B365ECE773C7A79A924ECA3DBFBF3C9813DA8A0AABA441489C
411507490E58A86FC412F8E6279921F858A9DFC715E955631DD2CA7875FD9E6A
544BD4906CDF7DE733AF07C6498E1B02F0A4C424136E762C7EC6707756136230
0F03C628C579E07C0BC5E2914DCD4BDC3CE27154AEB63F5ABABF0806F0A96CF2
C0CAC73620F4AFCF89C77139A771B29056E25BE4F8139BB84C288D5E54020FC8
267BF1D76E045ADC55F61E1BCAF8D83D8BA0AB47133D463E1C7C62126D67F7A6
F71FB05E124ABEBA23B9BDC3F4DD5A389619D9EAE7BCE70B66C58E2734F833AA
7C385AD050EB1610336F1DFC90EBB918C2C3B5BA59BE87C80B8EF6934FA4BA24
962C7BDBB8A6D403092B523D5CFCFC33F6A4A47C746160A01BD574657268E677
2D2D28DE291E7503FF4A9B74B01B343DC3F6F8E765564EADE975305F40A4250C
C1FDE800BFF314421584B646665B0DA69C272FBF9EAD05FB82F3A5647C4D8F86
18FFDED0381449EC2A72A70A24D85181763781EB54E14FEDD288F87F04614AC6
9B10424807D733229F27572170DC2790314FE731DECED7095DE5860B5F5228A1
FF5DC86352820F048CE608EE4CF7D3915618C376D77E00EA7D5F710E08C8E222
8160A3EBCB4DE78BA684244294704125BDDCD929865D016AEC202C2D474571B6
9E22FA96C486CC945E902697AFDE8DF203BA375C0691B76190DDB6381CFEB09C
5BEE2BAFE056C5322684DBC691DBEEB636839F33B9566D92A74B77B0B403D2FD
E6D5264BA1E8833B3BC4FD01148D71C54D92FFCAF38750EBB533A1CCAAE9EC97
268D630BAC82A163F2C575A4DB221A87E7C4B222A1920B9FD4E775E8E4BB4BE5
5D38636EC5341045CF88AD5C2230A8F9AE7EDF3ABAFB05E58280BD4C80C99738
A4F6D4BE2EC9BC2213AAC77409B9D7FEDFB586E325ADF8D4161EF53FDA1952C1
7FD4EB0FE1ABF37DFC764C18B88A15F98CCAF3B5AD501775B0E7D129A9A54368
8A49087F87AE725B73B41A95B99BF607FFE786ECD23976B4DD8900F341D45876
94A95AE95263FBCE32CE67A6896B8913B6BC7C1C8A5178102CD3CD0CBEB0B224
F4FFBE11EC5DCBEB8B15ECE9EDBA9D03FB8DD3F9C3350752BA3F3DBDB386427C
404A708EF3D249F2ABA8AAD9D16B37F938DB72CCBF0B28C57D2EFB97F70BB35C
C7C99653988C879937DCA880FCE2E096976A17892DE735046B2482E6F69DCCE1
9119B3A22E9776F2C8DEBAAAA5E6309803E254C7314913CF7E2F6F568A433FE0
F5B403A295C4A8F4F71F61C629F4A723AC14EED233865203A9CA088C58DDC7E4
1EDEC440B664BC918D7B6E033456C984CDAEDAD529A6294D8A237A2212A68C9C
6F0A09A52C42CD20848910D33110589F974AA95A56460214BC947F736EA08A67
B8EACAFA3525BBDC490F026B838DE4EA85B27E0556E464ABDE94202462AB4063
D057C0814D4D3438113EAAA3F18F85DF27A97CA11F584AA05AE4329977FB4B1A
61ACBE085997D990338D60CBA82A0BE48B08C7BD4CE7F86B4414702A3AB9D566
2FD959FE5392C2B263F733DFE8B8D02FD7CD673D440C544F7C3564F98CACBC99
9EB3A61CC77B103B858E7BAD35D324BB7EF7CDC47C8CA539F46777148238BB4D
ECAF1555046C641EC0EE74297E3F09CAD3A312257B6A7C5FF41A3A1223FE75C8
80C4DBA8A0AAAA31C5788D9373B17FCDDF5710EF0E6C5512EFC85E9C1C71B46A
43C7FD334C45A25C7FAA95CC3559577A56E5C7A9AA18196376124359D5F6F345
2B5ACE0C3AFCF868AA938D96CF54510CCBDFAE954C368D12D994BB172615C815
F9728662F9F38025773BFDCBA6D84E6EB12C9391CFFEE0110FE23462C9D9A7E4
499D69C30303D9349B6EB636B12CFF3504085278C181A0612A750BD7E7787716
D6988C84716C578F3D89A185FC1043F6BE973A0DBE35082C96211264B23DD1C6
AB733E4D42E8A6896DF300AC9CF440D9BB31395E83EB45178FA4AF1AFF66D62F
A59AD476B91E5C36F17DAC731A7ACB4C3889D9CE0B24DE05E87160B94FEB0555
A0DB35F1676D82D9889BA86DFAB42BD6AA10ED8AAD990BF1FFC018A488A7C9C8
79F47CAEC3EF6679F0ECABE6A6FBB076D89118D44336A65C96FB47AE6B0A541A
06FC1BF151A5326C08323EB3A0123F6ACD5853D5DF1AC0983ADAA8CD98D9DF8C
6B1384F0C58F17FBF32B3AC58D0816392F26670AAEB5CF6E8525ECD467FB8076
16E95AD62BAB5F57C5E6A0952B334E5C5773B81E6E991B88F312C66F01DFDD98
43277A9D4D101BDFA3ACACD518BEE8A43A23CF8B0EB59DEB8C6A658DCEF2354B
364CD1E7963EA01E4E8D11488E4733FE4B56D70BDA2E68399B46D7EC430F34BF
D94791B688210B4A12142D3294A39E2FBC75780C98217DE881E9132ABAD6B087
69667ED71C5AA115C86E4ACA4F0E2020FBEC5FE816639AADE8EF3CD5F57C5D32
F270958D470D3BD9A97474A5F5FDF37AED9E917ADB740106D9BDF77121A7E7B6
BD0C8BE03677C885567BC27BDCED91CEEE122A1908C0D9F91368ED564851A006
38833C222F30A044AF34B955844B8E36204BC6852CF44B7F4A0059BCBB4CBEAB
CE47D0CD566B7C04866A82CED9F929FF2B92EBFE0ABE463E5C9A7F55185EA0C4
A051EE42F56F2D30A086C51814641C4B3679B88C0E4247D982AB35FE406FCD88
7F868FAED80D41E00CD5F0123A6F131FAD97717DC4DED2D98FB7C5349432DF48
B111FB40B28207AE22FACE07D4F168A33425BFB7AAA54EE131C8B18E655FC1C5
21202F61424DE65259B31887673C33E7471C1F8FBCF5D9C7CF97EACA60267ECF
C64B073D34562F3CFE908B93E607088FCFB9A48F9310F23CD69AB6FF4FCDD70D
76405FBB9C76259CBFBE05F178D7B8754392C057F89964F0D1D5AC4179F75DE5
34DA4BAC66AF9760D626612C45225B3D3930AF448EB79301F8F0E093A159CC49
81426740FBCBDB3CFDBA65B36055C8333477909987523BDC270CDCF0A0A999B1
729208F8B7ABE74575FA7D3B7DFE89775C553ECF38DF90A29C6131AF8A41F5ED
F9A2D6B9A69021E15F681140F4D4C0723F0D7F92EFB582ACEBFD70D602F2EAEE
5645B83966C7BCEE611E5B71808A823711B25965525AD331B7E78B70653BC50E
03F4AB5AFC0F2863DF3703C22E2022074A81AAA00FBD7DA7727857233C7D3BF1
444A1683E06DEE5B44ABEC851EE16CEB8F9E48276489214878834BE780375DC9
5FC937930CF756A449651B151E26700FA77B9F59BECFC0EA75D49B2D8F85C83E
74A9F6E6A520C75FE1080989E78E261CF3590F00EBA66726406B6D1058229CE6
ADA59BA023E57B2A973A43610BCFC31FF6A742CE4BF7513A024AD2B122AC7F29
F3DD4CE04D36F617DEB01766B06971BE9575643EEBAFA9FA929B56F5063D7F6C
3030F175EFDE6C45E7011A100D81187E4E949BECBD1CA9F2C136FD01A0F2D3DF
FA7B03A01D1D1530FE610718AC5FE9EF724F0C6BA84B8B15EBC38E3A642B2183
1B8C10064550EB89FBF7EF07B620FD8C4C5036E0BCE8E3FF4477B024AC3E7D10
F549BBB42DBDB5FD9065675DC9B071C307314B6407EBA1A0BCAB4EDCE51CC42B
043EBFD81258598AC98CDA8AB9C0E209500BAB0BBA6A8D5CB794CA4D089F64B8
D5AA5400E10D3427A2A7ACBA3924554EF8B8A65788E3B67C4601CF17202169F7
4C8111339111B2DFDF6B6529CE1893C021E8275197CC0DDEA950CD700AE22898
58DEEAB3249B92F5213BBA59B2537FF6DF052C318E5022FB8C40DE428081C455
DBB41B48353F23CCC7A6F83E491BA683B199F39F42A5FFF5BADDC51C9F12F904
688DE1EC5AE6CAF3EE770FA3A83F355432D99BDFA6BBBB90B2EE8E98563C702E
C6E22804A931129C62A9A5555BA747E70EC4A94D83C260700B8B71F892DB2303
0FDBC3316F17A0476335D4CC5F07E6ED5A482AF3AF18AEAEC44449B9D52CE085
79F755509F0B6A68C1C1E81D62EA723E73C352F1D0BF3A912E1C166F9EC29BE8
F3FCDB92E71A87853359CF0F12B27ACB36E8D88A6614C27DD475D1A1848190F9
815924D2B232A584D5193D3DE779D895C578D01855221F2DFC2DB3A9F96F0B2B
7AE182AD7CCACF1BED6F701BAB41746CE0C90F3F81D91577BFEDAA87FFBEAAC4
B68242CC910361E2975276D954CCABC3A751338617E79A4A736FA656FF441CB2
FC2489091717D0D85538809EEE9F56928E9D0C19D53FCE2DC5085759CA5BCFE9
4F0FCD0A41560C1693D021CB144C65215A3B5EA8E21F717904AB0036BC8181D7
63F0CDEB47A2DF78A1641FFA23A4367CEC2910D5D50573D95704C45E21F964A7
08579E0EB1B1A5
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
TeXDict begin 39139632 55387786 1000 1000 1000 (iverson2016.sol.dvi)
@start /Fa 214[111 111 40[{}2 138.37 /CMEX10 rf /Fb 167[80
45[80 42[{}2 151.515 /CMTT10 rf /Fc 133[66 79 1[108 75
1[54 66 68 1[83 83 91 133 42 75 50 50 83 75 50 75 83
75 75 83 97[{}23 166.044 /CMTI12 rf /Fd 131[85 1[85 85
85 85 85 85 85 85 85 2[85 85 85 85 85 1[85 85 85 85 85
85 85 85 85 1[85 6[85 85 20[85 1[85 2[85 11[85 85 1[85
1[85 1[85 85 85 5[85 34[{}38 166.044 /CMTT12 rf /Fe 134[79
92 9[97 2[85 3[78 80 3[69 85 37[45 45 58[{}10 166.044
/CMMI12 rf /Ff 152[83 83 80[129 129 4[83 11[83 129 1[129{}8
166.044 /CMSY10 rf /Fg 133[120 1[142 2[149 105 106 110
142 1[134 149 224 75 142 1[75 149 134 1[123 1[120 149
131 38[75 5[134 134 134 134 49[{}24 239.103 /CMBX12 rf
/Fh 134[99 99 135 1[104 73 74 76 1[104 93 104 156 52
2[52 104 93 57 85 104 83 104 91 9[193 3[104 2[128 3[112
5[117 123 22[52 62 45[{}29 166.044 /CMBX12 rf /Fi 133[72
86 86 117 86 90 63 64 63 86 90 81 90 135 45 86 50 45
90 81 50 72 90 72 90 81 4[81 2[122 1[167 1[122 117 90
120 126 111 126 122 149 102 1[84 59 122 128 106 111 124
117 115 122 1[77 1[126 1[45 45 81 81 81 81 81 81 81 81
81 81 81 45 54 45 126 1[63 63 45 3[135 81 20[90 90 12[{}75
166.044 /CMR12 rf /Fj 135[86 1[86 2[64 63 2[81 90 135
7[72 3[81 23[59 18[81 3[81 81 81 48[{}14 166.044 /CMSL12
rf /Fk 134[80 80 109 2[59 60 59 1[84 1[84 126 1[80 1[42
84 76 1[67 84 67 84 76 3[42 1[42 93 7[112 9[114 1[99
103 14[76 76 76 76 76 76 49[{}31 151.515 /CMR10 rf /Fl
131[103 28[103 49[103 45[{}3 199.253 /CMTT12 rf /Fm 136[162
2[87 88 92 2[112 125 187 62 118 1[62 1[112 1[102 125
1[125 109 97[{}15 199.253 /CMBX12 rf /Fn 133[87 103 103
1[103 108 76 77 76 103 108 98 108 163 54 103 1[54 108
98 1[87 108 87 108 98 13[108 2[133 6[70 3[133 1[141 138
146 1[92 7[98 2[98 98 98 98 98 98 54 65 54 2[76 76 40[{}43
199.253 /CMR12 rf /Fo 134[170 2[170 179 126 127 132 1[179
161 179 269 3[90 1[161 1[147 1[143 1[157 23[120 18[161
2[161 161 161 161 48[{}21 286.979 /CMBX12 rf end
%%EndProlog
%%BeginSetup
%%Feature: *Resolution 1000dpi
TeXDict begin
%%PaperSize: A4
 end
%%EndSetup
%%Page: 1 1
TeXDict begin 1 0 bop Black Black Black Black 1043 380
a Fo(Iv)-9 b(erson)110 b(computing)f(comp)9 b(etition)2364
726 y(2016)110 b(ma)-9 b(y)108 b(31)264 1347 y Fn(name)p
1271 1369 3150 6 v 264 1845 a(sc)-5 b(ho)5 b(ol)p 1271
1867 V 264 2343 a(cit)-5 b(y)p 1271 2365 1575 6 v 264
2841 a(grade)p 1271 2863 788 6 v 264 3340 a(cs)65 b(teac)-5
b(her)p 1271 3362 3150 6 v 181 3993 a(are)64 b(y)-5 b(ou)65
b(taking)f(AP)h(computer)f(science?)87 b(\(y)-5 b(es/no\))p
4234 3993 394 7 v 181 4242 a(are)64 b(y)-5 b(ou)65 b(taking)f(IB)i
(computer)e(science?)86 b(\(y)-5 b(es/no\))p 4164 4242
V 181 4525 a(ha)g(v)g(e)66 b(y)-5 b(ou)67 b(tak)-5 b(en)66
b(adv)-11 b(anced)67 b(lev)-5 b(el)66 b(courses?)92 b(\(3000)65
b(lev)-5 b(el,)68 b(e.g.)e(CSE3110)g(itera-)181 4825
y(tiv)-5 b(e)64 b(algorithms)g(I.\))i(\(y)-5 b(es/no/curren)g(tly)62
b(taking\))p 4237 4825 1952 6 v Black Black 1491 5706
a Fm(illegible)76 b(answ)-6 b(ers)75 b(will)g(not)g(b)6
b(e)75 b(mark)-6 b(ed)p Black Black 1436 6575 3628 6
v 1433 6825 6 250 v 1519 6750 a Fn(question)p 2311 6825
V 242 w Fl(-)102 b(-)g(-)g(-)p 3345 6825 V 241 w Fn(marks)p
4027 6825 V 165 w(y)-5 b(our)64 b(score)p 5061 6825 V
1436 6830 3628 6 v 1433 7224 6 394 v 1519 7106 a(1)p
2311 7224 V 991 w(tiling)p 3345 7224 V 539 w(11)p 4027
7224 V 5061 7224 V 1436 7229 3628 6 v 1433 7623 6 394
v 1519 7505 a(2)p 2311 7623 V 779 w(ascii)h(maze)p 3345
7623 V 325 w(12)p 4027 7623 V 5061 7623 V 1436 7629 3628
6 v 1433 8022 6 394 v 1519 7904 a(3)p 2311 8022 V 955
w(blorks)p 3345 8022 V 503 w(10)p 4027 8022 V 5061 8022
V 1436 8028 3628 6 v 1433 8421 6 394 v 1519 8303 a(4)p
2311 8421 V 1064 w(hex)p 3345 8421 V 661 w(7)p 4027 8421
V 5061 8421 V 1436 8427 3628 6 v 1433 8821 6 394 v 1519
8703 a(total)p 2311 8821 V 551 w Fl(-)102 b(-)g(-)g(-)p
3345 8821 V 401 w Fn(40)p 4027 8821 V 5061 8821 V 1436
8826 3628 6 v 1401 9577 a Fk(Exam)51 b(prepared)h(b)l(y)e(Zac)l(hary)g
(F)-13 b(riggstad)51 b(and)f(Ry)l(an)g(Ha)l(yw)l(ard)p
Black Black eop end
%%Page: 2 2
TeXDict begin 2 1 bop Black 181 -165 a Fj(Iv)-5 b(erson)55
b(exam)h(2016)p 1555 -165 4521 6 v 4738 w Fi(2)p Black
181 347 a Fh(Exam)61 b(F)-16 b(ormat)181 655 y Fi(This)47
b(is)f(a)g(t)-5 b(w)g(o-hour)49 b(pap)5 b(er)46 b(and)h(p)5
b(encil)47 b(exam.)70 b(There)47 b(are)g(four)f(questions,)j(eac)-5
b(h)47 b(with)g(m)-5 b(ultiple)181 856 y(parts.)92 b(Some)61
b(part\(s\))h(migh)-5 b(t)62 b(b)5 b(e)61 b(easy)-14
b(.)91 b(Solv)-5 b(e)62 b(as)e(man)-5 b(y)62 b(parts)f(of)f(as)h(man)-5
b(y)62 b(questions)f(as)g(y)-5 b(ou)181 1056 y(can.)181
1489 y Fh(Programming)63 b(Language)181 1797 y Fi(Questions)40
b(that)e(require)g(programming)j(can)d(b)5 b(e)37 b(answ)-5
b(ered)40 b(using)e(an)-5 b(y)38 b(language)i(\(e.g.)105
b(C/C++,)181 1998 y(Ja)-5 b(v)c(a,)64 b(Python,)h(.)27
b(.)g(.)g(\))96 b(or)62 b(pseudo-co)5 b(de.)98 b Fh(Pseudo-co)5
b(de)72 b(should)e(b)5 b(e)71 b(detailed)f(enough)i(to)181
2198 y(allo)-5 b(w)88 b(for)i(a)e(near)h(direct)f(translation)f(in)-5
b(to)88 b(a)g(programming)h(language.)141 b Fi(Clarify)181
2399 y(y)-5 b(our)76 b(co)5 b(de)75 b(with)h(appropriate)i(commen)-5
b(ts.)137 b(F)-14 b(or)76 b(full)f(marks,)81 b(an)75
b(answ)-5 b(er)77 b(m)-5 b(ust)76 b(b)5 b(e)75 b(correct,)181
2600 y(w)-5 b(ell-explained,)58 b(and)d(as)g(simple)h(as)e(p)5
b(ossible.)347 2800 y(Our)45 b(primary)h(in)-5 b(terest)46
b(is)f(in)f(thinking)i(skill)f(rather)g(than)h(co)5 b(ding)45
b(wizardry)-14 b(,)49 b(so)44 b(logical)i(think-)181
3001 y(ing)k(and)f(systematic)i(problem)f(solving)g(coun)-5
b(t)51 b(for)e(more)h(than)f(programming)j(language)f(kno)-5
b(wl-)181 3202 y(edge.)181 3635 y Fh(Suggestions)p Black
380 3942 a Fi(1.)p Black 82 w(Y)-14 b(ou)55 b(can)g(assume)h(that)f
(the)g(user)g(en)-5 b(ters)56 b(only)f(v)-9 b(alid)55
b(input)g(in)g(the)g(co)5 b(ding)55 b(questions.)p Black
380 4281 a(2.)p Black 82 w(In)d(somes)i(cases,)g(sample)g(executions)h
(of)d(the)i(desired)g(program)h(are)e(sho)-5 b(wn.)74
b(Review)53 b(the)588 4482 y(samples)65 b(carefully)h(to)e(mak)-5
b(e)66 b(sure)f(y)-5 b(ou)65 b(understand)i(the)e(sp)5
b(eci\014cations.)105 b(The)65 b(samples)588 4683 y(ma)-5
b(y)55 b(giv)-5 b(e)55 b(hin)-5 b(ts.)p Black 380 5022
a(3.)p Black 82 w(Design)70 b(y)-5 b(our)70 b(algorithm)h(b)5
b(efore)70 b(writing)g(an)-5 b(y)70 b(co)5 b(de.)117
b(Use)69 b(an)-5 b(y)70 b(format)g(\(pseudo-co)5 b(de,)588
5222 y(diagrams,)82 b(tables\))76 b(or)f(aid)g(to)g(assist)h(y)-5
b(our)75 b(design)h(plan.)135 b(W)-14 b(e)75 b(ma)-5
b(y)76 b(giv)-5 b(e)75 b(part)h(marks)588 5423 y(for)59
b(legible)i(rough)g(w)-5 b(ork,)62 b(esp)5 b(ecially)61
b(if)e(y)-5 b(our)60 b(\014nal)h(answ)-5 b(er)61 b(is)f(lac)-5
b(king.)90 b(W)-14 b(e)60 b(are)g(lo)5 b(oking)588 5624
y(for)58 b(k)-5 b(ey)58 b(computing)j(ideas,)f(not)f(sp)5
b(eci\014c)59 b(co)5 b(ding)59 b(details,)i(so)d(y)-5
b(ou)59 b(can)g(in)-5 b(v)g(en)g(t)60 b(y)-5 b(our)59
b(o)-5 b(wn)588 5824 y(\\built-in")58 b(functions)g(for)f(simple)h
(subtasks)f(suc)-5 b(h)58 b(as)f(reading)h(the)f(next)g(n)-5
b(um)g(b)5 b(er,)59 b(or)e(the)588 6025 y(next)41 b(c)-5
b(haracter)44 b(in)d(a)g(string,)k(or)c(loading)i(an)e(arra)-5
b(y)-14 b(.)70 b(Mak)-5 b(e)42 b(sure)g(to)f(sp)5 b(ecify)41
b(suc)-5 b(h)42 b(functions)588 6226 y(b)-5 b(y)54 b(giving)i(a)e
(relationship)j(b)5 b(et)-5 b(w)g(een)57 b(their)e(inputs)h(and)f
(outputs.)p Black 380 6565 a(4.)p Black 82 w(Read)68
b(all)g(questions)i(b)5 b(efore)68 b(deciding)i(whic)-5
b(h)70 b(ones)f(to)f(attempt,)74 b(and)68 b(in)h(whic)-5
b(h)69 b(order.)588 6765 y(Start)55 b(with)g(the)g(easiest)h(parts)f
(of)g(eac)-5 b(h)55 b(question.)p Black Black eop end
%%Page: 3 3
TeXDict begin 3 2 bop Black 181 -165 a Fj(Iv)-5 b(erson)55
b(exam)h(2016)p 1555 -165 4521 6 v 4738 w Fi(3)p Black
181 347 a Fg(question)90 b(1:)120 b(tiling)181 712 y
Fi(W)-14 b(e)52 b(w)-5 b(an)g(t)53 b(to)e(tile)h(2)30
b Ff(\002)g Fe(n)51 b Fi(grids)h(using)g(domino)5 b(es.)73
b(A)51 b(domino)h(is)f(a)g(2)31 b Ff(\002)f Fi(1)51 b(or)g(1)30
b Ff(\002)h Fi(2)51 b(tile.)72 b(Here)51 b(are)181 913
y(all)k(w)-5 b(a)g(ys)56 b(to)e(tile)h(a)g(2)37 b Ff(\002)g
Fi(3)55 b(grid:)p Black Black 1281 1865 a @beginspecial
0 @llx 0 @lly 825 @urx 177 @ury 2834 @rwi @setspecial
%%BeginDocument: Figures/23-tilings.eps
%!PS-Adobe-3.0 EPSF-3.0
%%Creator: (ImageMagick)
%%Title: (23-tilings.eps)
%%CreationDate: (2016-05-27T14:18:10-06:00)
%%BoundingBox: -0 -0 825 177
%%HiResBoundingBox: 0 0 825 177
%%LanguageLevel: 2
%%Pages: 1
%%EndComments

%%BeginDefaults
%%EndDefaults

%%BeginProlog
%
% Display a color image.  The image is displayed in color on
% Postscript viewers or printers that support color, otherwise
% it is displayed as grayscale.
%
/DirectClassImage
{
  %
  % Display a DirectClass image.
  %
  colorspace 0 eq
  {
    /DeviceRGB setcolorspace
    <<
      /ImageType 1
      /Width columns
      /Height rows
      /BitsPerComponent 8
      /Decode [0 1 0 1 0 1]
      /ImageMatrix [columns 0 0 rows neg 0 rows]
      compression 0 gt
      { /DataSource pixel_stream /LZWDecode filter }
      { /DataSource pixel_stream /LZWDecode filter } ifelse
    >> image
  }
  {
    /DeviceCMYK setcolorspace
    <<
      /ImageType 1
      /Width columns
      /Height rows
      /BitsPerComponent 8
      /Decode [1 0 1 0 1 0 1 0]
      /ImageMatrix [columns 0 0 rows neg 0 rows]
      compression 0 gt
      { /DataSource pixel_stream /LZWDecode filter }
      { /DataSource pixel_stream /LZWDecode filter } ifelse
    >> image
  } ifelse
} bind def

/PseudoClassImage
{
  %
  % Display a PseudoClass image.
  %
  % Parameters:
  %   colors: number of colors in the colormap.
  %
  currentfile buffer readline pop
  token pop /colors exch def pop
  colors 0 eq
  {
    %
    % Image is grayscale.
    %
    currentfile buffer readline pop
    token pop /bits exch def pop
    /DeviceGray setcolorspace
    <<
      /ImageType 1
      /Width columns
      /Height rows
      /BitsPerComponent bits
      /Decode [0 1]
      /ImageMatrix [columns 0 0 rows neg 0 rows]
      compression 0 gt
      { /DataSource pixel_stream /LZWDecode filter }
      {
        /DataSource pixel_stream /LZWDecode filter
        <<
           /K -1
           /Columns columns
           /Rows rows
        >> /CCITTFaxDecode filter
      } ifelse
    >> image
  }
  {
    %
    % Parameters:
    %   colormap: red, green, blue color packets.
    %
    /colormap colors 3 mul string def
    currentfile colormap readhexstring pop pop
    currentfile buffer readline pop
    [ /Indexed /DeviceRGB colors 1 sub colormap ] setcolorspace
    <<
      /ImageType 1
      /Width columns
      /Height rows
      /BitsPerComponent 8
      /Decode [0 255]
      /ImageMatrix [columns 0 0 rows neg 0 rows]
      compression 0 gt
      { /DataSource pixel_stream /LZWDecode filter }
      { /DataSource pixel_stream /LZWDecode filter } ifelse
    >> image
  } ifelse
} bind def

/DisplayImage
{
  %
  % Display a DirectClass or PseudoClass image.
  %
  % Parameters:
  %   x & y translation.
  %   x & y scale.
  %   label pointsize.
  %   image label.
  %   image columns & rows.
  %   class: 0-DirectClass or 1-PseudoClass.
  %   colorspace: 0-RGB or 1-CMYK.
  %   compression: 0-RLECompression or 1-NoCompression.
  %   hex color packets.
  %
  gsave
  /buffer 512 string def
  /pixel_stream currentfile def

  currentfile buffer readline pop
  token pop /x exch def
  token pop /y exch def pop
  x y translate
  currentfile buffer readline pop
  token pop /x exch def
  token pop /y exch def pop
  currentfile buffer readline pop
  token pop /pointsize exch def pop
  /Helvetica findfont pointsize scalefont setfont
  x y scale
  currentfile buffer readline pop
  token pop /columns exch def
  token pop /rows exch def pop
  currentfile buffer readline pop
  token pop /class exch def pop
  currentfile buffer readline pop
  token pop /colorspace exch def pop
  currentfile buffer readline pop
  token pop /compression exch def pop
  class 0 gt { PseudoClassImage } { DirectClassImage } ifelse
  grestore
} bind def
%%EndProlog
%%Page:  1 1
%%PageBoundingBox: 0 0 825 177
userdict begin
%%BeginData:        11520 Binary Bytes
DisplayImage
0 0
825 177
12
825 177
1
0
1
0
8
?P8$BaPd6DbQ8V-FcQv=HdR9$M'JeRd]/LfS9m7NgS}?PhT:%GRiTe6OTjU:VWVkUv_XlV;%gZmVeo\nW;w^oW`pX<&bqXf7drY<W-?Yw=htZ=hZOluz.e}pvMoq/'Egv{]wu3Kz}]E^5>MKpl@;C4
B/&3|'{mEQKEq#u1K"E+1'H
a,LYR2N94I7J?&2=3}ARa!EztK5M*zT.PE |T-Nm<y	=OT]]Ctr[s^Y}YT}6-U]Y6k`YcUvqMQow-9s7RKg&1) } ?yT	!w|`%X&T}!Xu|yC>j=dYn4}NWeub>7}NwdQy6i3Il]Xv]53Sk[&m[ei;;^yE{|_nKg!<^-|	m|rCr\N:  7'Y =Sy?>y^guwxB_C|j{)_o~O+%IP f w!<	p4#@ `BX8K )0?1u07/.pB'<gLjv=Nw1@ E(A.EHq)xYy10FKs1XLcnp * q^&E?d7dEHdImDI+'j2JR;%RJQzK&:d&9`f`L"i1&4OfLm4&<ri1fxVg4wo4Ny5%tMBBtd1lrt~OMz3A	;2w>'T2PZ2_MV;_P%J#-[ M` tq<t:sN?'VO)@eSjNJI{ O5H~QbsUj)8UW+I1j>g7xl:x|W_+Gb[_kW{0Ev}c{*"}edX%c,3jb F0 w R6G*xkom7p.S(\}t.Z.rE\kUjIWjx/u#Arrp=A 8	v*Z}pMxYj
;m'j\@M%1h;3@X,_l3(cTAH}J@+#er&JD;h=1<F[.3
 !	f6)|O3ic{Psc=g\	K':gms;Gg> ' e18MMFzS4?V]uOVMQ}E5V'[?[k GH4c=G>sO&5mm&9m([}hn;pFc7(Px|tq,76N%\sfprw)!rI5<jc^_>C|rZ1niu~LP]Sj>e](d>Y#w^l.EgNuzk><y/ fK9P$|-8rig~3?!|ny YK?7F=s'd 4o>>0lG~W}B"GjQ8G0?Qo
(OPO%op
 6oN A[0V0[ P_P@DGYp}PyBmP0,#PI-}	i
U
gM	APw
pQ00'p?0{pPBI	
'M$$Q
pp+{1005WY.$10kPk"{U	0"G#36#v;?CGM%"oqfqcQQ"CiOQ"q#Q
Q
 [#"r#"7r1r8"y"$2*2mA!qrYO"B%P'2$u&# D#RI M)!'r%A(P)=&K"!!##W*Qa)k&2*+r#27+P"}.(e,R+*r)'W.-a)2!2-/1.2*-114#Rm0r,!&s:#3?12o0 "%5r/3'6Sa3G/03mI*7N%Z"_4U9i4{%383&5C.bu8"q9s99:2;s-/3*3S=o-I:r<4S]<s>>J"8w;53:S:s@Ao5-M0?+A3A=?S73C>7:%T!7r93B@")3?57E6tH&O@Q)%B"tW?9FBHCyIBOAR%4M?Is86]HD:9Tz%Ma=4Fd"tL3GtCTIt"TDMsLY;TqPTONJWFQB%KtKO#P4')C8N3S'M64QBPIUQJC6&;Vu?Nrur>TQ!Q/TRu	L_FcTST%oBu-,_11UTSUU5ZuJ9XOPX1}=Xs/[\Y5+W5C\m]O]U1I9TV^!JJu!HU/T]cask^^5=YtHQvEWIWP4v!eZUV`a`Ueud__TaPvcQ	uc!UV#Ou]iYOju50f5'v&- [Blp'cdgUgGnUXhV`]'a4|o8`O
7 $L	p 6&!+F6K:*!/NQ!O;,FH!GABWLxAsbs#n{omg+oUoKm|L!ZxqIyWauneWybokBMk!A@AzEq}~1d%{wwwjb*J  pRAj
''s g{ww{e7zZ.f9WaC8om}Q#ia`Xwkn~~QvwoXXnIAaPi\ !_iZ/)3fd!b#g `W-|Ahj50va~,aUj-#A@"<9!YZHy|`YgYl$!YYG1%*A!}z  
:Cx2-MU\;+Uw:z& z:z:zXYxA<  dtl@d  :aAAk^t1zbZAZ1H70 |jfx: {?uZLg{Qz[Kf[X_ 	 [f\L! !,%&q[y[dvb[iL{/;sU6zwt|(E!a!!a=A<E|IMQ6aJ<'/<7<W_<gH 9!0${GbXcCq1=A!!Aa\<|<!}|oL<|<=A!(Zd|}[{S&<S=A]=}aH(rn%=]]=}]A_y&r$4yw!Aa^=A>E~IMQ>IZM%/>7UYa^hoU{;8{0tU~a>>~^Azh.~p%^^!?%>D#n~]sBWAAmq?uy}_cGtZYa_i?l;^C?G~y7}? 	A'Kw<OW~n9G<~OwvnL&i5MbqXi{<JU. 0M&z_l~GuBr:5OU#Tjj}izS13z/sto9g*v/8n?#{yit^\-:-^*kx.8) }x]A{".<c~[+B nAHO31F;U;)q+32P[  f;qcf aw8G}	9!<1$Rd(JR,#LB6XN|`S58<@ uG#Gp )lGEQHt/)5P@G
V$ZVGs8A0nfeqG@Ta]SbZSeYqhAUe]/=E;7rj}tGCQt{@B>5X+|}WW|[,\]6+:F[VG@HqU,deYe}W-Uk^1p8B;v6H'F`Ui]]z.7N8i{g!nk'j#+SX6}p<?QS{AwEbT\<ngIy}e uqmwGVxZ9}[Y\RZ;r[|i|/%z?:6\bO<=y ; #!1'5Ax.!$U[vo\Bvr`
pGL`~DGPJ=XP 8[%nK	F
WvE\k
qP'cz+[K/	ctLE !`<gQ9GXw#$tvT2VKidFEd4E4pkb<-  2!+Xa/c
&\%#XNO+(p(2e$Ht;$:h'3?T03nl5%$g>XoaJ}"$(,>Pm@i<rQ@&DsepL!tf; r[}m>sztxi4UA&(QMIb7$#V%<z!7(D<\ZrQ10Ul5\k" DizKkW-dLbv;h\Vxmc8+mMmZjdDBPl[SolueCn[*_'b{r.l;8wmvkX.:R]jw`.-]f7_uxxpR7#!v%7rbgxvc4NBb|SM,#jXW";f!ccTG,W]4Lqab/ldYW'fkZ`'&eO@gc?+e7;M34J|5teSKC2ODs*Zc2A}s4,_R}%nSMRkmSksF0[Wp^)[m>oL[7n5l'z6>Gm.[6t3\g4o[7Lf>4#|l=q%08urwvW9<Dgu/gx=Yw9\)j<'Oq=yG7T$SU3/b.gepg[o5-}U/'S~_xyGeIU<#8tOiotSvOwQ2_K'yF[}n)Sn| r}?=m?0@ 22 K0?s[?:0l
@+-,$$Dtl	=dc["WAAPlbB)\"4$6tT@B:"B<
<.?uTB@
kB5 C'bC| <8,7kC?:`D4A3dB3CCHD*HX]rtRa.OEM"1,DS|TErWiEiUOZ\ME\OXF]
^,4-"(eJX'i*Tki+JfgmFn[urFY\G<txGnFl(xy&x2>H9GHLhuHyU$H
$HHHw*zH`tHtH~zz	2r]Q (J4YUIJJ`dI|dd$oK<r`~zG`@gp'(v|$L$LDLl"JPLLxuLHvL\|{$M4M+N`{V	@E7	n	tylT8vIcdpJb4NllNPNM\NNN	v| `)q"vPGP-mxmPB?%PQ	uLFQI]	]P}a=8w6aLr(y	`wRI%#(%u"-#UP~(E%ReS(Rm.M/0m4=2Se3R44m;-pt`T!:@DcbgBT17TEETbbTxTJT]FLB1TK
ML-:TTMTpxWXVUWT TMO&%Y	NOw@5D}'  -<k!{yMegi	VlUf2gVeVjE[TmW8uWeqVlWnUWpWmux-mM{%~C-o]p;1[0Rkd Ddz"
|ubYvXNQ}Y!}/X$Y=@UZSYY}ZeYZX`bxtgIE0`YgN`}P[O[!%-[\eM	~$Z	[\M\u\\V5Q\U$]e]$pyhtn  `  X`cPgzMHQmcM^^_u!=^^e=U_h__^f]` _[r_%`p`(_a-=aU`a Pv8qlH7@ p"0Sa0d`hQ ">$Pbf'b)b+a~,#x"b6$c1n')+7c/:2c35c6.b8AId.3c4.EZ-cGd0Qe
d<cF=a.^F9eR Sd>LYI[@qlhpeHc0b bef^ffngfxa@b0dPfxincQ]eL_faf&cfFhgNufVifkfmf^of]fqe`b>d^fnvkm.n]}g.~Fh&i&xh:)gg&~g>i>iNw6yfp}6iVihh.xF
iie~ht p_hpf`eXejkkV`gxhkou^hpj7.k>^xsjjjlkkVkvkflvkllm~mmm^lnNn^lFn.n>faxzu8q nljioooijlo}`xh@oo6oVovpoooo %Ov>^pVNwppqiq7	Op Opgr"r/#rqG
QOqq#*r$ori[r+o$pyv(rpnnm=s>s?s<npr'45_7s9s;s?Ks@B:TEo6xs9;K_>Bt7Dt*4G/HGJug^WtXEpsg[7IuO^_fvogv_NZQ[u'duUvnvov_hDHu?IomWYv|yspuHs0r rxx/xx r(s8tQ4UmoFz{o|~?yoolbgxOwkx{w}yz(qyyxmp}yoxzzzO?zg4xz{Oz7y7zyz?{ozwh|yB>|O|_{	xu?|?||z|w/|g$|}o|G|}}O|?~O}~:W}G~7~h~w~{y=$z8O~oyO%EbxAz=^~RyD	Bbe3FI&gCIpxL.)yv?!hym*aMk1QU't[Ek)2es\9ZnR7Z7RgDG}>k/g%er|A,\s}Fe6sS=zwm-yWp[N?Gt;vv\/Wq-<>]Vp ]I G~3[@ {;/	@,*Q/P9)<UQiG1+F 1GHtoH@*?((R0rK4$&(S6I4/9N>7N/=D<T-M'1LUMS81P}ITu5UV}aX=hVUq\UuKV`Vb=dV]f}hVjlVnpWr=tW]v}xWz|W~X	>X^~!X)1X9AYI
%%EndData
end
%%PageTrailer
%%Trailer
%%BoundingBox: -0 -0 825 177
%%HiResBoundingBox: 0 0 825 177
%%EOF

%%EndDocument
 @endspecial 181 2049 a(\(a\))g Fk([1)50 b(mark])55 b
Fi(Dra)-5 b(w)56 b(all)f(w)-5 b(a)g(ys)55 b(to)g(tile)g(a)g(2)37
b Ff(\002)g Fi(4)54 b(grid.)181 3208 y(\(b\))75 b Fk([2)51
b(marks])75 b Fi(Let)f Fe(f)18 b Fi(\()p Fe(n)p Fi(\))75
b(denote)h(the)g(n)-5 b(um)g(b)5 b(er)77 b(of)d(w)-5
b(a)g(ys)76 b(to)g(tile)f(a)g(2)51 b Ff(\002)g Fe(n)74
b Fi(grid.)135 b(So)75 b Fe(f)18 b Fi(\(0\))81 b(=)181
3409 y(1)p Fe(;)28 b(f)18 b Fi(\(1\))49 b(=)f(1)p Fe(;)28
b(f)18 b Fi(\(2\))49 b(=)f(2,)56 b(and)g Fe(f)18 b Fi(\(3\))48
b(=)h(3.)75 b(Find)56 b Fe(f)18 b Fi(\(5\))56 b(and)g
Fe(f)18 b Fi(\(6\))56 b(\(y)-5 b(ou)57 b(do)e(not)h(ha)-5
b(v)g(e)57 b(to)f(dra)-5 b(w)57 b(an)-5 b(y)181 3610
y(tilings,)56 b(but)f(y)-5 b(ou)55 b(can)g(if)f(it)h(helps)g(y)-5
b(ou\).)5407 4769 y Fe(f)18 b Fi(\(5\))47 b(=)5407 5928
y Fe(f)18 b Fi(\(6\))47 b(=)181 7087 y(\(c\))h Fk([2)j(marks])d
Fi(Let)f Fe(n)g Ff(\025)f Fi(2.)70 b(Assume)49 b(that)g(w)-5
b(e)49 b(kno)-5 b(w)49 b Fe(f)18 b Fi(\()p Fe(k)6 b Fi(\))47
b(for)h(all)g(v)-9 b(alues)49 b(0)d Ff(\024)g Fe(k)52
b Ff(\024)46 b Fe(n)24 b Ff(\000)g Fi(1.)70 b(Giv)-5
b(e)48 b(a)181 7288 y(simple)j(expression)h(that)f(calculates)h
Fe(f)18 b Fi(\()p Fe(n)p Fi(\))50 b(using)h(these)g(kno)-5
b(wn)51 b Fe(f)18 b Fi(\()p Fe(k)6 b Fi(\))49 b(v)-9
b(alues.)72 b(Carefully)51 b(justify)181 7488 y(y)-5
b(our)55 b(answ)-5 b(er)57 b(using)e(at)g(most)g Fh(t)-5
b(w)g(o)62 b(sen)-5 b(tences)p Fi(.)p Black Black eop
end
%%Page: 4 4
TeXDict begin 4 3 bop Black 181 -165 a Fj(Iv)-5 b(erson)55
b(exam)h(2016)p 1555 -165 4521 6 v 4738 w Fi(4)p Black
181 347 a(\(d\))46 b Fk([2)k(marks])c Fi(W)-14 b(rite)46
b(a)g(function)h Fd(tiling\(n\))i Fi(that)d(returns)h(the)f(v)-9
b(alue)46 b Fe(f)18 b Fi(\()p Fe(n)p Fi(\))45 b(for)h(a)f(giv)-5
b(en)47 b(in)-5 b(teger)181 548 y Fe(n)46 b Ff(\025)h
Fi(0.)72 b(F)-14 b(or)56 b(full)e(marks,)h(it)g(should)h(compute)g
Fe(f)18 b Fi(\(9999\))56 b(in)e(less)h(than)h(one)f(second.)181
3842 y(\(e\))63 b Fk([2)50 b(mark])63 b Fi(Let)g Fe(g)6
b Fi(\()p Fe(n)p Fi(\))62 b(denote)i(the)f(n)-5 b(um)g(b)5
b(er)65 b(of)d(w)-5 b(a)g(ys)64 b(to)f(tile)g(a)g(3)42
b Ff(\002)h Fe(n)62 b Fi(grid)h(using)h(domino)5 b(es.)181
4043 y(Here)55 b(is)f(a)h(tiling)g(of)g(a)f(3)37 b Ff(\002)g
Fi(4)55 b(grid:)p Black Black 2463 5293 a @beginspecial
0 @llx 0 @lly 321 @urx 249 @ury 1133 @rwi @setspecial
%%BeginDocument: Figures/34-tiling.eps
%!PS-Adobe-3.0 EPSF-3.0
%%Creator: (ImageMagick)
%%Title: (34-tiling.eps)
%%CreationDate: (2016-05-27T14:18:49-06:00)
%%BoundingBox: -0 -0 321 249
%%HiResBoundingBox: 0 0 321 249
%%LanguageLevel: 2
%%Pages: 1
%%EndComments

%%BeginDefaults
%%EndDefaults

%%BeginProlog
%
% Display a color image.  The image is displayed in color on
% Postscript viewers or printers that support color, otherwise
% it is displayed as grayscale.
%
/DirectClassImage
{
  %
  % Display a DirectClass image.
  %
  colorspace 0 eq
  {
    /DeviceRGB setcolorspace
    <<
      /ImageType 1
      /Width columns
      /Height rows
      /BitsPerComponent 8
      /Decode [0 1 0 1 0 1]
      /ImageMatrix [columns 0 0 rows neg 0 rows]
      compression 0 gt
      { /DataSource pixel_stream /LZWDecode filter }
      { /DataSource pixel_stream /LZWDecode filter } ifelse
    >> image
  }
  {
    /DeviceCMYK setcolorspace
    <<
      /ImageType 1
      /Width columns
      /Height rows
      /BitsPerComponent 8
      /Decode [1 0 1 0 1 0 1 0]
      /ImageMatrix [columns 0 0 rows neg 0 rows]
      compression 0 gt
      { /DataSource pixel_stream /LZWDecode filter }
      { /DataSource pixel_stream /LZWDecode filter } ifelse
    >> image
  } ifelse
} bind def

/PseudoClassImage
{
  %
  % Display a PseudoClass image.
  %
  % Parameters:
  %   colors: number of colors in the colormap.
  %
  currentfile buffer readline pop
  token pop /colors exch def pop
  colors 0 eq
  {
    %
    % Image is grayscale.
    %
    currentfile buffer readline pop
    token pop /bits exch def pop
    /DeviceGray setcolorspace
    <<
      /ImageType 1
      /Width columns
      /Height rows
      /BitsPerComponent bits
      /Decode [0 1]
      /ImageMatrix [columns 0 0 rows neg 0 rows]
      compression 0 gt
      { /DataSource pixel_stream /LZWDecode filter }
      {
        /DataSource pixel_stream /LZWDecode filter
        <<
           /K -1
           /Columns columns
           /Rows rows
        >> /CCITTFaxDecode filter
      } ifelse
    >> image
  }
  {
    %
    % Parameters:
    %   colormap: red, green, blue color packets.
    %
    /colormap colors 3 mul string def
    currentfile colormap readhexstring pop pop
    currentfile buffer readline pop
    [ /Indexed /DeviceRGB colors 1 sub colormap ] setcolorspace
    <<
      /ImageType 1
      /Width columns
      /Height rows
      /BitsPerComponent 8
      /Decode [0 255]
      /ImageMatrix [columns 0 0 rows neg 0 rows]
      compression 0 gt
      { /DataSource pixel_stream /LZWDecode filter }
      { /DataSource pixel_stream /LZWDecode filter } ifelse
    >> image
  } ifelse
} bind def

/DisplayImage
{
  %
  % Display a DirectClass or PseudoClass image.
  %
  % Parameters:
  %   x & y translation.
  %   x & y scale.
  %   label pointsize.
  %   image label.
  %   image columns & rows.
  %   class: 0-DirectClass or 1-PseudoClass.
  %   colorspace: 0-RGB or 1-CMYK.
  %   compression: 0-RLECompression or 1-NoCompression.
  %   hex color packets.
  %
  gsave
  /buffer 512 string def
  /pixel_stream currentfile def

  currentfile buffer readline pop
  token pop /x exch def
  token pop /y exch def pop
  x y translate
  currentfile buffer readline pop
  token pop /x exch def
  token pop /y exch def pop
  currentfile buffer readline pop
  token pop /pointsize exch def pop
  /Helvetica findfont pointsize scalefont setfont
  x y scale
  currentfile buffer readline pop
  token pop /columns exch def
  token pop /rows exch def pop
  currentfile buffer readline pop
  token pop /class exch def pop
  currentfile buffer readline pop
  token pop /colorspace exch def pop
  currentfile buffer readline pop
  token pop /compression exch def pop
  class 0 gt { PseudoClassImage } { DirectClassImage } ifelse
  grestore
} bind def
%%EndProlog
%%Page:  1 1
%%PageBoundingBox: 0 0 321 249
userdict begin
%%BeginData:         8018 Binary Bytes
DisplayImage
0 0
321 249
12
321 249
1
0
1
0
8
?P8$BaPd6DbQ8V-FcQv=HdR9$M'JeRd]/LfS9m7NgS}?PhT:%GRiTe6OTjU:VWVkUv=Xl/%gZmVeoXw^oWEyc~#bqXf7dqL&
a0YLw=hpGYXo|=Owmnw[}nvo}X]vtz]>93^hz<O/'z}^gxW{@+>N.cb" B-5= (xOp|#	1m)<Rzn<Z,mal]iv;` @VyyH$rj'2+2Ng@ t 7'Y+E}9<g?i-[!D"f`fAwG@ +K5NSEHP)	RQt{i8Vs].n V**U !tY6Y}i"vlWf C[\0@gG9xt]wmx^WGX:w*&v2~`x.Qv T'<ngIy)d	D>SX1Y7};]<l!x|g'"]&0z~w Ipb|kZw'a"g"qqAovaziA)r_W>} vruu{:fu'{k (=j| fqWyjIzx{~'z du?pY}xz|} 8|r;gF=q>vN r:K]~b;!;3Ny= 0j7:T.'O)C8j9rtp}x[ytP@Jcr <xb#tN".-6?G[42b9hN@w1"y@1mI?cHmHHFr/.AHI'NJx!N&4DJ+d~2SHY0r\Jm%0_	"Ov_@M%7RcL)o#&BM))9&fmB33d"sN	L	6nOy?&jcB3fC&t2r:(z]ACi,vRu_F4zIMCAb2iMi]"4{Ggm{T9<OJE;RMKu0&4JR:*U"}UN+D|mO?*x"f_6:L'tK`=%<I]WkrT%,%vpJKGA-4zUEe%V%i4Opv&<X-CBb"7qd1wo6\F
7.WF(s}(MEH
a"|4>tum0n)`vIl o@"|xFpd84r;eG<Ecm UvbN>d|efh#v0h3C;8<,n~sA6rf!DX,7pCy!L7KHs<T-$C#f<;:Wju{/mw&G  _/5~m6NM;m!=1)MFHoA^=w6[n17eN;HCk8jW/<F+e_+eB<`Gq< 2L+'  DXCeFB~0/r]9\wy:,hCtl
 z:]#pC0#c4}n^w;?i}&`,B
k8Dg10a=^z_MGcc3Fxs'|~|_G~gY[j=#p$40eG_~_3ho/j[oop oN
APY]a0epimjaEv 
=EMU
0
pu}0"!AaP0p0pWpp-1\3 ca1`eqimQy}1yQcASEc-#ipa[qQQ1g1nTOp%$`5 2 q!!pr	"1G~A#5h<!1 3%"7!+"m&%a"a'5#;5%e1L+%)*2*r&<++P"2*-2XJ|8,r,/2*,+W/1(#DP7U,3353s935*zDPsA4M4O.9$.=5a3q/E !.63}7A/F>sQ8K5A559?KD0'P
@ 2 u*JT:]<6! ;s>3D<JH8=$s=DSr?qDgrKB@LQ$O0T5CC
6!hI`$)(DSCCt85=Df$TFMTVeV$O1jE,XtGHHBHH%4zQTs"pR%VS>T4P%MKK[LR4T]M^.BXx\GjOOt%uO%Fd]%&Z[osQM{OQPL[&&5-Q`%_$]^e^RTUYDL_RVF `pba uuUWc5W,&5cqfpfPfZ0u'dMZfp;&^BoZFn4!yUhjFf]jjiF$hjam,l'Dla_a_l`pmnSn nxq&p#jp'(qgcwcfqr% t&g7dVje3effuT'zj<`ugg~v~'aga&t$zk'ziKi{LwkH~GlLYlGl}~~ lDhoHnCoLgmpB@(6h<(Kq?qB?qLmqzl-N\h}t(s~>"F#kb#%wfwku(hxW[ih2W7h3zyK I+gzP(Ki{Htc}wn#k]|}*#~"w)K{I~7wzi}"y}|0X({jx( 8<XX0X; a+j,Sy@gxK|XU"	x}k}oB#Je9w"U+g6Ym8ixlJ	CK;#
XI)K[8 X]Y "%wY885S=XY7;9?H"Qy1y'9WyuJ[xOX?XYj#L%}yxY"$y8[{9"xy-XY98CitaS9iBjWb%p!/i/h%v
AtM_f1z4":9aL#WE+iyZ=[L(orl yb!/U<.EzQJQM7.V+!m+aAE$FeDQ7;H!{ET)NtN@A,Y1MjZ%;{vpP>nZcElt|NBt@d:wjWb;|.NC;[";<1;|)?ov$,4Q/Ro\d
#\m<9#OXO<|p&F:yg4!	!0GO0W

00Z8TaP3}	/qqFq4xGK1W]=A==!'R}q=u!4+(sR=UYyr9rW1]=-T#tyE'*qs+%29F]WF;3=@A$!%E XcFsIzUJ4H?I4QK{~jKXU|c+2ODM~IQz;OF]W-XU]Tj![!;>Y}iBMpi\Cy\N4> >k@TuRZitDO$ "AJ[o+/U^r/[Twvpp?qJ7j>-{t{m- _;6+]Cwz'E|kb VcQs: .CN  aM|I1{<R9TYFN,"S-MGpq=K	rn;$y"6:5V9lZM2Xl5zdzAT-
ggS.w9lurfJm&f1;d=[Kf]zoo):+];eRJ~<QjQ.N{]b6~Ho|+z;0oI&@n+?A/ :@; QbdM	Elk1*3SFR
E+Q%;Hq=P1v2N$GCL'G/)2$85KG1Ml{CMe39QTEGs%=R>qHS?D5M0T	<GU:qQd{*`UKP`qbycoBtU9UPHrYVb?n[U[Xh*f]=%/P|^m b#F}0$m} ]E1tv d9(Xxcgx<bh!s'P\QhiPY{YAuCw[.^lr| w=p SqoQv|6<_<*sgsgGzJ	guiavquXvgvg
Lx&tyvw<{FW|>t}8vwA`fq; ' ,!^;axX'~7CyF !t0H;XR\<G` 
 "FL?q=GQ2'C3"TlwblO1N*w{Yw:B`{h#`5? $<#1#olPS\31dAGHy|(,UJ],%\KM*LW71"!`z,pw3I;}&a ,P<>GbmMzkc&rq:gZs^li>^qh8 vb]w@ 00rZQ*)E1tnCH)X|R[Kdj=H)$Osvq7F 
Xkc 0cd5iU:.jYuvk`lXjZenG>TbUaa5\/@~@dj2HbAnm;n1F0C4g17,|/8R;-][oov]vsjrZ]l-q.5NBP\jpv8c@g2XWa|1FV8g5Cu{S#`0c|qq4{b,IF T7pX?<w8{+8 C`kQ4k7fTk7#xer^1fL3Vq7Gh!ty;sY..g:OH\3|XW.r!7lmv_7 v'BZ}ouomwcsIMmMr-fwV>p(tq9G |4qp!x7A98[<xms|+ray|cq=28WNm\`9B>cwr:Xwuzwt7>[]w~{{v?;g<un;:|}:.B[~<yA}rA=yya!w{q}?QWoPCow}!S~3OC?8?[~(:}@l@|@zu@|)c\@AA
tTA$A2A@>,dAAAADA#B<$BL%B\&B4@DBl&B{B-B.B0C1C2C,3BC<16Cl7C|8C9C:C;C<C=C>C?C@DADBD,CD<DDLED\FDlGD|HDIDJp
%%EndData
end
%%PageTrailer
%%Trailer
%%BoundingBox: -0 -0 321 249
%%HiResBoundingBox: 0 0 321 249
%%EOF

%%EndDocument
 @endspecial 181 5477 a(So,)g Fe(g)6 b Fi(\(0\))47 b(=)f(1)p
Fe(;)28 b(g)6 b Fi(\(2\))47 b(=)g(3,)54 b Fe(g)6 b Fi(\(4\))47
b(=)g(11,)55 b(and)g Fe(g)6 b Fi(\(6\))46 b(=)h(41.)181
5878 y(What)55 b(is)g Fe(g)6 b Fi(\()p Fe(n)p Fi(\))54
b(when)i Fe(n)e Fi(is)g(o)5 b(dd?)73 b(Justify)54 b(y)-5
b(our)55 b(answ)-5 b(er.)181 7110 y(\(f)12 b(\))56 b
Fk([2)50 b(marks])57 b Fi(Let)f Fe(n)50 b Ff(\025)f Fi(2)57
b(b)5 b(e)56 b(an)h(ev)-5 b(en)57 b(in)-5 b(teger.)81
b(Assume)57 b(that)h(w)-5 b(e)57 b(kno)-5 b(w)58 b Fe(g)6
b Fi(\()p Fe(k)g Fi(\))55 b(for)i(all)g(0)49 b Ff(\024)h
Fe(k)55 b Ff(\024)181 7311 y Fe(n)44 b Ff(\000)g Fi(1.)104
b(Giv)-5 b(e)65 b(an)g(expression)i(that)f(easily)f(calculates)i
Fe(g)6 b Fi(\()p Fe(n)p Fi(\))65 b(using)h(these)g(kno)-5
b(wn)66 b Fe(g)6 b Fi(\()p Fe(k)g Fi(\))64 b(v)-9 b(alues.)181
7512 y(Justify)54 b(y)-5 b(our)55 b(answ)-5 b(er.)p Black
Black eop end
%%Page: 5 5
TeXDict begin 5 4 bop Black 181 -165 a Fj(Iv)-5 b(erson)55
b(exam)h(2016)p 1555 -165 4521 6 v 4738 w Fi(5)p Black
181 347 a Fg(question)90 b(2:)120 b(ascii)89 b(mazes)181
712 y Fi(One)63 b(w)-5 b(a)g(y)63 b(to)g(represen)-5
b(t)65 b(a)d(maze)h(using)g(ASCI)5 b(I)61 b(c)-5 b(haracters)65
b(is)e Fd(|)p Fi(-)p Fc(format)p Fi(,)h(whic)-5 b(h)64
b(uses)f(v)-5 b(ertical)181 913 y(bars)52 b Fd(|)p Fi(,)g(underscores)h
Fd(_)p Fi(,)f(and)g(spaces.)72 b(A)51 b(rectangular)i(grid)f(using)g
(only)f(these)h(three)g(c)-5 b(haracters)181 1113 y(is)55
b(a)f Fc(valid)j(maze)d Fi(if)347 1314 y Ff(\017)g Fi(there)i(are)f(at)
g(least)g(2)f(ro)-5 b(ws)56 b(and)f(at)g(least)g(3)g(columns,)h(and)347
1515 y Ff(\017)e Fi(the)h(top)g(ro)-5 b(w)56 b(has)f(only)g
Fd(_)f Fi(c)-5 b(haracters,)58 b(and)347 1715 y Ff(\017)c
Fi(the)h(\014rst)g(c)-5 b(haracter)58 b(in)c(the)h(second)h(ro)-5
b(w)56 b(is)e(a)h(space,)g(indicating)i(the)e(en)-5 b(trance,)57
b(and)347 1916 y Ff(\017)d Fi(the)h(last)g(c)-5 b(haracter)57
b(in)e(the)g(last)g(ro)-5 b(w)56 b(is)e Fd(_)p Fi(,)h(indicating)i(the)
e(exit,)g(and)347 2117 y Ff(\017)f Fi(except)h(for)g(the)f(en)-5
b(trance)57 b(and)e(exit,)g(the)g(\014rst)g(and)g(last)f(c)-5
b(haracter)57 b(on)e(eac)-5 b(h)56 b(ro)-5 b(w)55 b(is)f
Fd(|)p Fi(,)h(and)347 2317 y Ff(\017)f Fi(the)h(b)5 b(ottom)56
b(ro)-5 b(w)56 b(has)e(no)h(spaces.)181 2806 y Fh(Example)61
b(i)p Black Black 1416 2363 a Fd(_________)1587 2564
y(|)86 b(___)h(|)1416 2765 y(|)f(|)g(|)g(|)g(|)1416 2965
y(|_____|__)347 3295 y Fi(In)56 b Fd(|)p Fi(-format,)j(a)d(grid)h(cell)
g(is)f Fc(vac)-8 b(ant)56 b Fi(if)g(it)g(is)g(a)h(space,)h(or)e(if)g
(it)h(is)f(not)h(on)f(the)h(top)g(ro)-5 b(w)58 b(and)f(is)181
3496 y Fd(_)p Fi(.)73 b(Tw)-5 b(o)55 b(v)-9 b(acan)k(t)54
b(cells)h Fc(join)i(e)-8 b(ach)56 b(other)e Fi(if)f(one)h(is)f(b)5
b(eside)55 b(the)f(other)g(\(up,)h(do)-5 b(wn,)55 b(left,)f(or)g(righ)
-5 b(t\).)181 3696 y(Neigh)g(b)5 b(ouring)57 b(v)-9 b(acan)k(t)56
b(cells)f(join)g(eac)-5 b(h)56 b(other)f(if)f(and)h(only)g(if)f(no)h(w)
-5 b(all)56 b(separates)g(them.)181 4451 y(\(a\))37 b
Fk([1)50 b(marks])1217 4350 y Fi(F)-14 b(or)58 b(this)f(maze,)h(put)f
(a)g(dot)g(in)g(eac)-5 b(h)57 b(v)-9 b(acan)k(t)58 b(cell,)g(and)f(dra)
-5 b(w)58 b(a)f(line)1217 4551 y(b)5 b(et)-5 b(w)g(een)57
b(eac)-5 b(h)56 b(pair)f(of)f(v)-9 b(acan)k(t)56 b(cells)f(that)g(join)
g(eac)-5 b(h)56 b(other.)p Black Black 5729 3911 a Fl(____)5934
4160 y(_|)5729 4409 y(|)102 b(_|)5729 4658 y(|___)347
5036 y Fi(Another)56 b(w)-5 b(a)g(y)56 b(to)e(represen)-5
b(t)57 b(a)e(maze)g(is)g(with)g Fd(X)p Fi(-)p Fc(format)p
Fi(.)74 b Fd(X)p Fi(-format)56 b(uses)f(a)f(space)i(for)e(v)-9
b(acan)k(t)181 5237 y(cells)76 b(and)g(an)g Fd(X)g Fi(otherwise.)138
b(The)76 b(\014rst)g(c)-5 b(haracter)78 b(of)d(the)h(second)h(ro)-5
b(w)77 b(is)e(a)h(space,)82 b(for)75 b(the)181 5438 y(en)-5
b(trance;)63 b(the)58 b(last)h(c)-5 b(haracter)61 b(of)c(the)i
(second-last)h(ro)-5 b(w)60 b(is)e(a)g(space,)i(for)e(the)h(exit;)h(ev)
-5 b(ery)59 b(other)181 5638 y(c)-5 b(haracter)57 b(on)e(the)g
(rectangular)i(b)5 b(oundary)56 b(of)e(this)h(grid)g(is)g
Fd(X)p Fi(.)181 6431 y Fh(Example)61 b(ii)p Black Black
1416 5777 a Fb(XXXXXXXXX)1575 5965 y(X)398 b(X)1416 6153
y(X)79 b(X)h(XXX)e(X)1416 6341 y(X)h(X)h(X)f(X)g(X)1416
6530 y(X)g(X)h(X)f(X)g(X)1416 6718 y(X)398 b(X)1416 6906
y(XXXXXXXXX)347 7223 y Fi(W)-14 b(e)49 b(can)f(con)-5
b(v)g(ert)50 b(from)f Fd(|)p Fi(-format)g(to)f Fd(X)p
Fi(-format)i(b)-5 b(y)48 b(adding)h(extra)g(ro)-5 b(ws,)51
b(and)d(placing)i(a)e(space)181 7424 y(or)56 b Fd(X)g
Fi(b)5 b(et)-5 b(w)g(een)58 b(t)-5 b(w)g(o)57 b(cells)f(that)g(are)g
(on)g(top)h(of)e(eac)-5 b(h)57 b(other)f(indicating)i(whether)g(they)e
(join)f(eac)-5 b(h)181 7625 y(other.)109 b(The)67 b Fd(X)p
Fi(-format)h(example)f(ab)5 b(o)-5 b(v)g(e)68 b(is)e(what)h(w)-5
b(e)67 b(get)g(b)-5 b(y)67 b(con)-5 b(v)g(erting)69 b(from)d(the)h
Fd(|)p Fi(-format)181 7825 y(example.)117 b(Notice)70
b(that)f(the)h(n)-5 b(um)g(b)5 b(er)71 b(of)d(v)-9 b(acan)k(t)70
b(cells)g(can)f(c)-5 b(hange)71 b(during)f(this)g(con)-5
b(v)g(ersion.)181 8026 y(The)55 b(maze)h(in)e(\(b\))h(is)g(what)g(y)-5
b(ou)55 b(w)-5 b(ould)57 b(get)e(b)-5 b(y)54 b(con)-5
b(v)g(erting)58 b(from)d(the)g(maze)g(in)g(\(a\).)181
8893 y(\(b\))37 b Fk([1)50 b(marks])1226 8792 y Fi(F)-14
b(or)58 b(this)f(maze,)h(put)f(a)g(dot)g(in)g(eac)-5
b(h)57 b(v)-9 b(acan)k(t)58 b(cell,)g(and)f(dra)-5 b(w)58
b(a)f(line)1226 8993 y(b)5 b(et)-5 b(w)g(een)57 b(eac)-5
b(h)56 b(pair)f(of)f(v)-9 b(acan)k(t)56 b(cells)f(that)g(join)g(eac)-5
b(h)56 b(other.)p Black Black 5738 8333 a Fb(XXXX)5976
8521 y(X)5738 8709 y(X)79 b(XX)5738 8897 y(X)158 b(X)5738
9086 y(X)79 b(XX)5738 9274 y(X)5738 9462 y(XXXX)p Black
Black eop end
%%Page: 6 6
TeXDict begin 6 5 bop Black 181 -165 a Fj(Iv)-5 b(erson)55
b(exam)h(2016)p 1555 -165 4521 6 v 4738 w Fi(6)p Black
347 347 a(\(c\))64 b Fk([4)50 b(marks])64 b Fi(W)-14
b(rite)65 b(a)e(function)i Fd(convert\(maze\))k Fi(that)64
b(tak)-5 b(es)65 b(an)f(arra)-5 b(y)64 b(or)g(list)g(of)f(strings)181
548 y(represen)-5 b(ting)62 b(a)c(v)-9 b(alid)59 b(maze)h(in)e
Fd(|)p Fi(-format)i(and)g(prin)-5 b(ts)60 b(the)f(corresp)5
b(onding)61 b(maze)e(in)g Fd(X)p Fi(-format.)181 748
y(F)-14 b(or)55 b(example,)h Fd(maze)g Fi(is)f(from)g(\(a\))g(then)g
Fd(convert\(maze\))60 b Fi(prin)-5 b(ts)56 b(the)f(maze)g(from)g
(\(b\).)347 4252 y(\(d\))82 b Fk([6)50 b(marks])81 b
Fi(No)-5 b(w)83 b(write)f(a)f(function)i Fd(search\(maze\))j
Fi(that)c(tak)-5 b(es)82 b(an)g(arra)-5 b(y)82 b(of)f(strings)181
4452 y(represen)-5 b(ting)62 b(a)d(maze)h(in)f Fd(X)p
Fi(-format.)88 b(It)58 b(should)j(prin)-5 b(t)60 b(a)f(path)h(from)f
(the)h(en)-5 b(trance)61 b(to)e(the)g(exit)181 4653 y(using)j
Fd(*)e Fi(c)-5 b(haracters.)94 b(Y)-14 b(ou)62 b(ma)-5
b(y)61 b(assume)h(that)f(there)h(is)f(exactly)g(one)g(w)-5
b(a)g(y)62 b(to)f(tra)-5 b(v)g(el)62 b(from)f(the)181
4854 y(en)-5 b(trance)57 b(to)e(the)g(exit)f(using)i(a)e(path)i(that)f
(do)5 b(es)55 b(not)g(visit)f(a)h(cell)g(more)g(than)h(once.)181
5620 y Fh(Example)p Fi(:)119 b(calling)82 b Fd(search\(maze\))h
Fi(with)c Fd(X)p Fi(-format)h(example)g(ii)e(giv)-5 b(es)79
b(this)181 5821 y(output:)p Black Black 5516 5161 a Fb(XXXXXXXXX)5516
5349 y(**X*****X)5516 5537 y(X*X*XXX*X)5516 5725 y(X*X*X)e(X*X)5516
5913 y(X*X*X)g(X*X)5516 6102 y(X***)157 b(X**)5516 6290
y(XXXXXXXXX)p Black Black eop end
%%Page: 7 7
TeXDict begin 7 6 bop Black 181 -165 a Fj(Iv)-5 b(erson)55
b(exam)h(2016)p 1555 -165 4521 6 v 4738 w Fi(7)p Black
181 347 a Fg(question)90 b(3:)120 b(blorks)181 712 y
Fi(A)47 b Fc(binary)53 b(string)48 b Fi(con)-5 b(tains)50
b(only)e Fd(0)p Fi(s)g(and)g Fd(1)p Fi(.)71 b(A)47 b
Fc(blork)g Fi(is)h(a)f(string)i(con)-5 b(taining)51 b(only)d(c)-5
b(haracters)50 b Fd(0)p Fi(,)181 913 y Fd(1)p Fi(,)k(and)h
Fd(*)p Fi(.)72 b(A)54 b(binary)g(string)h Fd(str)g Fc(matches)e
Fi(a)h(blork)g Fd(blrk)h Fi(if)e(eac)-5 b(h)55 b Fd(*)f
Fi(c)-5 b(haracter)56 b(in)e Fd(blrk)h Fi(can)g(b)5 b(e)181
1113 y(replaced)64 b(with)f(a)f(binary)h(string)g(\(p)5
b(ossibly)63 b(empt)-5 b(y)-14 b(,)66 b(and)d(the)f(binary)h(strings)h
(do)e(not)h(all)f(ha)-5 b(v)g(e)181 1314 y(to)59 b(b)5
b(e)58 b(the)h(same\))h(so)e(that)i(the)f(resulting)h(string)f(equals)h
Fd(str)p Fi(.)85 b(W)-14 b(e)59 b(sho)-5 b(w)60 b(suc)-5
b(h)60 b(a)e(matc)-5 b(hing)61 b(b)-5 b(y)181 1515 y(starting)46
b(with)g(the)f(blork)g(and)g(then)h(replacing)g(eac)-5
b(h)46 b Fd(*)f Fi(with)h Fd(\(b\))f Fi(where)h Fd(b)f
Fi(is)g(the)g(needed)h(binary)181 1715 y(string)56 b(for)e(that)h
Fd(*)p Fi(.)181 2117 y Fh(Example)p Black 423 2456 a
Ff(\017)p Black 82 w Fd(str)86 b(=)g("01001")p Fi(,)58
b Fd(blrk)87 b(=)f("01*01")p Fi(,)57 b Fh(matc)-5 b(h)53
b Fd("01\(0\)01")p Black 423 2795 a Ff(\017)p Black 82
w Fd(str)86 b(=)g("101")p Fi(,)57 b Fd(blrk)87 b(=)f("10**1")p
Fi(,)57 b Fh(matc)-5 b(h)53 b Fd("10\(\)\(\)1")p Black
423 3134 a Ff(\017)p Black 82 w Fd(str)86 b(=)g("10101101")p
Fi(,)45 b Fd(blrk)87 b(=)f("10*10*")p Fi(,)43 b Fh(matc)-5
b(h)35 b Fd("10\(101\)10\(1\)")92 b(and)86 b("10\(\)10\(1101\)")p
Black 423 3473 a Ff(\017)p Black 82 w Fd(str)g(=)g("")p
Fi(,)55 b Fd(blrk)88 b(=)e("")55 b Fi(\(b)5 b(oth)55
b(strings)g(are)g(empt)-5 b(y\),)57 b Fh(matc)-5 b(h)53
b Fd("")p Black 423 3812 a Ff(\017)p Black 82 w Fd(str)86
b(=)g("11101")p Fi(,)58 b Fd(blrk)87 b(=)f("101*")p Fi(,)57
b Fh(no)62 b(matc)-5 b(h)61 b(p)5 b(ossible)347 4351
y Fi(\(a\))58 b Fk([2)50 b(marks])57 b Fi(F)-14 b(or)57
b(eac)-5 b(h)59 b(of)d(the)i(follo)-5 b(wing,)60 b(indicate)e(whether)h
(it)e(matc)-5 b(hes.)82 b(If)56 b(y)-5 b(es,)58 b(giv)-5
b(e)58 b(one)181 4552 y(replacemen)-5 b(t,)58 b(in)d(the)g(same)g(form)
g(as)g(the)g(example.)p Black 423 4932 a Ff(\017)p Black
82 w Fd(str)86 b(=)g("1001")p Fi(,)57 b Fd(blrk)87 b(=)f("*1*0*1*")p
Black 423 5673 a Ff(\017)p Black 82 w Fd(str)g(=)g("110110001010100")p
Fi(,)62 b Fd(blrk)87 b(=)f("1101*100*10*01*")p Black
423 6413 a Ff(\017)p Black 82 w Fd(str)g(=)g("10001101001")p
Fi(,)60 b Fd(blrk)88 b(=)d("100*11*101")p Black 423 7153
a Ff(\017)p Black 82 w Fd(str)h(=)g("")p Fi(,)55 b Fd(blrk)88
b(=)e("*")p Black 423 7894 a Ff(\017)p Black 82 w Fd(str)g(=)g
("100101010100001010)q(00)q(101)q(11)q(01)q(10)q(1")p
Fi(,)63 b Fd(blrk)87 b(=)f("*1001*001*11*101")p Black
423 8634 a Ff(\017)p Black 82 w Fd(str)g(=)g("000110101101100010)q(10)q
(101)q(01)q(01)q(10)q(1")p Fi(,)63 b Fd(blrk)87 b(=)f
("*1101*101010*110")p Black Black eop end
%%Page: 8 8
TeXDict begin 8 7 bop Black 181 -165 a Fj(Iv)-5 b(erson)55
b(exam)h(2016)p 1555 -165 4521 6 v 4738 w Fi(8)p Black
347 347 a(\(b\))f Fk([3)c(marks])k Fi(W)-14 b(rite)55
b(a)g(function)h Fd(extract\(blrk\))61 b Fi(that)55 b(tak)-5
b(es)56 b(a)f(blork)g Fd(blrk)h Fi(as)f(parameter)181
548 y(and)h(returns)h(an)f(arra)-5 b(y)57 b(or)f(list)g(of)f(strings)i
(with)f(the)g(binary)h(subtring)g Fc(pie)-8 b(c)g(es)54
b Fi(of)67 b Fd(blrk)p Fi(,)58 b(namely)181 748 y(the)d(nonempt)-5
b(y)57 b(binary)e(substrings)i(left)d(o)-5 b(v)g(er)56
b(if)e(eac)-5 b(h)56 b Ff(\003)e Fi(is)g(replaced)j(with)e(a)g(space.)
347 949 y(Example:)69 b(for)46 b Fd(blrk)88 b(=)d("*10**1110*110")53
b Fi(the)46 b(three)i(pieces)f(are)f Fd("10",)88 b("1110",)h("110")p
Fi(.)347 5061 y(\(c\))52 b Fk([5)e(marks])h Fi(W)-14
b(rite)52 b(a)f(function)i Fd(match\(str,)90 b(blrk\))53
b Fi(that)f(tak)-5 b(es)52 b(a)f(binary)h(string)g Fd(str)g
Fi(and)181 5262 y(blork)k Fd(blrk)h Fi(as)e(parameters)j(and)e(returns)
h Fd(true)g Fi(if)e Fd(str)i Fi(matc)-5 b(hes)57 b Fd(blrk)g
Fi(and)f Fd(false)h Fi(otherwise.)181 5462 y(If)42 b(it)i(is)f
(helpful,)j(y)-5 b(ou)44 b(ma)-5 b(y)44 b(use)f(the)h(function)g
(describ)5 b(ed)45 b(in)e(part)h(\(b\))g(ev)-5 b(en)44
b(if)f(y)-5 b(ou)43 b(did)h(not)g(answ)-5 b(er)181 5663
y(that)55 b(question.)p Black Black eop end
%%Page: 9 9
TeXDict begin 9 8 bop Black 181 -165 a Fj(Iv)-5 b(erson)55
b(exam)h(2016)p 1555 -165 4521 6 v 4738 w Fi(9)p Black
181 347 a Fg(question)90 b(4:)120 b(hex)181 712 y Fh(W)-16
b(arning)p Fi(:)73 b(this)55 b(question)h(can)f(tak)-5
b(e)55 b(time.)73 b(Budget)56 b(y)-5 b(our)56 b(time)f(wisely)-14
b(.)347 1113 y(The)49 b(t)-5 b(w)g(o-pla)g(y)g(er)51
b(game)e(of)f(Hex)f(is)h(pla)-5 b(y)g(ed)50 b(on)e(an)g
Fe(n)23 b Ff(\002)g Fe(n)49 b Fi(b)5 b(oard)49 b(with)f(hexagonal)i
(cells.)71 b(Belo)-5 b(w)181 1314 y(is)49 b(a)h(7)26
b Ff(\002)g Fi(7)50 b(b)5 b(oard.)72 b(Pla)-5 b(y)g(ers)50
b(alternate)i(turns.)72 b(On)49 b(a)h(turn,)h(a)e(pla)-5
b(y)g(er)51 b(puts)f(a)g(stone)g(on)g(an)f(empt)-5 b(y)181
1515 y(cell.)347 1715 y(The)60 b(\014rst)f(pla)-5 b(y)g(er)60
b(is)f(called)h Fc(white)e Fi(and)h(places)h(white)g(stones.)87
b(The)59 b(second)h(pla)-5 b(y)g(er)61 b(is)d(called)181
1916 y Fc(black)47 b Fi(and)i(places)g(blac)-5 b(k)50
b(stones.)72 b(Tw)-5 b(o)49 b(opp)5 b(osing)50 b(sides)f(of)f(the)h(b)5
b(oard)49 b(are)g(white)h(and)f(the)g(other)181 2117
y(t)-5 b(w)g(o)65 b(opp)5 b(osing)64 b(sides)f(are)h(blac)-5
b(k.)99 b(The)63 b(winner)h(is)f(who)5 b(ev)-5 b(er)64
b(connects)h(their)f(t)-5 b(w)g(o)64 b(sides)g(with)g(a)181
2317 y(connected)57 b(path)e(of)f(their)i(stones.)74
b(In)54 b(the)h(example)g(b)5 b(elo)-5 b(w,)56 b(blac)-5
b(k)56 b(has)f(w)-5 b(on.)p Black Black 1281 5122 a @beginspecial
0 @llx 0 @lly 113 @urx 74 @ury 2834 @rwi @setspecial
%%BeginDocument: fz/pix/7x7-f1b6.eps
%!PS-Adobe-3.0
%%Creator: Jack van Rijswijck, thanks to Cameron Browne
%%BoundingBox: 0 0 113 74
%%Pages: 0
%%EndComments

/OriginX -6 def
/OriginY 63 def
%---------------- Variables -------------------

/DimX 7 def
/DimY 7 def
/Scale 1.2 def


% draw  Hex boards, any size ... but labels only up to 26x26
% based on code by Cameron Browne, revised by Jack vR, revised by RBH
%-------------- state initializations -------------------------
1 setlinejoin   % lines meet at a point  ==>    use round join
%---------------- constants -------------------
/Root3Div2  0.86602540378444 def
/Chars   {[(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)
           (n)(o)(p)(q)(r)(s)(t)(u)(v)(w)(x)(y)(z)]} def
/CharsUC {[(A)(B)(C)(D)(E)(F)(G)(H)(I)(J)(K)(L)(M)
           (N)(O)(P)(Q)(R)(S)(T)(U)(V)(W)(X)(Y)(Z)]} def
/Digits  {[(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)(12)(13)
           (14)(15)(16)(17)(18)(19)(20)(21)(22)(23)(24)(25)(26)]} def
/HexRadius      5 Scale mul def % hexagon center-to-corner distance 
/HexLineWidth 0.1 Scale mul def 
/GraphVertexSize 1.0 Scale mul def
/GraphLineWidth 0.5 Scale mul def
/CircleRadius 3.0 Scale mul def 
/CircleLineWidth 0.346 Scale mul def 
/PerimeterWidth 0.5 Scale mul def 
/TextHeight 4.5 def
/TextWidth TextHeight 0.45 mul def 
/BoardShade 0.8 def
/CoordinatesShade 0.5 def
/MarkerSize 1.2 def
/CellOrientation 1 def   % 1: flat bottom  0: pointed bottom
/CellCorner [ % 6 cell corners, wrt center 0 0, plus "up" and "down"
   [ HexRadius  neg       0                           ] 
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul neg ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul neg ]
   [ HexRadius            0                           ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul     ]
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul neg ]
] def
%----- name cell corner indices ... see below
/Left  0 def /DownLeft 1 def /DownRight 2 def 
/Right 3 def /UpRight  4 def /UpLeft    5 def 
/Up    6 def /Down     7 def
%-----------------------------------------------------
% cell orientations:  flat bottom    flat side
%-----------------------------------------------------
% flat bottom 
% board cell indices            cell corner/top/bottom indices
%             --
%           /    \
%        --   1,3  --                  5 -6- 4
%      /    \    /    \               /       \
%   --   1,2  --   2,3  --           0         3
% /    \    /    \    /    \          \       /
%   1,1  --   2,2  --   3,3            1 -7- 2
% \    /    \    /    \    /
%   --   2,1  --   3,2  --
%      \    /    \    /   
%        --   3,1  --     
%----------------------------------------------------
% flat side 
%    /  \  /  \  /  \                       5
%   | 11 || 12 || 13 ||                   /   6
%    \  /  \  /  \  /  \                 0     4
%     || 21 || 22 || 23 |                |     |
%       \  /  \  /  \  /  \              1     3
%        || 31 || 32 || 33 |              7   /
%-------------------------------------------2--------
%----------- procedures -------------
/ScalePoint { % stack: ... x y size ==> ...  x*size y*size
   3 dict begin /size exch def /y exch def /x exch def
   x size mul           y size mul
end } def

/FlatTopBoard { FlatSideCells } def

/FlatSideCells {  % redefine cell orientation for flat side
  /CellOrientation 0 def   
  /CellCorner [ % 6 cell corners, wrt center 0 0  %xcoord ycoord
    [HexRadius Root3Div2 mul neg  HexRadius 2 div     ]
    [HexRadius Root3Div2 mul neg  HexRadius 2 div neg ]
    [0                            HexRadius neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div ]
    [0                            HexRadius ]
    [HexRadius Root3Div2 2 div mul HexRadius 0.75 mul ]
    [HexRadius Root3Div2 2 div mul neg HexRadius 0.75 mul neg ]
  ] def
} def

/HexCenterPoint { % center of cell (i,j)
    2 dict begin /j exch def /i exch def
    CellOrientation 1 eq {
    OriginX i j add HexRadius mul 1.5 mul add %Ox + (i+j)*HR*1.5
    OriginY i j sub HexRadius mul Root3Div2 mul sub %Oy - (i-j)*HR*R3/2
    }{
    OriginX i 2 j mul add HexRadius mul Root3Div2 mul add  %Ox + (2i+j)*HR
    OriginY i 1 sub HexRadius mul 1.5 mul sub %Oy - i*HR*R3/2
    } ifelse
end } def
 
/HexLine { % a b c d
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint lineto
    stroke
} def

/HexCurve { % a b c d e f
    /f exch def
    /e exch def
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint e f HexCenterPoint HexRadius 2 mul arcto
    e f HexCenterPoint lineto
    stroke
} def

/HxgnCorner { 5 dict begin /corn exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    x CellCorner corn get 0 get add
    y CellCorner corn get 1 get add
end } def

/Go { 2 dict begin /corn exch def /mag exch def
   % rlineto in a cell orientation direction
   CellCorner corn get aload pop mag ScalePoint rlineto
end } def

/TurnGo { rotate 1.0 Left Go } def % call: degrees TurnGo
/MagTurnGo { rotate Left Go } def % call: mag degrees TurnGo

/HexagonPath { % call: i j HexagonPath
    newpath 
    UpRight HxgnCorner moveto 
    6 { 1.0 Left Go 60 rotate } repeat 
} def

/FillAndStroke { 2 dict begin /sh exch def /wdth exch def
    gsave sh setgray fill
    grestore 0 setgray wdth setlinewidth stroke
end } def

/ShadedHexagon { 3 dict begin /shade exch def /j exch def /i exch def
    i j HexagonPath
    0 shade FillAndStroke
end } def

/Hexagon { % stack: ... i j
    HexagonPath 
    HexLineWidth BoardShade FillAndStroke
} def

/SemiHexagonPath { % stack: ... top i j
    newpath 
    1 eq { Left HxgnCorner moveto 
        1.0 UpRight Go 1.0 Right Go 1.0 DownRight Go stroke }{
        Right HxgnCorner moveto 
        1.0 DownLeft Go 1.0 Left Go 1.0 UpLeft Go stroke
    } ifelse
} def

/HexBoardPerimeter {
    newpath
    1 DimY UpRight HxgnCorner moveto 1.0 Left Go                      
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 rotate %restore rotation
} def

%----------- Havannah coordinates ----------------------
%                   ..  ..  ..
%                 d1  c2  b3  a4
%                   c1  b2  a3
%                     b1  a2
%                       a1
/HavannahPosn { % convert to usual coordinate, so ... x y  =>  ... 1+DimX-x  y
    exch DimX 1 add exch sub exch 
} def

/HavannahBoardPerimeter {
    newpath
    1 DimX UpRight HxgnCorner moveto 1.0 Left Go                      
    6 {Base 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo } repeat
} def

/DrawHexBoard { 2 dict begin
    gsave
    HexBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexPLBoard { 6 dict begin %point-line board
    gsave
    BoardShade setgray newpath
    -1 DimY 1 add 0.5 mul HexCenterPoint moveto
    1 DimY HexCenterPoint lineto
    DimX 1 add 0.5 mul DimY 2 add HexCenterPoint lineto
    DimX DimY HexCenterPoint lineto
    DimX 2 add DimY 1 add 0.5 mul HexCenterPoint lineto
    DimX 1 HexCenterPoint lineto
    DimX 1 add 0.5 mul -1 HexCenterPoint lineto
    1 1 HexCenterPoint lineto
    closepath fill 0 setgray
    1 DimY HexCenterPoint moveto
    1 1 DimX { /i exch def 
        i 1 i DimY HexLine 
        DimY 1 add 0.5 mul -1 i 1 HexLine
        DimY 1 add 0.5 mul DimY 2 add i DimY HexLine } for
    1 1 DimY { /j exch def 
        1 j DimX j HexLine 
        -1 DimX 1 add 0.5 mul 1 j HexLine
        DimX 2 add DimX 1 add 0.5 mul DimX j HexLine } for
    /topx 1 def /topy 1 def /btmx 1 def /btmy 1 def
    DimX DimY add 3 sub {
      topx DimX lt {/topx 1 topx add def}{/topy 1 topy add def} ifelse 
      btmy DimY lt {/btmy 1 btmy add def}{/btmx 1 btmx add def} ifelse 
      topx topy btmx btmy HexLine
      } repeat
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j HexVertex
	} for } for
    grestore
end } def

/DrawHavannahBoard { 3 dict begin
    /Base DimX 1 add 2 idiv  def
    gsave
    HavannahBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 Base { /j exch def
	Base j 1 sub sub 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    1 1 Base 1 sub { /j exch def
	1 1 DimX j sub { /i exch def
	   i j Base add 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexBorder{ 6 dict begin /start exch def 
    /cells exch def /isBlack exch def /which exch def
    gsave
    which UpLeft eq {1 DimY 1 add start sub Up HxgnCorner moveto /d Left def /r 60 def} if
    which UpRight eq {start DimY Up HxgnCorner moveto /d Right def /r 300 def} if
    which DownLeft eq {DimX 1 add start sub 1 Down HxgnCorner moveto /d Left def /r 300 def} if
    which DownRight eq {DimX start Down HxgnCorner moveto /d Right def /r 60 def} if
    0.5 d Go 
    which UpRight eq which DownRight eq or {180 rotate} if
    r TurnGo 
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.5 360 r sub MagTurnGo 1.5 360 r sub 2 mul MagTurnGo
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.75 360 r sub MagTurnGo
    closepath isBlack 1 eq {gsave fill grestore} if stroke grestore
end } def

/NoDrawHexBoard {  % dummy, used in creating bounding box
} def

/HexBoardBorders { 1 dict begin
    /upperLeftBlack exch def
    PerimeterWidth setlinewidth 0 setgray
    UpLeft    upperLeftBlack       DimY 1 DrawHexBorder
    UpRight   1 upperLeftBlack sub DimX 1 DrawHexBorder
    DownRight upperLeftBlack       DimY 1 DrawHexBorder
    DownLeft  1 upperLeftBlack sub DimX 1 DrawHexBorder
end } def

/YBoardPerimeter {
    newpath 1 1 DownRight HxgnCorner moveto 180 rotate
    3 { DimX 1 sub { 300 TurnGo 60 TurnGo } repeat 
        60 TurnGo 60 TurnGo} 
    repeat % now restore initial rotation state
    180 rotate % closepath
} def

/DrawYBoard { 2 dict begin
    YBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimX {/j exch def
        1 1 DimX 1 add j sub {/i exch def
	    i j 1 SemiHexagonPath stroke
        } for } for
end } def

/FontSelect { % bold italic FontSelect
    2 dict begin /italic exch def /bold exch def
    bold {
	italic 
	{ /Times-BoldItalic findfont TextHeight scalefont setfont } 
	{ /Times-Bold findfont TextHeight scalefont setfont }
	ifelse} 
        {
	italic {/Times-Italic findfont TextHeight scalefont setfont} 
	{ /Times findfont TextHeight scalefont setfont }
	ifelse}
    ifelse
end } def
	    
/LabelString {   % call: i j (str) strlen LabelString
%  to use with board rotation, remove comments
    6 dict begin /strlen exch def /str exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint /y exch def /x exch def
    %BoardRotation rotate
    x y moveto 
    %360 BoardRotation sub rotate
    TextWidth strlen mul 0.5 mul neg TextHeight 0.33 mul neg rmoveto
    str show 
end } def

/AbsLabelString { 4 dict begin
    /strlen exch def /str exch def /y exch def /x exch def
    newpath
    x AbsCoordX TextWidth strlen mul 0.5 mul sub
    y AbsCoordY TextHeight 0.33 mul sub
    moveto
    str
    show
end } def

/LabelStringVerb { % i j (str) strlen shade bold italic LabelStringVerb
    7 dict begin /italic exch def /bold exch def /shade exch def
    /strlen exch def /str exch def /j exch def /i exch def
    bold italic FontSelect shade setgray
    i j str strlen LabelString
end } def

/HexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimX { /i exch def
	i 0          Chars i 1 sub get 1 LabelString
	i DimY 1 add Chars i 1 sub get 1 LabelString
    } for
    1 1 DimY { /j exch def
	0 j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
	DimX 1 add j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HavannahBoardCoordinates { 3 dict begin
    false true FontSelect CoordinatesShade setgray
    /Base DimX 1 add 2 idiv  def
    1 1 Base { /i exch def
	i 0 HavannahPosn Chars  i 1 sub get 1 LabelString
	0 i HavannahPosn Digits i 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
    1 1 Base 1 sub { /i exch def
	i Base add i HavannahPosn Chars  i Base add 1 sub get 1 LabelString
	i i Base add HavannahPosn Digits i Base add 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/AltHexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimY { /j exch def
	0 j Chars j 1 sub get 1 LabelString
        %DimX 1 add j Chars j 1 sub get 1 LabelString
    } for
    1 1 DimX { /i exch def
	i 0 Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
	%i DimY 1 add Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HexDot { 3 dict begin /size exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint size 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexWhiteMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexWhitePiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexBlackMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexBlackPiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    1 setgray 0 setlinewidth fill
end } def

/HexDoubleMarker { 6 dict begin
    /shaderight exch def /shadeleft exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    gsave
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    shadeleft setgray 0 setlinewidth fill
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    shaderight setgray 0 setlinewidth fill
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    grestore
end } def

/HexBlackWhiteMarker { 0.0 1.0 HexDoubleMarker } def

/HexWhiteBlackMarker { 1.0 0.0 HexDoubleMarker } def
        
/HexMarker { 2 dict begin /j exch def /i exch def
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setlinewidth fill
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke  
end } def

/HexBlackMarker { 2 dict begin /j exch def /i exch def
    0 setgray
    i j HexMarker
end } def

/HexWhiteMarker { 2 dict begin /j exch def /i exch def
    1 setgray
    i j HexMarker
end } def
    
/HexPiece { 3 dict begin /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/MagicStone { 4 dict begin 
    /size exch def /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 1.3 mul size mul 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/HexWhitePiece { 1.0 HexPiece } def

/HexBlackPiece { 0.0 HexPiece } def

/HexWhiteLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def
    i j HexWhitePiece
    i j str strlen 0.0 true true LabelStringVerb
end } def

/HexBlackLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def 
    i j HexBlackPiece
    i j str strlen 1.0 true true LabelStringVerb
end } def

/AbsCoordX { 1 dict begin /x exch def
    OriginX x Scale mul add
end } def

/AbsCoordY { 1 dict begin /y exch def
    OriginY y Scale mul add
end } def

/DrawBox { /maxy exch def /maxx exch def /miny exch def /minx exch def
    newpath
    minx miny moveto
    maxx minx sub 0 rlineto
    0 maxy miny sub rlineto
    minx maxx sub 0 rlineto
    0 miny maxy sub rlineto
    HexLineWidth setlinewidth
    0 setgray
    stroke
} def

/HexVertex { 2 dict begin /j exch def /i exch def
    i j GraphVertexSize HexDot
end } def

/HexLine { 4 dict begin /j2 exch def /i2 exch def /j1 exch def /i1 exch def
    GraphLineWidth setlinewidth
    0 setgray
    newpath
    i1 j1 HexCenterPoint moveto
    i2 j2 HexCenterPoint lineto
    stroke
end } def

%%---------------- Program -------------------


% transpose: f1 b6 c5 e5 f5 f2 e3 e4 f3 d3

FlatTopBoard
DrawHexBoard
1 HexBoardBorders

6 1 HexWhitePiece
2 6 HexBlackPiece
3 5 HexWhitePiece
5 5 HexBlackPiece
6 5 HexWhitePiece
6 2 HexBlackPiece
5 3 HexWhitePiece
5 4 HexBlackPiece
6 3 HexWhitePiece
4 3 HexBlackPiece
5 2 HexWhitePiece
6 4 HexBlackPiece
4 6 HexWhitePiece
4 4 HexBlackPiece
2 4 HexWhitePiece
3 2 HexBlackPiece
1 3 HexWhitePiece
2 1 HexBlackPiece
1 2 HexWhitePiece
1 1 HexBlackPiece
3 1 HexWhitePiece
2 2 HexBlackPiece
4 2 HexWhitePiece
3 3 HexBlackPiece
7 4 HexWhitePiece
7 3 HexBlackPiece


%------------ Trailer --------------

showpage

%%EndDocument
 @endspecial 347 5502 a(An)62 b(amazing)h(prop)5 b(ert)-5
b(y)64 b(of)d(Hex)g(is)h(that)h(if)e(the)h(b)5 b(oard)63
b(is)e(completely)j(co)-5 b(v)g(ered)64 b(with)f(stones)181
5703 y(then)55 b(exactly)g(one)h(pla)-5 b(y)g(er)56 b(has)f(joined)g
(their)g(t)-5 b(w)g(o)56 b(sides.)74 b(So)55 b(dra)-5
b(ws)56 b(are)f(not)g(p)5 b(ossible.)347 6104 y(This)53
b(question)g(is)f(ab)5 b(out)52 b(pla)-5 b(ying)54 b(p)5
b(erfectly)52 b(in)g(Hex.)71 b(W)-14 b(e)53 b(sa)-5 b(y)52
b(that)g(a)g(pla)-5 b(y)g(er)54 b(pla)-5 b(ys)53 b Fc(p)-8
b(erfe)g(ctly)181 6305 y Fi(if,)46 b(on)f(eac)-5 b(h)46
b(mo)-5 b(v)g(e,)48 b(if)c(there)i(is)e(some)i(mo)-5
b(v)g(e)46 b(that)f(is)g(part)g(of)f(a)h(winning)h(strategy)g(for)e
(that)i(pla)-5 b(y)g(er,)181 6506 y(then)45 b(the)f(pla)-5
b(y)g(er)45 b(mak)-5 b(es)45 b(suc)-5 b(h)45 b(a)f(mo)-5
b(v)g(e.)70 b(So,)47 b(who)5 b(ev)-5 b(er)45 b(can)f(win)g(alw)-5
b(a)g(ys)46 b(mak)-5 b(es)45 b(a)f(winning)h(mo)-5 b(v)g(e;)181
6706 y(who)5 b(ev)-5 b(er)56 b(cannot)g(win)f(can)g(pla)-5
b(y)55 b(an)-5 b(ywhere.)p Black Black eop end
%%Page: 10 10
TeXDict begin 10 9 bop Black 181 -165 a Fj(Iv)-5 b(erson)55
b(exam)h(2016)p 1555 -165 4439 6 v 4656 w Fi(10)p Black
347 347 a(\(a\))65 b Fk([3)50 b(marks])65 b Fi(On)g(this)g(3)44
b Ff(\002)g Fi(3)64 b(b)5 b(oard)66 b(white)f(pla)-5
b(y)g(ed)67 b(her)e(\014rst)g(mo)-5 b(v)g(e)66 b(in)e(the)h(middle.)105
b(\(The)181 548 y(letters)48 b(are)f(for)f(the)h(analysis)h(b)5
b(elo)-5 b(w.\))71 b(No)-5 b(w)47 b(it)g(is)g(blac)-5
b(k's)47 b(turn.)71 b(W)-14 b(e)47 b(claim)h(that)f(white)h(can)f(win.)
p Black Black 2463 1956 a @beginspecial 0 @llx 0 @lly
51 @urx 38 @ury 1133 @rwi @setspecial
%%BeginDocument: fz/pix/3x3-marked.eps
%!PS-Adobe-3.0
%%Creator: Jack van Rijswijck, thanks to Cameron Browne
%%BoundingBox: 0 0 51 38
%%Pages: 0
%%EndComments

/OriginX -6 def
/OriginY 27 def
%---------------- Variables -------------------

/DimX 3 def
/DimY 3 def
/Scale 1.2 def


% draw  Hex boards, any size ... but labels only up to 26x26
% based on code by Cameron Browne, revised by Jack vR, revised by RBH
%-------------- state initializations -------------------------
1 setlinejoin   % lines meet at a point  ==>    use round join
%---------------- constants -------------------
/Root3Div2  0.86602540378444 def
/Chars   {[(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)
           (n)(o)(p)(q)(r)(s)(t)(u)(v)(w)(x)(y)(z)]} def
/CharsUC {[(A)(B)(C)(D)(E)(F)(G)(H)(I)(J)(K)(L)(M)
           (N)(O)(P)(Q)(R)(S)(T)(U)(V)(W)(X)(Y)(Z)]} def
/Digits  {[(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)(12)(13)
           (14)(15)(16)(17)(18)(19)(20)(21)(22)(23)(24)(25)(26)]} def
/HexRadius      5 Scale mul def % hexagon center-to-corner distance
/HexLineWidth 0.1 Scale mul def
/GraphVertexSize 1.0 Scale mul def
/GraphLineWidth 0.5 Scale mul def
/CircleRadius 3.0 Scale mul def
/CircleLineWidth 0.346 Scale mul def
/PerimeterWidth 0.5 Scale mul def
/TextHeight 4.5 def
/TextWidth TextHeight 0.45 mul def
/BoardShade 1.0 def
/CoordinatesShade 0.5 def
/MarkerSize 1.2 def
/CellOrientation 1 def   % 1: flat bottom  0: pointed bottom
/CellCorner [ % 6 cell corners, wrt center 0 0, plus "up" and "down"
   [ HexRadius  neg       0                           ]
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul neg ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul neg ]
   [ HexRadius            0                           ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul     ]
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul neg ]
] def
%----- name cell corner indices ... see below
/Left  0 def /DownLeft 1 def /DownRight 2 def
/Right 3 def /UpRight  4 def /UpLeft    5 def
/Up    6 def /Down     7 def
%-----------------------------------------------------
% cell orientations:  flat bottom    flat side
%-----------------------------------------------------
% flat bottom
% board cell indices            cell corner/top/bottom indices
%             --
%           /    \
%        --   1,3  --                  5 -6- 4
%      /    \    /    \               /       \
%   --   1,2  --   2,3  --           0         3
% /    \    /    \    /    \          \       /
%   1,1  --   2,2  --   3,3            1 -7- 2
% \    /    \    /    \    /
%   --   2,1  --   3,2  --
%      \    /    \    /
%        --   3,1  --
%----------------------------------------------------
% flat side
%    /  \  /  \  /  \                       5
%   | 11 || 12 || 13 ||                   /   6
%    \  /  \  /  \  /  \                 0     4
%     || 21 || 22 || 23 |                |     |
%       \  /  \  /  \  /  \              1     3
%        || 31 || 32 || 33 |              7   /
%-------------------------------------------2--------
%----------- procedures -------------
/ScalePoint { % stack: ... x y size ==> ...  x*size y*size
   3 dict begin /size exch def /y exch def /x exch def
   x size mul           y size mul
end } def

/FlatTopBoard { FlatSideCells } def

/FlatSideCells {  % redefine cell orientation for flat side
  /CellOrientation 0 def
  /CellCorner [ % 6 cell corners, wrt center 0 0  %xcoord ycoord
    [HexRadius Root3Div2 mul neg  HexRadius 2 div     ]
    [HexRadius Root3Div2 mul neg  HexRadius 2 div neg ]
    [0                            HexRadius neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div ]
    [0                            HexRadius ]
    [HexRadius Root3Div2 2 div mul HexRadius 0.75 mul ]
    [HexRadius Root3Div2 2 div mul neg HexRadius 0.75 mul neg ]
  ] def
} def

/HexCenterPoint { % center of cell (i,j)
    2 dict begin /j exch def /i exch def
    CellOrientation 1 eq {
    OriginX i j add HexRadius mul 1.5 mul add %Ox + (i+j)*HR*1.5
    OriginY i j sub HexRadius mul Root3Div2 mul sub %Oy - (i-j)*HR*R3/2
    }{
    OriginX i 2 j mul add HexRadius mul Root3Div2 mul add  %Ox + (2i+j)*HR
    OriginY i 1 sub HexRadius mul 1.5 mul sub %Oy - i*HR*R3/2
    } ifelse
end } def

/HexLine { % a b c d
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint lineto
    stroke
} def

/HexCurve { % a b c d e f
    /f exch def
    /e exch def
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint e f HexCenterPoint HexRadius 2 mul arcto
    e f HexCenterPoint lineto
    stroke
} def

/HxgnCorner { 5 dict begin /corn exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    x CellCorner corn get 0 get add
    y CellCorner corn get 1 get add
end } def

/Go { 2 dict begin /corn exch def /mag exch def
   % rlineto in a cell orientation direction
   CellCorner corn get aload pop mag ScalePoint rlineto
end } def

/TurnGo { rotate 1.0 Left Go } def % call: degrees TurnGo
/MagTurnGo { rotate Left Go } def % call: mag degrees TurnGo

/HexagonPath { % call: i j HexagonPath
    newpath
    UpRight HxgnCorner moveto
    6 { 1.0 Left Go 60 rotate } repeat
} def

/FillAndStroke { 2 dict begin /sh exch def /wdth exch def
    gsave sh setgray fill
    grestore 0 setgray wdth setlinewidth stroke
end } def

/ShadedHexagon { 3 dict begin /shade exch def /j exch def /i exch def
    i j HexagonPath
    0 shade FillAndStroke
end } def

/Hexagon { % stack: ... i j
    HexagonPath
    HexLineWidth BoardShade FillAndStroke
} def

/SemiHexagonPath { % stack: ... top i j
    newpath
    1 eq { Left HxgnCorner moveto
        1.0 UpRight Go 1.0 Right Go 1.0 DownRight Go stroke }{
        Right HxgnCorner moveto
        1.0 DownLeft Go 1.0 Left Go 1.0 UpLeft Go stroke
    } ifelse
} def

/HexBoardPerimeter {
    newpath
    1 DimY UpRight HxgnCorner moveto 1.0 Left Go
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 rotate %restore rotation
} def

%----------- Havannah coordinates ----------------------
%                   ..  ..  ..
%                 d1  c2  b3  a4
%                   c1  b2  a3
%                     b1  a2
%                       a1
/HavannahPosn { % convert to usual coordinate, so ... x y  =>  ... 1+DimX-x  y
    exch DimX 1 add exch sub exch
} def

/HavannahBoardPerimeter {
    newpath
    1 DimX UpRight HxgnCorner moveto 1.0 Left Go
    6 {Base 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo } repeat
} def

/DrawHexBoard { 2 dict begin
    gsave
    HexBoardPerimeter
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexPLBoard { 6 dict begin %point-line board
    gsave
    BoardShade setgray newpath
    -1 DimY 1 add 0.5 mul HexCenterPoint moveto
    1 DimY HexCenterPoint lineto
    DimX 1 add 0.5 mul DimY 2 add HexCenterPoint lineto
    DimX DimY HexCenterPoint lineto
    DimX 2 add DimY 1 add 0.5 mul HexCenterPoint lineto
    DimX 1 HexCenterPoint lineto
    DimX 1 add 0.5 mul -1 HexCenterPoint lineto
    1 1 HexCenterPoint lineto
    closepath fill 0 setgray
    1 DimY HexCenterPoint moveto
    1 1 DimX { /i exch def
        i 1 i DimY HexLine
        DimY 1 add 0.5 mul -1 i 1 HexLine
        DimY 1 add 0.5 mul DimY 2 add i DimY HexLine } for
    1 1 DimY { /j exch def
        1 j DimX j HexLine
        -1 DimX 1 add 0.5 mul 1 j HexLine
        DimX 2 add DimX 1 add 0.5 mul DimX j HexLine } for
    /topx 1 def /topy 1 def /btmx 1 def /btmy 1 def
    DimX DimY add 3 sub {
      topx DimX lt {/topx 1 topx add def}{/topy 1 topy add def} ifelse
      btmy DimY lt {/btmy 1 btmy add def}{/btmx 1 btmx add def} ifelse
      topx topy btmx btmy HexLine
      } repeat
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j HexVertex
	} for } for
    grestore
end } def

/DrawHavannahBoard { 3 dict begin
    /Base DimX 1 add 2 idiv  def
    gsave
    HavannahBoardPerimeter
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 Base { /j exch def
	Base j 1 sub sub 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    1 1 Base 1 sub { /j exch def
	1 1 DimX j sub { /i exch def
	   i j Base add 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexBorder{ 6 dict begin /start exch def
    /cells exch def /isBlack exch def /which exch def
    gsave
    which UpLeft eq {1 DimY 1 add start sub Up HxgnCorner moveto /d Left def /r 60 def} if
    which UpRight eq {start DimY Up HxgnCorner moveto /d Right def /r 300 def} if
    which DownLeft eq {DimX 1 add start sub 1 Down HxgnCorner moveto /d Left def /r 300 def} if
    which DownRight eq {DimX start Down HxgnCorner moveto /d Right def /r 60 def} if
    0.5 d Go
    which UpRight eq which DownRight eq or {180 rotate} if
    r TurnGo
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.5 360 r sub MagTurnGo 1.5 360 r sub 2 mul MagTurnGo
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.75 360 r sub MagTurnGo
    closepath isBlack 1 eq {gsave fill grestore} if stroke grestore
end } def

/NoDrawHexBoard {  % dummy, used in creating bounding box
} def

/HexBoardBorders { 1 dict begin
    /upperLeftBlack exch def
    PerimeterWidth setlinewidth 0 setgray
    UpLeft    upperLeftBlack       DimY 1 DrawHexBorder
    UpRight   1 upperLeftBlack sub DimX 1 DrawHexBorder
    DownRight upperLeftBlack       DimY 1 DrawHexBorder
    DownLeft  1 upperLeftBlack sub DimX 1 DrawHexBorder
end } def

/YBoardPerimeter {
    newpath 1 1 DownRight HxgnCorner moveto 180 rotate
    3 { DimX 1 sub { 300 TurnGo 60 TurnGo } repeat
        60 TurnGo 60 TurnGo}
    repeat % now restore initial rotation state
    180 rotate % closepath
} def

/DrawYBoard { 2 dict begin
    YBoardPerimeter
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimX {/j exch def
        1 1 DimX 1 add j sub {/i exch def
	    i j 1 SemiHexagonPath stroke
        } for } for
end } def

/FontSelect { % bold italic FontSelect
    2 dict begin /italic exch def /bold exch def
    bold {
	italic
	{ /Times-BoldItalic findfont TextHeight scalefont setfont }
	{ /Times-Bold findfont TextHeight scalefont setfont }
	ifelse}
        {
	italic {/Times-Italic findfont TextHeight scalefont setfont}
	{ /Times findfont TextHeight scalefont setfont }
	ifelse}
    ifelse
end } def

/LabelString {   % call: i j (str) strlen LabelString
%  to use with board rotation, remove comments
    6 dict begin /strlen exch def /str exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint /y exch def /x exch def
    %BoardRotation rotate
    x y moveto
    %360 BoardRotation sub rotate
    TextWidth strlen mul 0.5 mul neg TextHeight 0.33 mul neg rmoveto
    str show
end } def

/AbsLabelString { 4 dict begin
    /strlen exch def /str exch def /y exch def /x exch def
    newpath
    x AbsCoordX TextWidth strlen mul 0.5 mul sub
    y AbsCoordY TextHeight 0.33 mul sub
    moveto
    str
    show
end } def

/LabelStringVerb { % i j (str) strlen shade bold italic LabelStringVerb
    7 dict begin /italic exch def /bold exch def /shade exch def
    /strlen exch def /str exch def /j exch def /i exch def
    bold italic FontSelect shade setgray
    i j str strlen LabelString
end } def

/HexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimX { /i exch def
	i 0          Chars i 1 sub get 1 LabelString
	i DimY 1 add Chars i 1 sub get 1 LabelString
    } for
    1 1 DimY { /j exch def
	0 j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
	DimX 1 add j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HavannahBoardCoordinates { 3 dict begin
    false true FontSelect CoordinatesShade setgray
    /Base DimX 1 add 2 idiv  def
    1 1 Base { /i exch def
	i 0 HavannahPosn Chars  i 1 sub get 1 LabelString
	0 i HavannahPosn Digits i 1 sub get
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
    1 1 Base 1 sub { /i exch def
	i Base add i HavannahPosn Chars  i Base add 1 sub get 1 LabelString
	i i Base add HavannahPosn Digits i Base add 1 sub get
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/AltHexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimY { /j exch def
	0 j Chars j 1 sub get 1 LabelString
        %DimX 1 add j Chars j 1 sub get 1 LabelString
    } for
    1 1 DimX { /i exch def
	i 0 Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
	%i DimY 1 add Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HexDot { 3 dict begin /size exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint size 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexWhiteMarkedPiece { 2 dict begin /j exch def /i exch def
    i j HexWhitePiece
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexBlackMarkedPiece { 2 dict begin /j exch def /i exch def
    i j HexBlackPiece
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    1 setgray 0 setlinewidth fill
end } def

/HexDoubleMarker { 6 dict begin
    /shaderight exch def /shadeleft exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    gsave
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    shadeleft setgray 0 setlinewidth fill
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    shaderight setgray 0 setlinewidth fill
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    grestore
end } def

/HexBlackWhiteMarker { 0.0 1.0 HexDoubleMarker } def

/HexWhiteBlackMarker { 1.0 0.0 HexDoubleMarker } def

/HexMarker { 2 dict begin /j exch def /i exch def
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setlinewidth fill
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
end } def

/HexBlackMarker { 2 dict begin /j exch def /i exch def
    0 setgray
    i j HexMarker
end } def

/HexWhiteMarker { 2 dict begin /j exch def /i exch def
    1 setgray
    i j HexMarker
end } def

/HexPiece { 3 dict begin /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/HexWhitePiece { 1.0 HexPiece } def

/HexBlackPiece { 0.0 HexPiece } def

/HexWhiteLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def
    % i j HexWhitePiece
    i j str strlen 0.0 true true LabelStringVerb
end } def

/HexBlackLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def
    i j HexBlackPiece
    i j str strlen 1.0 true true LabelStringVerb
end } def

/AbsCoordX { 1 dict begin /x exch def
    OriginX x Scale mul add
end } def

/AbsCoordY { 1 dict begin /y exch def
    OriginY y Scale mul add
end } def

/DrawBox { /maxy exch def /maxx exch def /miny exch def /minx exch def
    newpath
    minx miny moveto
    maxx minx sub 0 rlineto
    0 maxy miny sub rlineto
    minx maxx sub 0 rlineto
    0 miny maxy sub rlineto
    HexLineWidth setlinewidth
    0 setgray
    stroke
} def

/HexVertex { 2 dict begin /j exch def /i exch def
    i j GraphVertexSize HexDot
end } def

/HexLine { 4 dict begin /j2 exch def /i2 exch def /j1 exch def /i1 exch def
    GraphLineWidth setlinewidth
    0 setgray
    newpath
    i1 j1 HexCenterPoint moveto
    i2 j2 HexCenterPoint lineto
    stroke
end } def

%%---------------- Program -------------------


FlatTopBoard
DrawHexBoard
1 HexBoardBorders

2 2 HexWhitePiece
2 1 (x) 1 HexWhiteLabelledPiece
3 1 (x) 1 HexWhiteLabelledPiece
1 3 (y) 1 HexWhiteLabelledPiece
2 3 (y) 1 HexWhiteLabelledPiece


%------------ Trailer --------------

showpage

%%EndDocument
 @endspecial 347 2337 a(White)61 b(can)f(guaran)-5 b(tee)63
b(she)d(gets)g(at)g(least)h(one)f(of)g(the)g(cells)h(lab)5
b(elled)60 b Fe(x)g Fi(b)-5 b(y)61 b(placing)g(a)f(stone)181
2538 y(on)54 b(one)h(of)f(these)h(t)-5 b(w)g(o)55 b(cells)g(if)e(blac)
-5 b(k)55 b(ev)-5 b(er)55 b(places)g(a)f(stone)h(on)g(the)f(other.)74
b(Similarly)-14 b(,)56 b(white)f(can)181 2738 y(guaran)-5
b(tee)60 b(she)e(gets)h(at)f(least)g(one)g(of)g(the)g(cells)g(lab)5
b(elled)59 b Fe(y)6 b Fi(.)82 b(But)58 b(eac)-5 b(h)59
b Fe(x)f Fi(cell)g(touc)-5 b(hes)59 b(the)g(left)181
2939 y(side)k(and)f(the)h(middle,)j(and)c(eac)-5 b(h)64
b Fe(y)k Fi(cell)62 b(touc)-5 b(hes)64 b(the)f(middle)g(and)g(the)g
(righ)-5 b(t)63 b(side.)96 b(So)63 b(white)181 3140 y(will)55
b(join)g(her)g(t)-5 b(w)g(o)56 b(sides)f(if)f(she)h(follo)-5
b(ws)56 b(this)f(strategy)-14 b(.)347 3541 y(No)-5 b(w)58
b(assume)g(that)f(white)h(starts)g(a)f(game)h(b)-5 b(y)57
b(b)-5 b(y)57 b(placing)h(her)g(\014rst)f(stone)h(as)f(sho)-5
b(wn)58 b(b)5 b(elo)-5 b(w.)181 3741 y(It)57 b(is)g(blac)-5
b(k's)59 b(turn.)82 b(Who)58 b(will)g(win)g(the)g(game)g(if)f(b)5
b(oth)58 b(pla)-5 b(y)g(ers)59 b(pla)-5 b(y)58 b(p)5
b(erfectly)58 b(from)g(no)-5 b(w)59 b(on?)181 3942 y(Justify)49
b(y)-5 b(our)51 b(answ)-5 b(er)52 b(b)-5 b(y)50 b(giving)g(the)g
(winning)i(pla)-5 b(y)g(er's)51 b(strategy)g Fh(as)57
b(concisely)f(as)g(p)5 b(ossible)p Fi(.)347 4143 y(\(W)-14
b(e)55 b(ha)-5 b(v)g(e)55 b(included)g(a)f(page)g(with)h(blank)f(3)36
b Ff(\002)f Fi(3)54 b(hex)g(grids)h(on)f(the)g(second)h(last)f(page)h
(of)e(this)181 4343 y(exam.)120 b(Y)-14 b(ou)71 b(can)g(use)g(these)g
(to)f(help)h(describ)5 b(e)71 b(the)g(strategy)-14 b(,)76
b(just)70 b(mak)-5 b(e)71 b(sure)g(that)g(w)-5 b(e)71
b(can)181 4544 y(follo)-5 b(w)56 b(y)-5 b(our)55 b(reasoning.\))222
6644 y @beginspecial 0 @llx 0 @lly 51 @urx 38 @ury 1417
@rwi @setspecial
%%BeginDocument: fz/pix/3strat.eps
%!PS-Adobe-3.0
%%Creator: Jack van Rijswijck, thanks to Cameron Browne
%%BoundingBox: 0 0 51 38
%%Pages: 0
%%EndComments

/OriginX -6 def
/OriginY 27 def
%---------------- Variables -------------------

/DimX 3 def
/DimY 3 def
/Scale 1.2 def


% draw  Hex boards, any size ... but labels only up to 26x26
% based on code by Cameron Browne, revised by Jack vR, revised by RBH
%-------------- state initializations -------------------------
1 setlinejoin   % lines meet at a point  ==>    use round join
%---------------- constants -------------------
/Root3Div2  0.86602540378444 def
/Chars   {[(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)
           (n)(o)(p)(q)(r)(s)(t)(u)(v)(w)(x)(y)(z)]} def
/CharsUC {[(A)(B)(C)(D)(E)(F)(G)(H)(I)(J)(K)(L)(M)
           (N)(O)(P)(Q)(R)(S)(T)(U)(V)(W)(X)(Y)(Z)]} def
/Digits  {[(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)(12)(13)
           (14)(15)(16)(17)(18)(19)(20)(21)(22)(23)(24)(25)(26)]} def
/HexRadius      5 Scale mul def % hexagon center-to-corner distance 
/HexLineWidth 0.1 Scale mul def 
/GraphVertexSize 1.0 Scale mul def
/GraphLineWidth 0.5 Scale mul def
/CircleRadius 3.0 Scale mul def 
/CircleLineWidth 0.346 Scale mul def 
/PerimeterWidth 0.5 Scale mul def 
/TextHeight 4.5 def
/TextWidth TextHeight 0.45 mul def 
/BoardShade 0.8 def
/CoordinatesShade 0.5 def
/MarkerSize 1.2 def
/CellOrientation 1 def   % 1: flat bottom  0: pointed bottom
/CellCorner [ % 6 cell corners, wrt center 0 0, plus "up" and "down"
   [ HexRadius  neg       0                           ] 
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul neg ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul neg ]
   [ HexRadius            0                           ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul     ]
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul neg ]
] def
%----- name cell corner indices ... see below
/Left  0 def /DownLeft 1 def /DownRight 2 def 
/Right 3 def /UpRight  4 def /UpLeft    5 def 
/Up    6 def /Down     7 def
%-----------------------------------------------------
% cell orientations:  flat bottom    flat side
%-----------------------------------------------------
% flat bottom 
% board cell indices            cell corner/top/bottom indices
%             --
%           /    \
%        --   1,3  --                  5 -6- 4
%      /    \    /    \               /       \
%   --   1,2  --   2,3  --           0         3
% /    \    /    \    /    \          \       /
%   1,1  --   2,2  --   3,3            1 -7- 2
% \    /    \    /    \    /
%   --   2,1  --   3,2  --
%      \    /    \    /   
%        --   3,1  --     
%----------------------------------------------------
% flat side 
%    /  \  /  \  /  \                       5
%   | 11 || 12 || 13 ||                   /   6
%    \  /  \  /  \  /  \                 0     4
%     || 21 || 22 || 23 |                |     |
%       \  /  \  /  \  /  \              1     3
%        || 31 || 32 || 33 |              7   /
%-------------------------------------------2--------
%----------- procedures -------------
/ScalePoint { % stack: ... x y size ==> ...  x*size y*size
   3 dict begin /size exch def /y exch def /x exch def
   x size mul           y size mul
end } def

/FlatTopBoard { FlatSideCells } def

/FlatSideCells {  % redefine cell orientation for flat side
  /CellOrientation 0 def   
  /CellCorner [ % 6 cell corners, wrt center 0 0  %xcoord ycoord
    [HexRadius Root3Div2 mul neg  HexRadius 2 div     ]
    [HexRadius Root3Div2 mul neg  HexRadius 2 div neg ]
    [0                            HexRadius neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div ]
    [0                            HexRadius ]
    [HexRadius Root3Div2 2 div mul HexRadius 0.75 mul ]
    [HexRadius Root3Div2 2 div mul neg HexRadius 0.75 mul neg ]
  ] def
} def

/HexCenterPoint { % center of cell (i,j)
    2 dict begin /j exch def /i exch def
    CellOrientation 1 eq {
    OriginX i j add HexRadius mul 1.5 mul add %Ox + (i+j)*HR*1.5
    OriginY i j sub HexRadius mul Root3Div2 mul sub %Oy - (i-j)*HR*R3/2
    }{
    OriginX i 2 j mul add HexRadius mul Root3Div2 mul add  %Ox + (2i+j)*HR
    OriginY i 1 sub HexRadius mul 1.5 mul sub %Oy - i*HR*R3/2
    } ifelse
end } def
 
/HexLine { % a b c d
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint lineto
    stroke
} def

/HexCurve { % a b c d e f
    /f exch def
    /e exch def
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint e f HexCenterPoint HexRadius 2 mul arcto
    e f HexCenterPoint lineto
    stroke
} def

/HxgnCorner { 5 dict begin /corn exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    x CellCorner corn get 0 get add
    y CellCorner corn get 1 get add
end } def

/Go { 2 dict begin /corn exch def /mag exch def
   % rlineto in a cell orientation direction
   CellCorner corn get aload pop mag ScalePoint rlineto
end } def

/TurnGo { rotate 1.0 Left Go } def % call: degrees TurnGo
/MagTurnGo { rotate Left Go } def % call: mag degrees TurnGo

/HexagonPath { % call: i j HexagonPath
    newpath 
    UpRight HxgnCorner moveto 
    6 { 1.0 Left Go 60 rotate } repeat 
} def

/FillAndStroke { 2 dict begin /sh exch def /wdth exch def
    gsave sh setgray fill
    grestore 0 setgray wdth setlinewidth stroke
end } def

/ShadedHexagon { 3 dict begin /shade exch def /j exch def /i exch def
    i j HexagonPath
    0 shade FillAndStroke
end } def

/Hexagon { % stack: ... i j
    HexagonPath 
    HexLineWidth BoardShade FillAndStroke
} def

/SemiHexagonPath { % stack: ... top i j
    newpath 
    1 eq { Left HxgnCorner moveto 
        1.0 UpRight Go 1.0 Right Go 1.0 DownRight Go stroke }{
        Right HxgnCorner moveto 
        1.0 DownLeft Go 1.0 Left Go 1.0 UpLeft Go stroke
    } ifelse
} def

/HexBoardPerimeter {
    newpath
    1 DimY UpRight HxgnCorner moveto 1.0 Left Go                      
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 rotate %restore rotation
} def

%----------- Havannah coordinates ----------------------
%                   ..  ..  ..
%                 d1  c2  b3  a4
%                   c1  b2  a3
%                     b1  a2
%                       a1
/HavannahPosn { % convert to usual coordinate, so ... x y  =>  ... 1+DimX-x  y
    exch DimX 1 add exch sub exch 
} def

/HavannahBoardPerimeter {
    newpath
    1 DimX UpRight HxgnCorner moveto 1.0 Left Go                      
    6 {Base 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo } repeat
} def

/DrawHexBoard { 2 dict begin
    gsave
    HexBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexPLBoard { 6 dict begin %point-line board
    gsave
    BoardShade setgray newpath
    -1 DimY 1 add 0.5 mul HexCenterPoint moveto
    1 DimY HexCenterPoint lineto
    DimX 1 add 0.5 mul DimY 2 add HexCenterPoint lineto
    DimX DimY HexCenterPoint lineto
    DimX 2 add DimY 1 add 0.5 mul HexCenterPoint lineto
    DimX 1 HexCenterPoint lineto
    DimX 1 add 0.5 mul -1 HexCenterPoint lineto
    1 1 HexCenterPoint lineto
    closepath fill 0 setgray
    1 DimY HexCenterPoint moveto
    1 1 DimX { /i exch def 
        i 1 i DimY HexLine 
        DimY 1 add 0.5 mul -1 i 1 HexLine
        DimY 1 add 0.5 mul DimY 2 add i DimY HexLine } for
    1 1 DimY { /j exch def 
        1 j DimX j HexLine 
        -1 DimX 1 add 0.5 mul 1 j HexLine
        DimX 2 add DimX 1 add 0.5 mul DimX j HexLine } for
    /topx 1 def /topy 1 def /btmx 1 def /btmy 1 def
    DimX DimY add 3 sub {
      topx DimX lt {/topx 1 topx add def}{/topy 1 topy add def} ifelse 
      btmy DimY lt {/btmy 1 btmy add def}{/btmx 1 btmx add def} ifelse 
      topx topy btmx btmy HexLine
      } repeat
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j HexVertex
	} for } for
    grestore
end } def

/DrawHavannahBoard { 3 dict begin
    /Base DimX 1 add 2 idiv  def
    gsave
    HavannahBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 Base { /j exch def
	Base j 1 sub sub 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    1 1 Base 1 sub { /j exch def
	1 1 DimX j sub { /i exch def
	   i j Base add 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexBorder{ 6 dict begin /start exch def 
    /cells exch def /isBlack exch def /which exch def
    gsave
    which UpLeft eq {1 DimY 1 add start sub Up HxgnCorner moveto /d Left def /r 60 def} if
    which UpRight eq {start DimY Up HxgnCorner moveto /d Right def /r 300 def} if
    which DownLeft eq {DimX 1 add start sub 1 Down HxgnCorner moveto /d Left def /r 300 def} if
    which DownRight eq {DimX start Down HxgnCorner moveto /d Right def /r 60 def} if
    0.5 d Go 
    which UpRight eq which DownRight eq or {180 rotate} if
    r TurnGo 
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.5 360 r sub MagTurnGo 1.5 360 r sub 2 mul MagTurnGo
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.75 360 r sub MagTurnGo
    closepath isBlack 1 eq {gsave fill grestore} if stroke grestore
end } def

/NoDrawHexBoard {  % dummy, used in creating bounding box
} def

/HexBoardBorders { 1 dict begin
    /upperLeftBlack exch def
    PerimeterWidth setlinewidth 0 setgray
    UpLeft    upperLeftBlack       DimY 1 DrawHexBorder
    UpRight   1 upperLeftBlack sub DimX 1 DrawHexBorder
    DownRight upperLeftBlack       DimY 1 DrawHexBorder
    DownLeft  1 upperLeftBlack sub DimX 1 DrawHexBorder
end } def

/YBoardPerimeter {
    newpath 1 1 DownRight HxgnCorner moveto 180 rotate
    3 { DimX 1 sub { 300 TurnGo 60 TurnGo } repeat 
        60 TurnGo 60 TurnGo} 
    repeat % now restore initial rotation state
    180 rotate % closepath
} def

/DrawYBoard { 2 dict begin
    YBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimX {/j exch def
        1 1 DimX 1 add j sub {/i exch def
	    i j 1 SemiHexagonPath stroke
        } for } for
end } def

/FontSelect { % bold italic FontSelect
    2 dict begin /italic exch def /bold exch def
    bold {
	italic 
	{ /Times-BoldItalic findfont TextHeight scalefont setfont } 
	{ /Times-Bold findfont TextHeight scalefont setfont }
	ifelse} 
        {
	italic {/Times-Italic findfont TextHeight scalefont setfont} 
	{ /Times findfont TextHeight scalefont setfont }
	ifelse}
    ifelse
end } def
	    
/LabelString {   % call: i j (str) strlen LabelString
%  to use with board rotation, remove comments
    6 dict begin /strlen exch def /str exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint /y exch def /x exch def
    %BoardRotation rotate
    x y moveto 
    %360 BoardRotation sub rotate
    TextWidth strlen mul 0.5 mul neg TextHeight 0.33 mul neg rmoveto
    str show 
end } def

/AbsLabelString { 4 dict begin
    /strlen exch def /str exch def /y exch def /x exch def
    newpath
    x AbsCoordX TextWidth strlen mul 0.5 mul sub
    y AbsCoordY TextHeight 0.33 mul sub
    moveto
    str
    show
end } def

/LabelStringVerb { % i j (str) strlen shade bold italic LabelStringVerb
    7 dict begin /italic exch def /bold exch def /shade exch def
    /strlen exch def /str exch def /j exch def /i exch def
    bold italic FontSelect shade setgray
    i j str strlen LabelString
end } def

/HexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimX { /i exch def
	i 0          Chars i 1 sub get 1 LabelString
	i DimY 1 add Chars i 1 sub get 1 LabelString
    } for
    1 1 DimY { /j exch def
	0 j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
	DimX 1 add j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HavannahBoardCoordinates { 3 dict begin
    false true FontSelect CoordinatesShade setgray
    /Base DimX 1 add 2 idiv  def
    1 1 Base { /i exch def
	i 0 HavannahPosn Chars  i 1 sub get 1 LabelString
	0 i HavannahPosn Digits i 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
    1 1 Base 1 sub { /i exch def
	i Base add i HavannahPosn Chars  i Base add 1 sub get 1 LabelString
	i i Base add HavannahPosn Digits i Base add 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/AltHexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimY { /j exch def
	0 j Chars j 1 sub get 1 LabelString
        %DimX 1 add j Chars j 1 sub get 1 LabelString
    } for
    1 1 DimX { /i exch def
	i 0 Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
	%i DimY 1 add Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HexDot { 3 dict begin /size exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint size 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexWhiteMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexWhitePiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexBlackMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexBlackPiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    1 setgray 0 setlinewidth fill
end } def

/HexDoubleMarker { 6 dict begin
    /shaderight exch def /shadeleft exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    gsave
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    shadeleft setgray 0 setlinewidth fill
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    shaderight setgray 0 setlinewidth fill
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    grestore
end } def

/HexBlackWhiteMarker { 0.0 1.0 HexDoubleMarker } def

/HexWhiteBlackMarker { 1.0 0.0 HexDoubleMarker } def
        
/HexMarker { 2 dict begin /j exch def /i exch def
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setlinewidth fill
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke  
end } def

/HexBlackMarker { 2 dict begin /j exch def /i exch def
    0 setgray
    i j HexMarker
end } def

/HexWhiteMarker { 2 dict begin /j exch def /i exch def
    1 setgray
    i j HexMarker
end } def
    
/HexPiece { 3 dict begin /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/MagicStone { 4 dict begin 
    /size exch def /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 1.3 mul size mul 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/HexWhitePiece { 1.0 HexPiece } def

/HexBlackPiece { 0.0 HexPiece } def

/HexWhiteLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def
    i j HexWhitePiece
    i j str strlen 0.0 true true LabelStringVerb
end } def

/HexBlackLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def 
    i j HexBlackPiece
    i j str strlen 1.0 true true LabelStringVerb
end } def

/AbsCoordX { 1 dict begin /x exch def
    OriginX x Scale mul add
end } def

/AbsCoordY { 1 dict begin /y exch def
    OriginY y Scale mul add
end } def

/DrawBox { /maxy exch def /maxx exch def /miny exch def /minx exch def
    newpath
    minx miny moveto
    maxx minx sub 0 rlineto
    0 maxy miny sub rlineto
    minx maxx sub 0 rlineto
    0 miny maxy sub rlineto
    HexLineWidth setlinewidth
    0 setgray
    stroke
} def

/HexVertex { 2 dict begin /j exch def /i exch def
    i j GraphVertexSize HexDot
end } def

/HexLine { 4 dict begin /j2 exch def /i2 exch def /j1 exch def /i1 exch def
    GraphLineWidth setlinewidth
    0 setgray
    newpath
    i1 j1 HexCenterPoint moveto
    i2 j2 HexCenterPoint lineto
    stroke
end } def

%%---------------- Program -------------------


FlatTopBoard
DrawHexBoard
1 HexBoardBorders
AltHexBoardCoordinates

1 3 HexWhitePiece


%------------ Trailer --------------

showpage

%%EndDocument
 @endspecial 2064 w @beginspecial 0 @llx 0 @lly 51 @urx
38 @ury 1417 @rwi @setspecial
%%BeginDocument: fz/pix/3strat0.eps
%!PS-Adobe-3.0
%%Creator: Jack van Rijswijck, thanks to Cameron Browne
%%BoundingBox: 0 0 51 38
%%Pages: 0
%%EndComments

/OriginX -6 def
/OriginY 27 def
%---------------- Variables -------------------

/DimX 3 def
/DimY 3 def
/Scale 1.2 def


% draw  Hex boards, any size ... but labels only up to 26x26
% based on code by Cameron Browne, revised by Jack vR, revised by RBH
%-------------- state initializations -------------------------
1 setlinejoin   % lines meet at a point  ==>    use round join
%---------------- constants -------------------
/Root3Div2  0.86602540378444 def
/Chars   {[(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)
           (n)(o)(p)(q)(r)(s)(t)(u)(v)(w)(x)(y)(z)]} def
/CharsUC {[(A)(B)(C)(D)(E)(F)(G)(H)(I)(J)(K)(L)(M)
           (N)(O)(P)(Q)(R)(S)(T)(U)(V)(W)(X)(Y)(Z)]} def
/Digits  {[(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)(12)(13)
           (14)(15)(16)(17)(18)(19)(20)(21)(22)(23)(24)(25)(26)]} def
/HexRadius      5 Scale mul def % hexagon center-to-corner distance 
/HexLineWidth 0.1 Scale mul def 
/GraphVertexSize 1.0 Scale mul def
/GraphLineWidth 0.5 Scale mul def
/CircleRadius 3.0 Scale mul def 
/CircleLineWidth 0.346 Scale mul def 
/PerimeterWidth 0.5 Scale mul def 
/TextHeight 4.5 def
/TextWidth TextHeight 0.45 mul def 
/BoardShade 0.8 def
/CoordinatesShade 0.5 def
/MarkerSize 1.2 def
/CellOrientation 1 def   % 1: flat bottom  0: pointed bottom
/CellCorner [ % 6 cell corners, wrt center 0 0, plus "up" and "down"
   [ HexRadius  neg       0                           ] 
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul neg ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul neg ]
   [ HexRadius            0                           ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul     ]
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul neg ]
] def
%----- name cell corner indices ... see below
/Left  0 def /DownLeft 1 def /DownRight 2 def 
/Right 3 def /UpRight  4 def /UpLeft    5 def 
/Up    6 def /Down     7 def
%-----------------------------------------------------
% cell orientations:  flat bottom    flat side
%-----------------------------------------------------
% flat bottom 
% board cell indices            cell corner/top/bottom indices
%             --
%           /    \
%        --   1,3  --                  5 -6- 4
%      /    \    /    \               /       \
%   --   1,2  --   2,3  --           0         3
% /    \    /    \    /    \          \       /
%   1,1  --   2,2  --   3,3            1 -7- 2
% \    /    \    /    \    /
%   --   2,1  --   3,2  --
%      \    /    \    /   
%        --   3,1  --     
%----------------------------------------------------
% flat side 
%    /  \  /  \  /  \                       5
%   | 11 || 12 || 13 ||                   /   6
%    \  /  \  /  \  /  \                 0     4
%     || 21 || 22 || 23 |                |     |
%       \  /  \  /  \  /  \              1     3
%        || 31 || 32 || 33 |              7   /
%-------------------------------------------2--------
%----------- procedures -------------
/ScalePoint { % stack: ... x y size ==> ...  x*size y*size
   3 dict begin /size exch def /y exch def /x exch def
   x size mul           y size mul
end } def

/FlatTopBoard { FlatSideCells } def

/FlatSideCells {  % redefine cell orientation for flat side
  /CellOrientation 0 def   
  /CellCorner [ % 6 cell corners, wrt center 0 0  %xcoord ycoord
    [HexRadius Root3Div2 mul neg  HexRadius 2 div     ]
    [HexRadius Root3Div2 mul neg  HexRadius 2 div neg ]
    [0                            HexRadius neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div ]
    [0                            HexRadius ]
    [HexRadius Root3Div2 2 div mul HexRadius 0.75 mul ]
    [HexRadius Root3Div2 2 div mul neg HexRadius 0.75 mul neg ]
  ] def
} def

/HexCenterPoint { % center of cell (i,j)
    2 dict begin /j exch def /i exch def
    CellOrientation 1 eq {
    OriginX i j add HexRadius mul 1.5 mul add %Ox + (i+j)*HR*1.5
    OriginY i j sub HexRadius mul Root3Div2 mul sub %Oy - (i-j)*HR*R3/2
    }{
    OriginX i 2 j mul add HexRadius mul Root3Div2 mul add  %Ox + (2i+j)*HR
    OriginY i 1 sub HexRadius mul 1.5 mul sub %Oy - i*HR*R3/2
    } ifelse
end } def
 
/HexLine { % a b c d
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint lineto
    stroke
} def

/HexCurve { % a b c d e f
    /f exch def
    /e exch def
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint e f HexCenterPoint HexRadius 2 mul arcto
    e f HexCenterPoint lineto
    stroke
} def

/HxgnCorner { 5 dict begin /corn exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    x CellCorner corn get 0 get add
    y CellCorner corn get 1 get add
end } def

/Go { 2 dict begin /corn exch def /mag exch def
   % rlineto in a cell orientation direction
   CellCorner corn get aload pop mag ScalePoint rlineto
end } def

/TurnGo { rotate 1.0 Left Go } def % call: degrees TurnGo
/MagTurnGo { rotate Left Go } def % call: mag degrees TurnGo

/HexagonPath { % call: i j HexagonPath
    newpath 
    UpRight HxgnCorner moveto 
    6 { 1.0 Left Go 60 rotate } repeat 
} def

/FillAndStroke { 2 dict begin /sh exch def /wdth exch def
    gsave sh setgray fill
    grestore 0 setgray wdth setlinewidth stroke
end } def

/ShadedHexagon { 3 dict begin /shade exch def /j exch def /i exch def
    i j HexagonPath
    0 shade FillAndStroke
end } def

/Hexagon { % stack: ... i j
    HexagonPath 
    HexLineWidth BoardShade FillAndStroke
} def

/SemiHexagonPath { % stack: ... top i j
    newpath 
    1 eq { Left HxgnCorner moveto 
        1.0 UpRight Go 1.0 Right Go 1.0 DownRight Go stroke }{
        Right HxgnCorner moveto 
        1.0 DownLeft Go 1.0 Left Go 1.0 UpLeft Go stroke
    } ifelse
} def

/HexBoardPerimeter {
    newpath
    1 DimY UpRight HxgnCorner moveto 1.0 Left Go                      
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 rotate %restore rotation
} def

%----------- Havannah coordinates ----------------------
%                   ..  ..  ..
%                 d1  c2  b3  a4
%                   c1  b2  a3
%                     b1  a2
%                       a1
/HavannahPosn { % convert to usual coordinate, so ... x y  =>  ... 1+DimX-x  y
    exch DimX 1 add exch sub exch 
} def

/HavannahBoardPerimeter {
    newpath
    1 DimX UpRight HxgnCorner moveto 1.0 Left Go                      
    6 {Base 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo } repeat
} def

/DrawHexBoard { 2 dict begin
    gsave
    HexBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexPLBoard { 6 dict begin %point-line board
    gsave
    BoardShade setgray newpath
    -1 DimY 1 add 0.5 mul HexCenterPoint moveto
    1 DimY HexCenterPoint lineto
    DimX 1 add 0.5 mul DimY 2 add HexCenterPoint lineto
    DimX DimY HexCenterPoint lineto
    DimX 2 add DimY 1 add 0.5 mul HexCenterPoint lineto
    DimX 1 HexCenterPoint lineto
    DimX 1 add 0.5 mul -1 HexCenterPoint lineto
    1 1 HexCenterPoint lineto
    closepath fill 0 setgray
    1 DimY HexCenterPoint moveto
    1 1 DimX { /i exch def 
        i 1 i DimY HexLine 
        DimY 1 add 0.5 mul -1 i 1 HexLine
        DimY 1 add 0.5 mul DimY 2 add i DimY HexLine } for
    1 1 DimY { /j exch def 
        1 j DimX j HexLine 
        -1 DimX 1 add 0.5 mul 1 j HexLine
        DimX 2 add DimX 1 add 0.5 mul DimX j HexLine } for
    /topx 1 def /topy 1 def /btmx 1 def /btmy 1 def
    DimX DimY add 3 sub {
      topx DimX lt {/topx 1 topx add def}{/topy 1 topy add def} ifelse 
      btmy DimY lt {/btmy 1 btmy add def}{/btmx 1 btmx add def} ifelse 
      topx topy btmx btmy HexLine
      } repeat
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j HexVertex
	} for } for
    grestore
end } def

/DrawHavannahBoard { 3 dict begin
    /Base DimX 1 add 2 idiv  def
    gsave
    HavannahBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 Base { /j exch def
	Base j 1 sub sub 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    1 1 Base 1 sub { /j exch def
	1 1 DimX j sub { /i exch def
	   i j Base add 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexBorder{ 6 dict begin /start exch def 
    /cells exch def /isBlack exch def /which exch def
    gsave
    which UpLeft eq {1 DimY 1 add start sub Up HxgnCorner moveto /d Left def /r 60 def} if
    which UpRight eq {start DimY Up HxgnCorner moveto /d Right def /r 300 def} if
    which DownLeft eq {DimX 1 add start sub 1 Down HxgnCorner moveto /d Left def /r 300 def} if
    which DownRight eq {DimX start Down HxgnCorner moveto /d Right def /r 60 def} if
    0.5 d Go 
    which UpRight eq which DownRight eq or {180 rotate} if
    r TurnGo 
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.5 360 r sub MagTurnGo 1.5 360 r sub 2 mul MagTurnGo
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.75 360 r sub MagTurnGo
    closepath isBlack 1 eq {gsave fill grestore} if stroke grestore
end } def

/NoDrawHexBoard {  % dummy, used in creating bounding box
} def

/HexBoardBorders { 1 dict begin
    /upperLeftBlack exch def
    PerimeterWidth setlinewidth 0 setgray
    UpLeft    upperLeftBlack       DimY 1 DrawHexBorder
    UpRight   1 upperLeftBlack sub DimX 1 DrawHexBorder
    DownRight upperLeftBlack       DimY 1 DrawHexBorder
    DownLeft  1 upperLeftBlack sub DimX 1 DrawHexBorder
end } def

/YBoardPerimeter {
    newpath 1 1 DownRight HxgnCorner moveto 180 rotate
    3 { DimX 1 sub { 300 TurnGo 60 TurnGo } repeat 
        60 TurnGo 60 TurnGo} 
    repeat % now restore initial rotation state
    180 rotate % closepath
} def

/DrawYBoard { 2 dict begin
    YBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimX {/j exch def
        1 1 DimX 1 add j sub {/i exch def
	    i j 1 SemiHexagonPath stroke
        } for } for
end } def

/FontSelect { % bold italic FontSelect
    2 dict begin /italic exch def /bold exch def
    bold {
	italic 
	{ /Times-BoldItalic findfont TextHeight scalefont setfont } 
	{ /Times-Bold findfont TextHeight scalefont setfont }
	ifelse} 
        {
	italic {/Times-Italic findfont TextHeight scalefont setfont} 
	{ /Times findfont TextHeight scalefont setfont }
	ifelse}
    ifelse
end } def
	    
/LabelString {   % call: i j (str) strlen LabelString
%  to use with board rotation, remove comments
    6 dict begin /strlen exch def /str exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint /y exch def /x exch def
    %BoardRotation rotate
    x y moveto 
    %360 BoardRotation sub rotate
    TextWidth strlen mul 0.5 mul neg TextHeight 0.33 mul neg rmoveto
    str show 
end } def

/AbsLabelString { 4 dict begin
    /strlen exch def /str exch def /y exch def /x exch def
    newpath
    x AbsCoordX TextWidth strlen mul 0.5 mul sub
    y AbsCoordY TextHeight 0.33 mul sub
    moveto
    str
    show
end } def

/LabelStringVerb { % i j (str) strlen shade bold italic LabelStringVerb
    7 dict begin /italic exch def /bold exch def /shade exch def
    /strlen exch def /str exch def /j exch def /i exch def
    bold italic FontSelect shade setgray
    i j str strlen LabelString
end } def

/HexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimX { /i exch def
	i 0          Chars i 1 sub get 1 LabelString
	i DimY 1 add Chars i 1 sub get 1 LabelString
    } for
    1 1 DimY { /j exch def
	0 j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
	DimX 1 add j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HavannahBoardCoordinates { 3 dict begin
    false true FontSelect CoordinatesShade setgray
    /Base DimX 1 add 2 idiv  def
    1 1 Base { /i exch def
	i 0 HavannahPosn Chars  i 1 sub get 1 LabelString
	0 i HavannahPosn Digits i 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
    1 1 Base 1 sub { /i exch def
	i Base add i HavannahPosn Chars  i Base add 1 sub get 1 LabelString
	i i Base add HavannahPosn Digits i Base add 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/AltHexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimY { /j exch def
	0 j Chars j 1 sub get 1 LabelString
        %DimX 1 add j Chars j 1 sub get 1 LabelString
    } for
    1 1 DimX { /i exch def
	i 0 Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
	%i DimY 1 add Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HexDot { 3 dict begin /size exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint size 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexWhiteMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexWhitePiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexBlackMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexBlackPiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    1 setgray 0 setlinewidth fill
end } def

/HexDoubleMarker { 6 dict begin
    /shaderight exch def /shadeleft exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    gsave
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    shadeleft setgray 0 setlinewidth fill
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    shaderight setgray 0 setlinewidth fill
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    grestore
end } def

/HexBlackWhiteMarker { 0.0 1.0 HexDoubleMarker } def

/HexWhiteBlackMarker { 1.0 0.0 HexDoubleMarker } def
        
/HexMarker { 2 dict begin /j exch def /i exch def
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setlinewidth fill
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke  
end } def

/HexBlackMarker { 2 dict begin /j exch def /i exch def
    0 setgray
    i j HexMarker
end } def

/HexWhiteMarker { 2 dict begin /j exch def /i exch def
    1 setgray
    i j HexMarker
end } def
    
/HexPiece { 3 dict begin /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/MagicStone { 4 dict begin 
    /size exch def /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 1.3 mul size mul 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/HexWhitePiece { 1.0 HexPiece } def

/HexBlackPiece { 0.0 HexPiece } def

/HexWhiteLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def
    i j HexWhitePiece
    i j str strlen 0.0 true true LabelStringVerb
end } def

/HexBlackLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def 
    i j HexBlackPiece
    i j str strlen 1.0 true true LabelStringVerb
end } def

/AbsCoordX { 1 dict begin /x exch def
    OriginX x Scale mul add
end } def

/AbsCoordY { 1 dict begin /y exch def
    OriginY y Scale mul add
end } def

/DrawBox { /maxy exch def /maxx exch def /miny exch def /minx exch def
    newpath
    minx miny moveto
    maxx minx sub 0 rlineto
    0 maxy miny sub rlineto
    minx maxx sub 0 rlineto
    0 miny maxy sub rlineto
    HexLineWidth setlinewidth
    0 setgray
    stroke
} def

/HexVertex { 2 dict begin /j exch def /i exch def
    i j GraphVertexSize HexDot
end } def

/HexLine { 4 dict begin /j2 exch def /i2 exch def /j1 exch def /i1 exch def
    GraphLineWidth setlinewidth
    0 setgray
    newpath
    i1 j1 HexCenterPoint moveto
    i2 j2 HexCenterPoint lineto
    stroke
end } def

%%---------------- Program -------------------


FlatTopBoard
DrawHexBoard
1 HexBoardBorders
AltHexBoardCoordinates

1 3 HexWhitePiece
2 2 HexWhiteMarker
1 2 HexWhiteMarker
2 0 1 1 1 2 HexCurve
2 0 2 1 1 2 HexCurve
3 0 2 1 2 2 HexCurve
3 0 3 1 2 2 HexCurve


%------------ Trailer --------------

showpage

%%EndDocument
 @endspecial 2064 w @beginspecial 0 @llx 0 @lly 51 @urx
38 @ury 1417 @rwi @setspecial
%%BeginDocument: fz/pix/3strat1.eps
%!PS-Adobe-3.0
%%Creator: Jack van Rijswijck, thanks to Cameron Browne
%%BoundingBox: 0 0 51 38
%%Pages: 0
%%EndComments

/OriginX -6 def
/OriginY 27 def
%---------------- Variables -------------------

/DimX 3 def
/DimY 3 def
/Scale 1.2 def


% draw  Hex boards, any size ... but labels only up to 26x26
% based on code by Cameron Browne, revised by Jack vR, revised by RBH
%-------------- state initializations -------------------------
1 setlinejoin   % lines meet at a point  ==>    use round join
%---------------- constants -------------------
/Root3Div2  0.86602540378444 def
/Chars   {[(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)
           (n)(o)(p)(q)(r)(s)(t)(u)(v)(w)(x)(y)(z)]} def
/CharsUC {[(A)(B)(C)(D)(E)(F)(G)(H)(I)(J)(K)(L)(M)
           (N)(O)(P)(Q)(R)(S)(T)(U)(V)(W)(X)(Y)(Z)]} def
/Digits  {[(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)(12)(13)
           (14)(15)(16)(17)(18)(19)(20)(21)(22)(23)(24)(25)(26)]} def
/HexRadius      5 Scale mul def % hexagon center-to-corner distance 
/HexLineWidth 0.1 Scale mul def 
/GraphVertexSize 1.0 Scale mul def
/GraphLineWidth 0.5 Scale mul def
/CircleRadius 3.0 Scale mul def 
/CircleLineWidth 0.346 Scale mul def 
/PerimeterWidth 0.5 Scale mul def 
/TextHeight 4.5 def
/TextWidth TextHeight 0.45 mul def 
/BoardShade 0.8 def
/CoordinatesShade 0.5 def
/MarkerSize 1.2 def
/CellOrientation 1 def   % 1: flat bottom  0: pointed bottom
/CellCorner [ % 6 cell corners, wrt center 0 0, plus "up" and "down"
   [ HexRadius  neg       0                           ] 
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul neg ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul neg ]
   [ HexRadius            0                           ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul     ]
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul neg ]
] def
%----- name cell corner indices ... see below
/Left  0 def /DownLeft 1 def /DownRight 2 def 
/Right 3 def /UpRight  4 def /UpLeft    5 def 
/Up    6 def /Down     7 def
%-----------------------------------------------------
% cell orientations:  flat bottom    flat side
%-----------------------------------------------------
% flat bottom 
% board cell indices            cell corner/top/bottom indices
%             --
%           /    \
%        --   1,3  --                  5 -6- 4
%      /    \    /    \               /       \
%   --   1,2  --   2,3  --           0         3
% /    \    /    \    /    \          \       /
%   1,1  --   2,2  --   3,3            1 -7- 2
% \    /    \    /    \    /
%   --   2,1  --   3,2  --
%      \    /    \    /   
%        --   3,1  --     
%----------------------------------------------------
% flat side 
%    /  \  /  \  /  \                       5
%   | 11 || 12 || 13 ||                   /   6
%    \  /  \  /  \  /  \                 0     4
%     || 21 || 22 || 23 |                |     |
%       \  /  \  /  \  /  \              1     3
%        || 31 || 32 || 33 |              7   /
%-------------------------------------------2--------
%----------- procedures -------------
/ScalePoint { % stack: ... x y size ==> ...  x*size y*size
   3 dict begin /size exch def /y exch def /x exch def
   x size mul           y size mul
end } def

/FlatTopBoard { FlatSideCells } def

/FlatSideCells {  % redefine cell orientation for flat side
  /CellOrientation 0 def   
  /CellCorner [ % 6 cell corners, wrt center 0 0  %xcoord ycoord
    [HexRadius Root3Div2 mul neg  HexRadius 2 div     ]
    [HexRadius Root3Div2 mul neg  HexRadius 2 div neg ]
    [0                            HexRadius neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div ]
    [0                            HexRadius ]
    [HexRadius Root3Div2 2 div mul HexRadius 0.75 mul ]
    [HexRadius Root3Div2 2 div mul neg HexRadius 0.75 mul neg ]
  ] def
} def

/HexCenterPoint { % center of cell (i,j)
    2 dict begin /j exch def /i exch def
    CellOrientation 1 eq {
    OriginX i j add HexRadius mul 1.5 mul add %Ox + (i+j)*HR*1.5
    OriginY i j sub HexRadius mul Root3Div2 mul sub %Oy - (i-j)*HR*R3/2
    }{
    OriginX i 2 j mul add HexRadius mul Root3Div2 mul add  %Ox + (2i+j)*HR
    OriginY i 1 sub HexRadius mul 1.5 mul sub %Oy - i*HR*R3/2
    } ifelse
end } def
 
/HexLine { % a b c d
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint lineto
    stroke
} def

/HexCurve { % a b c d e f
    /f exch def
    /e exch def
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint e f HexCenterPoint HexRadius 2 mul arcto
    e f HexCenterPoint lineto
    stroke
} def

/HxgnCorner { 5 dict begin /corn exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    x CellCorner corn get 0 get add
    y CellCorner corn get 1 get add
end } def

/Go { 2 dict begin /corn exch def /mag exch def
   % rlineto in a cell orientation direction
   CellCorner corn get aload pop mag ScalePoint rlineto
end } def

/TurnGo { rotate 1.0 Left Go } def % call: degrees TurnGo
/MagTurnGo { rotate Left Go } def % call: mag degrees TurnGo

/HexagonPath { % call: i j HexagonPath
    newpath 
    UpRight HxgnCorner moveto 
    6 { 1.0 Left Go 60 rotate } repeat 
} def

/FillAndStroke { 2 dict begin /sh exch def /wdth exch def
    gsave sh setgray fill
    grestore 0 setgray wdth setlinewidth stroke
end } def

/ShadedHexagon { 3 dict begin /shade exch def /j exch def /i exch def
    i j HexagonPath
    0 shade FillAndStroke
end } def

/Hexagon { % stack: ... i j
    HexagonPath 
    HexLineWidth BoardShade FillAndStroke
} def

/SemiHexagonPath { % stack: ... top i j
    newpath 
    1 eq { Left HxgnCorner moveto 
        1.0 UpRight Go 1.0 Right Go 1.0 DownRight Go stroke }{
        Right HxgnCorner moveto 
        1.0 DownLeft Go 1.0 Left Go 1.0 UpLeft Go stroke
    } ifelse
} def

/HexBoardPerimeter {
    newpath
    1 DimY UpRight HxgnCorner moveto 1.0 Left Go                      
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 rotate %restore rotation
} def

%----------- Havannah coordinates ----------------------
%                   ..  ..  ..
%                 d1  c2  b3  a4
%                   c1  b2  a3
%                     b1  a2
%                       a1
/HavannahPosn { % convert to usual coordinate, so ... x y  =>  ... 1+DimX-x  y
    exch DimX 1 add exch sub exch 
} def

/HavannahBoardPerimeter {
    newpath
    1 DimX UpRight HxgnCorner moveto 1.0 Left Go                      
    6 {Base 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo } repeat
} def

/DrawHexBoard { 2 dict begin
    gsave
    HexBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexPLBoard { 6 dict begin %point-line board
    gsave
    BoardShade setgray newpath
    -1 DimY 1 add 0.5 mul HexCenterPoint moveto
    1 DimY HexCenterPoint lineto
    DimX 1 add 0.5 mul DimY 2 add HexCenterPoint lineto
    DimX DimY HexCenterPoint lineto
    DimX 2 add DimY 1 add 0.5 mul HexCenterPoint lineto
    DimX 1 HexCenterPoint lineto
    DimX 1 add 0.5 mul -1 HexCenterPoint lineto
    1 1 HexCenterPoint lineto
    closepath fill 0 setgray
    1 DimY HexCenterPoint moveto
    1 1 DimX { /i exch def 
        i 1 i DimY HexLine 
        DimY 1 add 0.5 mul -1 i 1 HexLine
        DimY 1 add 0.5 mul DimY 2 add i DimY HexLine } for
    1 1 DimY { /j exch def 
        1 j DimX j HexLine 
        -1 DimX 1 add 0.5 mul 1 j HexLine
        DimX 2 add DimX 1 add 0.5 mul DimX j HexLine } for
    /topx 1 def /topy 1 def /btmx 1 def /btmy 1 def
    DimX DimY add 3 sub {
      topx DimX lt {/topx 1 topx add def}{/topy 1 topy add def} ifelse 
      btmy DimY lt {/btmy 1 btmy add def}{/btmx 1 btmx add def} ifelse 
      topx topy btmx btmy HexLine
      } repeat
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j HexVertex
	} for } for
    grestore
end } def

/DrawHavannahBoard { 3 dict begin
    /Base DimX 1 add 2 idiv  def
    gsave
    HavannahBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 Base { /j exch def
	Base j 1 sub sub 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    1 1 Base 1 sub { /j exch def
	1 1 DimX j sub { /i exch def
	   i j Base add 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexBorder{ 6 dict begin /start exch def 
    /cells exch def /isBlack exch def /which exch def
    gsave
    which UpLeft eq {1 DimY 1 add start sub Up HxgnCorner moveto /d Left def /r 60 def} if
    which UpRight eq {start DimY Up HxgnCorner moveto /d Right def /r 300 def} if
    which DownLeft eq {DimX 1 add start sub 1 Down HxgnCorner moveto /d Left def /r 300 def} if
    which DownRight eq {DimX start Down HxgnCorner moveto /d Right def /r 60 def} if
    0.5 d Go 
    which UpRight eq which DownRight eq or {180 rotate} if
    r TurnGo 
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.5 360 r sub MagTurnGo 1.5 360 r sub 2 mul MagTurnGo
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.75 360 r sub MagTurnGo
    closepath isBlack 1 eq {gsave fill grestore} if stroke grestore
end } def

/NoDrawHexBoard {  % dummy, used in creating bounding box
} def

/HexBoardBorders { 1 dict begin
    /upperLeftBlack exch def
    PerimeterWidth setlinewidth 0 setgray
    UpLeft    upperLeftBlack       DimY 1 DrawHexBorder
    UpRight   1 upperLeftBlack sub DimX 1 DrawHexBorder
    DownRight upperLeftBlack       DimY 1 DrawHexBorder
    DownLeft  1 upperLeftBlack sub DimX 1 DrawHexBorder
end } def

/YBoardPerimeter {
    newpath 1 1 DownRight HxgnCorner moveto 180 rotate
    3 { DimX 1 sub { 300 TurnGo 60 TurnGo } repeat 
        60 TurnGo 60 TurnGo} 
    repeat % now restore initial rotation state
    180 rotate % closepath
} def

/DrawYBoard { 2 dict begin
    YBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimX {/j exch def
        1 1 DimX 1 add j sub {/i exch def
	    i j 1 SemiHexagonPath stroke
        } for } for
end } def

/FontSelect { % bold italic FontSelect
    2 dict begin /italic exch def /bold exch def
    bold {
	italic 
	{ /Times-BoldItalic findfont TextHeight scalefont setfont } 
	{ /Times-Bold findfont TextHeight scalefont setfont }
	ifelse} 
        {
	italic {/Times-Italic findfont TextHeight scalefont setfont} 
	{ /Times findfont TextHeight scalefont setfont }
	ifelse}
    ifelse
end } def
	    
/LabelString {   % call: i j (str) strlen LabelString
%  to use with board rotation, remove comments
    6 dict begin /strlen exch def /str exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint /y exch def /x exch def
    %BoardRotation rotate
    x y moveto 
    %360 BoardRotation sub rotate
    TextWidth strlen mul 0.5 mul neg TextHeight 0.33 mul neg rmoveto
    str show 
end } def

/AbsLabelString { 4 dict begin
    /strlen exch def /str exch def /y exch def /x exch def
    newpath
    x AbsCoordX TextWidth strlen mul 0.5 mul sub
    y AbsCoordY TextHeight 0.33 mul sub
    moveto
    str
    show
end } def

/LabelStringVerb { % i j (str) strlen shade bold italic LabelStringVerb
    7 dict begin /italic exch def /bold exch def /shade exch def
    /strlen exch def /str exch def /j exch def /i exch def
    bold italic FontSelect shade setgray
    i j str strlen LabelString
end } def

/HexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimX { /i exch def
	i 0          Chars i 1 sub get 1 LabelString
	i DimY 1 add Chars i 1 sub get 1 LabelString
    } for
    1 1 DimY { /j exch def
	0 j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
	DimX 1 add j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HavannahBoardCoordinates { 3 dict begin
    false true FontSelect CoordinatesShade setgray
    /Base DimX 1 add 2 idiv  def
    1 1 Base { /i exch def
	i 0 HavannahPosn Chars  i 1 sub get 1 LabelString
	0 i HavannahPosn Digits i 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
    1 1 Base 1 sub { /i exch def
	i Base add i HavannahPosn Chars  i Base add 1 sub get 1 LabelString
	i i Base add HavannahPosn Digits i Base add 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/AltHexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimY { /j exch def
	0 j Chars j 1 sub get 1 LabelString
        %DimX 1 add j Chars j 1 sub get 1 LabelString
    } for
    1 1 DimX { /i exch def
	i 0 Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
	%i DimY 1 add Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HexDot { 3 dict begin /size exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint size 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexWhiteMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexWhitePiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexBlackMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexBlackPiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    1 setgray 0 setlinewidth fill
end } def

/HexDoubleMarker { 6 dict begin
    /shaderight exch def /shadeleft exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    gsave
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    shadeleft setgray 0 setlinewidth fill
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    shaderight setgray 0 setlinewidth fill
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    grestore
end } def

/HexBlackWhiteMarker { 0.0 1.0 HexDoubleMarker } def

/HexWhiteBlackMarker { 1.0 0.0 HexDoubleMarker } def
        
/HexMarker { 2 dict begin /j exch def /i exch def
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setlinewidth fill
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke  
end } def

/HexBlackMarker { 2 dict begin /j exch def /i exch def
    0 setgray
    i j HexMarker
end } def

/HexWhiteMarker { 2 dict begin /j exch def /i exch def
    1 setgray
    i j HexMarker
end } def
    
/HexPiece { 3 dict begin /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/MagicStone { 4 dict begin 
    /size exch def /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 1.3 mul size mul 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/HexWhitePiece { 1.0 HexPiece } def

/HexBlackPiece { 0.0 HexPiece } def

/HexWhiteLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def
    i j HexWhitePiece
    i j str strlen 0.0 true true LabelStringVerb
end } def

/HexBlackLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def 
    i j HexBlackPiece
    i j str strlen 1.0 true true LabelStringVerb
end } def

/AbsCoordX { 1 dict begin /x exch def
    OriginX x Scale mul add
end } def

/AbsCoordY { 1 dict begin /y exch def
    OriginY y Scale mul add
end } def

/DrawBox { /maxy exch def /maxx exch def /miny exch def /minx exch def
    newpath
    minx miny moveto
    maxx minx sub 0 rlineto
    0 maxy miny sub rlineto
    minx maxx sub 0 rlineto
    0 miny maxy sub rlineto
    HexLineWidth setlinewidth
    0 setgray
    stroke
} def

/HexVertex { 2 dict begin /j exch def /i exch def
    i j GraphVertexSize HexDot
end } def

/HexLine { 4 dict begin /j2 exch def /i2 exch def /j1 exch def /i1 exch def
    GraphLineWidth setlinewidth
    0 setgray
    newpath
    i1 j1 HexCenterPoint moveto
    i2 j2 HexCenterPoint lineto
    stroke
end } def

%%---------------- Program -------------------


FlatTopBoard
DrawHexBoard
1 HexBoardBorders
AltHexBoardCoordinates

1 3 HexWhitePiece
2 1 HexBlackPiece
3 1 HexWhitePiece
2 2 HexWhiteMarker
3 2 HexWhiteMarker
3 2 2 3 2 4 HexCurve
3 2 3 3 2 4 HexCurve


%------------ Trailer --------------

showpage

%%EndDocument
 @endspecial 181 7423 a Fh(Solution)347 7624 y Fi(\(ab)5
b(o)-5 b(v)g(e)62 b(middle\))g(If)e(blac)-5 b(k's)62
b(1st)f(mo)-5 b(v)g(e)62 b(is)e(not)h(in)g(the)g(set)g
Ff(f)p Fe(a)p Fi(1)p Fe(;)28 b(a)p Fi(2)p Fe(;)g(b)p
Fi(1)p Ff(g)62 b Fi(then)f(white)h(wins)f(b)-5 b(y)181
7824 y(pla)g(ying)63 b(b1,)g(and)e(then)h(on)f(the)h(next)f(mo)-5
b(v)g(e)62 b(one)g(of)f Ff(f)p Fe(a)p Fi(1)p Fe(;)28
b(a)p Fi(2)p Ff(g)p Fi(.)92 b(Similarly)-14 b(,)65 b(if)c(blac)-5
b(k's)62 b(1st)f(mo)-5 b(v)g(e)181 8025 y(is)57 b(not)g(in)f
Ff(f)p Fe(a)p Fi(2)p Fe(;)28 b(a)p Fi(3)p Fe(;)g(b)p
Fi(2)p Ff(g)58 b Fi(then)f(white)h(wins)f(b)-5 b(y)57
b(pla)-5 b(ying)58 b(b2)f(and)g(then)g(on)g(the)g(next)g(mo)-5
b(v)g(e)58 b(one)f(of)181 8226 y Ff(f)p Fe(a)p Fi(2)p
Fe(;)28 b(a)p Fi(3)p Ff(g)p Fi(.)74 b(So)54 b(white)i(wins)f(unless)h
(blac)-5 b(k's)56 b(1st)e(mo)-5 b(v)g(e)56 b(is)f(in)g
Fc(b)-8 b(oth)53 b Fi(sets,)i(so)g(a2.)347 8627 y(\(ab)5
b(o)-5 b(v)g(e)52 b(righ)-5 b(t\))53 b(No)-5 b(w)51 b(white)h(wins)g(b)
-5 b(y)51 b(pla)-5 b(ying)52 b(a3,)g(and)g(then)f(on)h(the)f(next)g(mo)
-5 b(v)g(e)52 b(either)g(b2)f(or)181 8828 y(\(if)j(blac)-5
b(k)56 b(is)e(already)i(there\))g(b3,)f(and)g(then)g(on)g(the)g(next)g
(mo)-5 b(v)g(e)56 b(either)f(c2)g(or)g(c3.)p Black Black
eop end
%%Page: 11 11
TeXDict begin 11 10 bop Black 181 -165 a Fj(Iv)-5 b(erson)55
b(exam)h(2016)p 1555 -165 4439 6 v 4656 w Fi(11)p Black
347 347 a(\(b\))49 b Fk([4)i(marks])d Fi(F)-14 b(or)50
b Fh(eac)-5 b(h)48 b Fi(cell)h(on)g(the)g(4)25 b Ff(\002)g
Fi(4)50 b(b)5 b(oard)49 b(b)5 b(elo)-5 b(w,)51 b(sho)-5
b(w)50 b(who)g(wins)f(\(white)h(or)f(blac)-5 b(k\))181
548 y(if)53 b(that)h(cell)f(is)g(white's)i(\014rst)f(mo)-5
b(v)g(e,)55 b(and)e(b)5 b(oth)54 b(pla)-5 b(y)g(ers)55
b(pla)-5 b(y)54 b(p)5 b(erfectly)53 b(from)h(then)g(on:)72
b(if)53 b(white)181 748 y(wins,)68 b(then)e(on)f(that)g(cell)h(dra)-5
b(w)66 b(an)f(empt)-5 b(y)66 b(circle)g(\(or)f(the)g(letter)h
Fd(W)p Fi(\);)f(if)g(blac)-5 b(k)65 b(wins,)k(then)c(on)181
949 y(that)55 b(cell)g(dra)-5 b(w)56 b(a)f(\014lled)g(circle)h(\(or)f
(the)g(letter)g Fd(B)p Fi(\).)347 1150 y(Y)-14 b(ou)55
b(do)g(not)g(need)g(to)g(justify)f(y)-5 b(our)56 b(answ)-5
b(er:)74 b(y)-5 b(our)56 b(score)f(will)g(b)5 b(e)54
b(calculated)j(as)e(follo)-5 b(ws:)997 1611 y(max)1327
1367 y Fa(\()1456 1499 y Fi(\(#)54 b(of)66 b(correct)56
b(answ)-5 b(ers)r(\))38 b Ff(\000)f Fi(\(#)54 b(of)66
b(incorrect)57 b(answ)-5 b(ers)r(\))p 1456 1572 3545
6 v 3187 1725 a(4)5017 1611 y Fe(;)175 b Fi(0)5318 1367
y Fa(\))5458 1611 y Fe(:)181 2072 y Fi(Cells)65 b(left)f(blank)h(will)f
(b)5 b(e)64 b(coun)-5 b(ted)66 b(neither)g(correct)f(nor)g(incorrect.)
103 b(Illegible)65 b(en)-5 b(tries)66 b(will)f(b)5 b(e)181
2273 y(coun)-5 b(ted)46 b(incorrect.)71 b(\(Some)44 b(empt)-5
b(y)45 b(4)14 b Ff(\002)g Fi(4)45 b(grids)f(can)g(b)5
b(e)43 b(found)h(at)g(the)g(end)g(of)f(this)h(exam.)70
b(These)181 2473 y(are)55 b(for)f(y)-5 b(our)56 b(scratc)-5
b(h)56 b(notes)g(only)e(and)i(will)f(not)g(b)5 b(e)54
b(lo)5 b(ok)-5 b(ed)55 b(at)g(when)h(w)-5 b(e)55 b(grade.\))181
2875 y Fh(Solution)p Black Black 2069 4751 a @beginspecial
0 @llx 0 @lly 66 @urx 47 @ury 1700 @rwi @setspecial
%%BeginDocument: fz/pix/4x4.winners.eps
%!PS-Adobe-3.0
%%Creator: Jack van Rijswijck, thanks to Cameron Browne
%%BoundingBox: 0 0 66 47
%%Pages: 0
%%EndComments

/OriginX -6 def
/OriginY 36 def
%---------------- Variables -------------------

/DimX 4 def
/DimY 4 def
/Scale 1.2 def


% draw  Hex boards, any size ... but labels only up to 26x26
% based on code by Cameron Browne, revised by Jack vR, revised by RBH
%-------------- state initializations -------------------------
1 setlinejoin   % lines meet at a point  ==>    use round join
%---------------- constants -------------------
/Root3Div2  0.86602540378444 def
/Chars   {[(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)
           (n)(o)(p)(q)(r)(s)(t)(u)(v)(w)(x)(y)(z)]} def
/CharsUC {[(A)(B)(C)(D)(E)(F)(G)(H)(I)(J)(K)(L)(M)
           (N)(O)(P)(Q)(R)(S)(T)(U)(V)(W)(X)(Y)(Z)]} def
/Digits  {[(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)(12)(13)
           (14)(15)(16)(17)(18)(19)(20)(21)(22)(23)(24)(25)(26)]} def
/HexRadius      5 Scale mul def % hexagon center-to-corner distance 
/HexLineWidth 0.1 Scale mul def 
/GraphVertexSize 1.0 Scale mul def
/GraphLineWidth 0.5 Scale mul def
/CircleRadius 3.0 Scale mul def 
/CircleLineWidth 0.346 Scale mul def 
/PerimeterWidth 0.5 Scale mul def 
/TextHeight 4.5 def
/TextWidth TextHeight 0.45 mul def 
/BoardShade 0.8 def
/CoordinatesShade 0.5 def
/MarkerSize 1.2 def
/CellOrientation 1 def   % 1: flat bottom  0: pointed bottom
/CellCorner [ % 6 cell corners, wrt center 0 0, plus "up" and "down"
   [ HexRadius  neg       0                           ] 
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul neg ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul neg ]
   [ HexRadius            0                           ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul     ]
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul neg ]
] def
%----- name cell corner indices ... see below
/Left  0 def /DownLeft 1 def /DownRight 2 def 
/Right 3 def /UpRight  4 def /UpLeft    5 def 
/Up    6 def /Down     7 def
%-----------------------------------------------------
% cell orientations:  flat bottom    flat side
%-----------------------------------------------------
% flat bottom 
% board cell indices            cell corner/top/bottom indices
%             --
%           /    \
%        --   1,3  --                  5 -6- 4
%      /    \    /    \               /       \
%   --   1,2  --   2,3  --           0         3
% /    \    /    \    /    \          \       /
%   1,1  --   2,2  --   3,3            1 -7- 2
% \    /    \    /    \    /
%   --   2,1  --   3,2  --
%      \    /    \    /   
%        --   3,1  --     
%----------------------------------------------------
% flat side 
%    /  \  /  \  /  \                       5
%   | 11 || 12 || 13 ||                   /   6
%    \  /  \  /  \  /  \                 0     4
%     || 21 || 22 || 23 |                |     |
%       \  /  \  /  \  /  \              1     3
%        || 31 || 32 || 33 |              7   /
%-------------------------------------------2--------
%----------- procedures -------------
/ScalePoint { % stack: ... x y size ==> ...  x*size y*size
   3 dict begin /size exch def /y exch def /x exch def
   x size mul           y size mul
end } def

/FlatTopBoard { FlatSideCells } def

/FlatSideCells {  % redefine cell orientation for flat side
  /CellOrientation 0 def   
  /CellCorner [ % 6 cell corners, wrt center 0 0  %xcoord ycoord
    [HexRadius Root3Div2 mul neg  HexRadius 2 div     ]
    [HexRadius Root3Div2 mul neg  HexRadius 2 div neg ]
    [0                            HexRadius neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div ]
    [0                            HexRadius ]
    [HexRadius Root3Div2 2 div mul HexRadius 0.75 mul ]
    [HexRadius Root3Div2 2 div mul neg HexRadius 0.75 mul neg ]
  ] def
} def

/HexCenterPoint { % center of cell (i,j)
    2 dict begin /j exch def /i exch def
    CellOrientation 1 eq {
    OriginX i j add HexRadius mul 1.5 mul add %Ox + (i+j)*HR*1.5
    OriginY i j sub HexRadius mul Root3Div2 mul sub %Oy - (i-j)*HR*R3/2
    }{
    OriginX i 2 j mul add HexRadius mul Root3Div2 mul add  %Ox + (2i+j)*HR
    OriginY i 1 sub HexRadius mul 1.5 mul sub %Oy - i*HR*R3/2
    } ifelse
end } def
 
/HexLine { % a b c d
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint lineto
    stroke
} def

/HexCurve { % a b c d e f
    /f exch def
    /e exch def
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint e f HexCenterPoint HexRadius 2 mul arcto
    e f HexCenterPoint lineto
    stroke
} def

/HxgnCorner { 5 dict begin /corn exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    x CellCorner corn get 0 get add
    y CellCorner corn get 1 get add
end } def

/Go { 2 dict begin /corn exch def /mag exch def
   % rlineto in a cell orientation direction
   CellCorner corn get aload pop mag ScalePoint rlineto
end } def

/TurnGo { rotate 1.0 Left Go } def % call: degrees TurnGo
/MagTurnGo { rotate Left Go } def % call: mag degrees TurnGo

/HexagonPath { % call: i j HexagonPath
    newpath 
    UpRight HxgnCorner moveto 
    6 { 1.0 Left Go 60 rotate } repeat 
} def

/FillAndStroke { 2 dict begin /sh exch def /wdth exch def
    gsave sh setgray fill
    grestore 0 setgray wdth setlinewidth stroke
end } def

/ShadedHexagon { 3 dict begin /shade exch def /j exch def /i exch def
    i j HexagonPath
    0 shade FillAndStroke
end } def

/Hexagon { % stack: ... i j
    HexagonPath 
    HexLineWidth BoardShade FillAndStroke
} def

/SemiHexagonPath { % stack: ... top i j
    newpath 
    1 eq { Left HxgnCorner moveto 
        1.0 UpRight Go 1.0 Right Go 1.0 DownRight Go stroke }{
        Right HxgnCorner moveto 
        1.0 DownLeft Go 1.0 Left Go 1.0 UpLeft Go stroke
    } ifelse
} def

/HexBoardPerimeter {
    newpath
    1 DimY UpRight HxgnCorner moveto 1.0 Left Go                      
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 rotate %restore rotation
} def

%----------- Havannah coordinates ----------------------
%                   ..  ..  ..
%                 d1  c2  b3  a4
%                   c1  b2  a3
%                     b1  a2
%                       a1
/HavannahPosn { % convert to usual coordinate, so ... x y  =>  ... 1+DimX-x  y
    exch DimX 1 add exch sub exch 
} def

/HavannahBoardPerimeter {
    newpath
    1 DimX UpRight HxgnCorner moveto 1.0 Left Go                      
    6 {Base 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo } repeat
} def

/DrawHexBoard { 2 dict begin
    gsave
    HexBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexPLBoard { 6 dict begin %point-line board
    gsave
    BoardShade setgray newpath
    -1 DimY 1 add 0.5 mul HexCenterPoint moveto
    1 DimY HexCenterPoint lineto
    DimX 1 add 0.5 mul DimY 2 add HexCenterPoint lineto
    DimX DimY HexCenterPoint lineto
    DimX 2 add DimY 1 add 0.5 mul HexCenterPoint lineto
    DimX 1 HexCenterPoint lineto
    DimX 1 add 0.5 mul -1 HexCenterPoint lineto
    1 1 HexCenterPoint lineto
    closepath fill 0 setgray
    1 DimY HexCenterPoint moveto
    1 1 DimX { /i exch def 
        i 1 i DimY HexLine 
        DimY 1 add 0.5 mul -1 i 1 HexLine
        DimY 1 add 0.5 mul DimY 2 add i DimY HexLine } for
    1 1 DimY { /j exch def 
        1 j DimX j HexLine 
        -1 DimX 1 add 0.5 mul 1 j HexLine
        DimX 2 add DimX 1 add 0.5 mul DimX j HexLine } for
    /topx 1 def /topy 1 def /btmx 1 def /btmy 1 def
    DimX DimY add 3 sub {
      topx DimX lt {/topx 1 topx add def}{/topy 1 topy add def} ifelse 
      btmy DimY lt {/btmy 1 btmy add def}{/btmx 1 btmx add def} ifelse 
      topx topy btmx btmy HexLine
      } repeat
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j HexVertex
	} for } for
    grestore
end } def

/DrawHavannahBoard { 3 dict begin
    /Base DimX 1 add 2 idiv  def
    gsave
    HavannahBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 Base { /j exch def
	Base j 1 sub sub 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    1 1 Base 1 sub { /j exch def
	1 1 DimX j sub { /i exch def
	   i j Base add 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexBorder{ 6 dict begin /start exch def 
    /cells exch def /isBlack exch def /which exch def
    gsave
    which UpLeft eq {1 DimY 1 add start sub Up HxgnCorner moveto /d Left def /r 60 def} if
    which UpRight eq {start DimY Up HxgnCorner moveto /d Right def /r 300 def} if
    which DownLeft eq {DimX 1 add start sub 1 Down HxgnCorner moveto /d Left def /r 300 def} if
    which DownRight eq {DimX start Down HxgnCorner moveto /d Right def /r 60 def} if
    0.5 d Go 
    which UpRight eq which DownRight eq or {180 rotate} if
    r TurnGo 
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.5 360 r sub MagTurnGo 1.5 360 r sub 2 mul MagTurnGo
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.75 360 r sub MagTurnGo
    closepath isBlack 1 eq {gsave fill grestore} if stroke grestore
end } def

/NoDrawHexBoard {  % dummy, used in creating bounding box
} def

/HexBoardBorders { 1 dict begin
    /upperLeftBlack exch def
    PerimeterWidth setlinewidth 0 setgray
    UpLeft    upperLeftBlack       DimY 1 DrawHexBorder
    UpRight   1 upperLeftBlack sub DimX 1 DrawHexBorder
    DownRight upperLeftBlack       DimY 1 DrawHexBorder
    DownLeft  1 upperLeftBlack sub DimX 1 DrawHexBorder
end } def

/YBoardPerimeter {
    newpath 1 1 DownRight HxgnCorner moveto 180 rotate
    3 { DimX 1 sub { 300 TurnGo 60 TurnGo } repeat 
        60 TurnGo 60 TurnGo} 
    repeat % now restore initial rotation state
    180 rotate % closepath
} def

/DrawYBoard { 2 dict begin
    YBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimX {/j exch def
        1 1 DimX 1 add j sub {/i exch def
	    i j 1 SemiHexagonPath stroke
        } for } for
end } def

/FontSelect { % bold italic FontSelect
    2 dict begin /italic exch def /bold exch def
    bold {
	italic 
	{ /Times-BoldItalic findfont TextHeight scalefont setfont } 
	{ /Times-Bold findfont TextHeight scalefont setfont }
	ifelse} 
        {
	italic {/Times-Italic findfont TextHeight scalefont setfont} 
	{ /Times findfont TextHeight scalefont setfont }
	ifelse}
    ifelse
end } def
	    
/LabelString {   % call: i j (str) strlen LabelString
%  to use with board rotation, remove comments
    6 dict begin /strlen exch def /str exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint /y exch def /x exch def
    %BoardRotation rotate
    x y moveto 
    %360 BoardRotation sub rotate
    TextWidth strlen mul 0.5 mul neg TextHeight 0.33 mul neg rmoveto
    str show 
end } def

/AbsLabelString { 4 dict begin
    /strlen exch def /str exch def /y exch def /x exch def
    newpath
    x AbsCoordX TextWidth strlen mul 0.5 mul sub
    y AbsCoordY TextHeight 0.33 mul sub
    moveto
    str
    show
end } def

/LabelStringVerb { % i j (str) strlen shade bold italic LabelStringVerb
    7 dict begin /italic exch def /bold exch def /shade exch def
    /strlen exch def /str exch def /j exch def /i exch def
    bold italic FontSelect shade setgray
    i j str strlen LabelString
end } def

/HexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimX { /i exch def
	i 0          Chars i 1 sub get 1 LabelString
	i DimY 1 add Chars i 1 sub get 1 LabelString
    } for
    1 1 DimY { /j exch def
	0 j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
	DimX 1 add j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HavannahBoardCoordinates { 3 dict begin
    false true FontSelect CoordinatesShade setgray
    /Base DimX 1 add 2 idiv  def
    1 1 Base { /i exch def
	i 0 HavannahPosn Chars  i 1 sub get 1 LabelString
	0 i HavannahPosn Digits i 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
    1 1 Base 1 sub { /i exch def
	i Base add i HavannahPosn Chars  i Base add 1 sub get 1 LabelString
	i i Base add HavannahPosn Digits i Base add 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/AltHexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimY { /j exch def
	0 j Chars j 1 sub get 1 LabelString
        %DimX 1 add j Chars j 1 sub get 1 LabelString
    } for
    1 1 DimX { /i exch def
	i 0 Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
	%i DimY 1 add Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HexDot { 3 dict begin /size exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint size 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexWhiteMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexWhitePiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexBlackMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexBlackPiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    1 setgray 0 setlinewidth fill
end } def

/HexDoubleMarker { 6 dict begin
    /shaderight exch def /shadeleft exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    gsave
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    shadeleft setgray 0 setlinewidth fill
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    shaderight setgray 0 setlinewidth fill
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    grestore
end } def

/HexBlackWhiteMarker { 0.0 1.0 HexDoubleMarker } def

/HexWhiteBlackMarker { 1.0 0.0 HexDoubleMarker } def
        
/HexMarker { 2 dict begin /j exch def /i exch def
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setlinewidth fill
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke  
end } def

/HexBlackMarker { 2 dict begin /j exch def /i exch def
    0 setgray
    i j HexMarker
end } def

/HexWhiteMarker { 2 dict begin /j exch def /i exch def
    1 setgray
    i j HexMarker
end } def
    
/HexPiece { 3 dict begin /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/MagicStone { 4 dict begin 
    /size exch def /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 1.3 mul size mul 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/HexWhitePiece { 1.0 HexPiece } def

/HexBlackPiece { 0.0 HexPiece } def

/HexWhiteLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def
    i j HexWhitePiece
    i j str strlen 0.0 true true LabelStringVerb
end } def

/HexBlackLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def 
    i j HexBlackPiece
    i j str strlen 1.0 true true LabelStringVerb
end } def

/AbsCoordX { 1 dict begin /x exch def
    OriginX x Scale mul add
end } def

/AbsCoordY { 1 dict begin /y exch def
    OriginY y Scale mul add
end } def

/DrawBox { /maxy exch def /maxx exch def /miny exch def /minx exch def
    newpath
    minx miny moveto
    maxx minx sub 0 rlineto
    0 maxy miny sub rlineto
    minx maxx sub 0 rlineto
    0 miny maxy sub rlineto
    HexLineWidth setlinewidth
    0 setgray
    stroke
} def

/HexVertex { 2 dict begin /j exch def /i exch def
    i j GraphVertexSize HexDot
end } def

/HexLine { 4 dict begin /j2 exch def /i2 exch def /j1 exch def /i1 exch def
    GraphLineWidth setlinewidth
    0 setgray
    newpath
    i1 j1 HexCenterPoint moveto
    i2 j2 HexCenterPoint lineto
    stroke
end } def

%%---------------- Program -------------------


FlatTopBoard
DrawHexBoard
1 HexBoardBorders
1 1 HexBlackMarker
1 2 HexBlackMarker
1 3 HexBlackMarker
1 4 HexWhiteMarker
2 1 HexBlackMarker
2 2 HexBlackMarker
2 3 HexWhiteMarker
2 4 HexBlackMarker
3 1 HexBlackMarker
3 2 HexWhiteMarker
3 3 HexBlackMarker
3 4 HexBlackMarker
4 1 HexWhiteMarker
4 2 HexBlackMarker
4 3 HexBlackMarker
4 4 HexBlackMarker


%------------ Trailer --------------

showpage

%%EndDocument
 @endspecial 347 5332 a Fi(White)62 b(wins)h(b)-5 b(y)62
b(pla)-5 b(ying)63 b(b3,)g(as)f(sho)-5 b(wn)63 b(\(b)5
b(elo)-5 b(w)63 b(left\).)94 b(By)62 b(a)f(symmetric)i(strategy)g
(\(re\015ect)181 5533 y(the)51 b(b)5 b(oard)51 b(through)i(the)e(cen)-5
b(termost)53 b(p)5 b(oin)-5 b(t\))52 b(white)g(also)f(wins)g(b)-5
b(y)51 b(pla)-5 b(ying)52 b(c2.)72 b(So)50 b(far)h(w)-5
b(e)51 b(ha)-5 b(v)g(e)181 5733 y(t)g(w)g(o)56 b(winning)g(op)5
b(enings.)347 7630 y @beginspecial 0 @llx 0 @lly 66 @urx
47 @ury 1700 @rwi @setspecial
%%BeginDocument: fz/pix/4.1strat2.eps
%!PS-Adobe-3.0
%%Creator: Jack van Rijswijck, thanks to Cameron Browne
%%BoundingBox: 0 0 66 47
%%Pages: 0
%%EndComments

/OriginX -6 def
/OriginY 36 def
%---------------- Variables -------------------

/DimX 4 def
/DimY 4 def
/Scale 1.2 def


% draw  Hex boards, any size ... but labels only up to 26x26
% based on code by Cameron Browne, revised by Jack vR, revised by RBH
%-------------- state initializations -------------------------
1 setlinejoin   % lines meet at a point  ==>    use round join
%---------------- constants -------------------
/Root3Div2  0.86602540378444 def
/Chars   {[(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)
           (n)(o)(p)(q)(r)(s)(t)(u)(v)(w)(x)(y)(z)]} def
/CharsUC {[(A)(B)(C)(D)(E)(F)(G)(H)(I)(J)(K)(L)(M)
           (N)(O)(P)(Q)(R)(S)(T)(U)(V)(W)(X)(Y)(Z)]} def
/Digits  {[(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)(12)(13)
           (14)(15)(16)(17)(18)(19)(20)(21)(22)(23)(24)(25)(26)]} def
/HexRadius      5 Scale mul def % hexagon center-to-corner distance 
/HexLineWidth 0.1 Scale mul def 
/GraphVertexSize 1.0 Scale mul def
/GraphLineWidth 0.5 Scale mul def
/CircleRadius 3.0 Scale mul def 
/CircleLineWidth 0.346 Scale mul def 
/PerimeterWidth 0.5 Scale mul def 
/TextHeight 4.5 def
/TextWidth TextHeight 0.45 mul def 
/BoardShade 0.8 def
/CoordinatesShade 0.5 def
/MarkerSize 1.2 def
/CellOrientation 1 def   % 1: flat bottom  0: pointed bottom
/CellCorner [ % 6 cell corners, wrt center 0 0, plus "up" and "down"
   [ HexRadius  neg       0                           ] 
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul neg ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul neg ]
   [ HexRadius            0                           ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul     ]
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul neg ]
] def
%----- name cell corner indices ... see below
/Left  0 def /DownLeft 1 def /DownRight 2 def 
/Right 3 def /UpRight  4 def /UpLeft    5 def 
/Up    6 def /Down     7 def
%-----------------------------------------------------
% cell orientations:  flat bottom    flat side
%-----------------------------------------------------
% flat bottom 
% board cell indices            cell corner/top/bottom indices
%             --
%           /    \
%        --   1,3  --                  5 -6- 4
%      /    \    /    \               /       \
%   --   1,2  --   2,3  --           0         3
% /    \    /    \    /    \          \       /
%   1,1  --   2,2  --   3,3            1 -7- 2
% \    /    \    /    \    /
%   --   2,1  --   3,2  --
%      \    /    \    /   
%        --   3,1  --     
%----------------------------------------------------
% flat side 
%    /  \  /  \  /  \                       5
%   | 11 || 12 || 13 ||                   /   6
%    \  /  \  /  \  /  \                 0     4
%     || 21 || 22 || 23 |                |     |
%       \  /  \  /  \  /  \              1     3
%        || 31 || 32 || 33 |              7   /
%-------------------------------------------2--------
%----------- procedures -------------
/ScalePoint { % stack: ... x y size ==> ...  x*size y*size
   3 dict begin /size exch def /y exch def /x exch def
   x size mul           y size mul
end } def

/FlatTopBoard { FlatSideCells } def

/FlatSideCells {  % redefine cell orientation for flat side
  /CellOrientation 0 def   
  /CellCorner [ % 6 cell corners, wrt center 0 0  %xcoord ycoord
    [HexRadius Root3Div2 mul neg  HexRadius 2 div     ]
    [HexRadius Root3Div2 mul neg  HexRadius 2 div neg ]
    [0                            HexRadius neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div ]
    [0                            HexRadius ]
    [HexRadius Root3Div2 2 div mul HexRadius 0.75 mul ]
    [HexRadius Root3Div2 2 div mul neg HexRadius 0.75 mul neg ]
  ] def
} def

/HexCenterPoint { % center of cell (i,j)
    2 dict begin /j exch def /i exch def
    CellOrientation 1 eq {
    OriginX i j add HexRadius mul 1.5 mul add %Ox + (i+j)*HR*1.5
    OriginY i j sub HexRadius mul Root3Div2 mul sub %Oy - (i-j)*HR*R3/2
    }{
    OriginX i 2 j mul add HexRadius mul Root3Div2 mul add  %Ox + (2i+j)*HR
    OriginY i 1 sub HexRadius mul 1.5 mul sub %Oy - i*HR*R3/2
    } ifelse
end } def
 
/HexLine { % a b c d
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint lineto
    stroke
} def

/HexCurve { % a b c d e f
    /f exch def
    /e exch def
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint e f HexCenterPoint HexRadius 2 mul arcto
    e f HexCenterPoint lineto
    stroke
} def

/HxgnCorner { 5 dict begin /corn exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    x CellCorner corn get 0 get add
    y CellCorner corn get 1 get add
end } def

/Go { 2 dict begin /corn exch def /mag exch def
   % rlineto in a cell orientation direction
   CellCorner corn get aload pop mag ScalePoint rlineto
end } def

/TurnGo { rotate 1.0 Left Go } def % call: degrees TurnGo
/MagTurnGo { rotate Left Go } def % call: mag degrees TurnGo

/HexagonPath { % call: i j HexagonPath
    newpath 
    UpRight HxgnCorner moveto 
    6 { 1.0 Left Go 60 rotate } repeat 
} def

/FillAndStroke { 2 dict begin /sh exch def /wdth exch def
    gsave sh setgray fill
    grestore 0 setgray wdth setlinewidth stroke
end } def

/ShadedHexagon { 3 dict begin /shade exch def /j exch def /i exch def
    i j HexagonPath
    0 shade FillAndStroke
end } def

/Hexagon { % stack: ... i j
    HexagonPath 
    HexLineWidth BoardShade FillAndStroke
} def

/SemiHexagonPath { % stack: ... top i j
    newpath 
    1 eq { Left HxgnCorner moveto 
        1.0 UpRight Go 1.0 Right Go 1.0 DownRight Go stroke }{
        Right HxgnCorner moveto 
        1.0 DownLeft Go 1.0 Left Go 1.0 UpLeft Go stroke
    } ifelse
} def

/HexBoardPerimeter {
    newpath
    1 DimY UpRight HxgnCorner moveto 1.0 Left Go                      
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 rotate %restore rotation
} def

%----------- Havannah coordinates ----------------------
%                   ..  ..  ..
%                 d1  c2  b3  a4
%                   c1  b2  a3
%                     b1  a2
%                       a1
/HavannahPosn { % convert to usual coordinate, so ... x y  =>  ... 1+DimX-x  y
    exch DimX 1 add exch sub exch 
} def

/HavannahBoardPerimeter {
    newpath
    1 DimX UpRight HxgnCorner moveto 1.0 Left Go                      
    6 {Base 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo } repeat
} def

/DrawHexBoard { 2 dict begin
    gsave
    HexBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexPLBoard { 6 dict begin %point-line board
    gsave
    BoardShade setgray newpath
    -1 DimY 1 add 0.5 mul HexCenterPoint moveto
    1 DimY HexCenterPoint lineto
    DimX 1 add 0.5 mul DimY 2 add HexCenterPoint lineto
    DimX DimY HexCenterPoint lineto
    DimX 2 add DimY 1 add 0.5 mul HexCenterPoint lineto
    DimX 1 HexCenterPoint lineto
    DimX 1 add 0.5 mul -1 HexCenterPoint lineto
    1 1 HexCenterPoint lineto
    closepath fill 0 setgray
    1 DimY HexCenterPoint moveto
    1 1 DimX { /i exch def 
        i 1 i DimY HexLine 
        DimY 1 add 0.5 mul -1 i 1 HexLine
        DimY 1 add 0.5 mul DimY 2 add i DimY HexLine } for
    1 1 DimY { /j exch def 
        1 j DimX j HexLine 
        -1 DimX 1 add 0.5 mul 1 j HexLine
        DimX 2 add DimX 1 add 0.5 mul DimX j HexLine } for
    /topx 1 def /topy 1 def /btmx 1 def /btmy 1 def
    DimX DimY add 3 sub {
      topx DimX lt {/topx 1 topx add def}{/topy 1 topy add def} ifelse 
      btmy DimY lt {/btmy 1 btmy add def}{/btmx 1 btmx add def} ifelse 
      topx topy btmx btmy HexLine
      } repeat
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j HexVertex
	} for } for
    grestore
end } def

/DrawHavannahBoard { 3 dict begin
    /Base DimX 1 add 2 idiv  def
    gsave
    HavannahBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 Base { /j exch def
	Base j 1 sub sub 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    1 1 Base 1 sub { /j exch def
	1 1 DimX j sub { /i exch def
	   i j Base add 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexBorder{ 6 dict begin /start exch def 
    /cells exch def /isBlack exch def /which exch def
    gsave
    which UpLeft eq {1 DimY 1 add start sub Up HxgnCorner moveto /d Left def /r 60 def} if
    which UpRight eq {start DimY Up HxgnCorner moveto /d Right def /r 300 def} if
    which DownLeft eq {DimX 1 add start sub 1 Down HxgnCorner moveto /d Left def /r 300 def} if
    which DownRight eq {DimX start Down HxgnCorner moveto /d Right def /r 60 def} if
    0.5 d Go 
    which UpRight eq which DownRight eq or {180 rotate} if
    r TurnGo 
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.5 360 r sub MagTurnGo 1.5 360 r sub 2 mul MagTurnGo
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.75 360 r sub MagTurnGo
    closepath isBlack 1 eq {gsave fill grestore} if stroke grestore
end } def

/NoDrawHexBoard {  % dummy, used in creating bounding box
} def

/HexBoardBorders { 1 dict begin
    /upperLeftBlack exch def
    PerimeterWidth setlinewidth 0 setgray
    UpLeft    upperLeftBlack       DimY 1 DrawHexBorder
    UpRight   1 upperLeftBlack sub DimX 1 DrawHexBorder
    DownRight upperLeftBlack       DimY 1 DrawHexBorder
    DownLeft  1 upperLeftBlack sub DimX 1 DrawHexBorder
end } def

/YBoardPerimeter {
    newpath 1 1 DownRight HxgnCorner moveto 180 rotate
    3 { DimX 1 sub { 300 TurnGo 60 TurnGo } repeat 
        60 TurnGo 60 TurnGo} 
    repeat % now restore initial rotation state
    180 rotate % closepath
} def

/DrawYBoard { 2 dict begin
    YBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimX {/j exch def
        1 1 DimX 1 add j sub {/i exch def
	    i j 1 SemiHexagonPath stroke
        } for } for
end } def

/FontSelect { % bold italic FontSelect
    2 dict begin /italic exch def /bold exch def
    bold {
	italic 
	{ /Times-BoldItalic findfont TextHeight scalefont setfont } 
	{ /Times-Bold findfont TextHeight scalefont setfont }
	ifelse} 
        {
	italic {/Times-Italic findfont TextHeight scalefont setfont} 
	{ /Times findfont TextHeight scalefont setfont }
	ifelse}
    ifelse
end } def
	    
/LabelString {   % call: i j (str) strlen LabelString
%  to use with board rotation, remove comments
    6 dict begin /strlen exch def /str exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint /y exch def /x exch def
    %BoardRotation rotate
    x y moveto 
    %360 BoardRotation sub rotate
    TextWidth strlen mul 0.5 mul neg TextHeight 0.33 mul neg rmoveto
    str show 
end } def

/AbsLabelString { 4 dict begin
    /strlen exch def /str exch def /y exch def /x exch def
    newpath
    x AbsCoordX TextWidth strlen mul 0.5 mul sub
    y AbsCoordY TextHeight 0.33 mul sub
    moveto
    str
    show
end } def

/LabelStringVerb { % i j (str) strlen shade bold italic LabelStringVerb
    7 dict begin /italic exch def /bold exch def /shade exch def
    /strlen exch def /str exch def /j exch def /i exch def
    bold italic FontSelect shade setgray
    i j str strlen LabelString
end } def

/HexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimX { /i exch def
	i 0          Chars i 1 sub get 1 LabelString
	i DimY 1 add Chars i 1 sub get 1 LabelString
    } for
    1 1 DimY { /j exch def
	0 j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
	DimX 1 add j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HavannahBoardCoordinates { 3 dict begin
    false true FontSelect CoordinatesShade setgray
    /Base DimX 1 add 2 idiv  def
    1 1 Base { /i exch def
	i 0 HavannahPosn Chars  i 1 sub get 1 LabelString
	0 i HavannahPosn Digits i 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
    1 1 Base 1 sub { /i exch def
	i Base add i HavannahPosn Chars  i Base add 1 sub get 1 LabelString
	i i Base add HavannahPosn Digits i Base add 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/AltHexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimY { /j exch def
	0 j Chars j 1 sub get 1 LabelString
        %DimX 1 add j Chars j 1 sub get 1 LabelString
    } for
    1 1 DimX { /i exch def
	i 0 Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
	%i DimY 1 add Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HexDot { 3 dict begin /size exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint size 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexWhiteMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexWhitePiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexBlackMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexBlackPiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    1 setgray 0 setlinewidth fill
end } def

/HexDoubleMarker { 6 dict begin
    /shaderight exch def /shadeleft exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    gsave
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    shadeleft setgray 0 setlinewidth fill
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    shaderight setgray 0 setlinewidth fill
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    grestore
end } def

/HexBlackWhiteMarker { 0.0 1.0 HexDoubleMarker } def

/HexWhiteBlackMarker { 1.0 0.0 HexDoubleMarker } def
        
/HexMarker { 2 dict begin /j exch def /i exch def
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setlinewidth fill
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke  
end } def

/HexBlackMarker { 2 dict begin /j exch def /i exch def
    0 setgray
    i j HexMarker
end } def

/HexWhiteMarker { 2 dict begin /j exch def /i exch def
    1 setgray
    i j HexMarker
end } def
    
/HexPiece { 3 dict begin /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/MagicStone { 4 dict begin 
    /size exch def /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 1.3 mul size mul 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/HexWhitePiece { 1.0 HexPiece } def

/HexBlackPiece { 0.0 HexPiece } def

/HexWhiteLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def
    i j HexWhitePiece
    i j str strlen 0.0 true true LabelStringVerb
end } def

/HexBlackLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def 
    i j HexBlackPiece
    i j str strlen 1.0 true true LabelStringVerb
end } def

/AbsCoordX { 1 dict begin /x exch def
    OriginX x Scale mul add
end } def

/AbsCoordY { 1 dict begin /y exch def
    OriginY y Scale mul add
end } def

/DrawBox { /maxy exch def /maxx exch def /miny exch def /minx exch def
    newpath
    minx miny moveto
    maxx minx sub 0 rlineto
    0 maxy miny sub rlineto
    minx maxx sub 0 rlineto
    0 miny maxy sub rlineto
    HexLineWidth setlinewidth
    0 setgray
    stroke
} def

/HexVertex { 2 dict begin /j exch def /i exch def
    i j GraphVertexSize HexDot
end } def

/HexLine { 4 dict begin /j2 exch def /i2 exch def /j1 exch def /i1 exch def
    GraphLineWidth setlinewidth
    0 setgray
    newpath
    i1 j1 HexCenterPoint moveto
    i2 j2 HexCenterPoint lineto
    stroke
end } def

%%---------------- Program -------------------


FlatTopBoard
DrawHexBoard
1 HexBoardBorders
AltHexBoardCoordinates

3 2 4 1 4 0 HexCurve
3 2 3 1 4 0 HexCurve
3 2 4 2 4 3 HexCurve
3 2 3 3 4 3 HexCurve
4 3 3 4 3 5 HexCurve
4 3 4 4 3 5 HexCurve
2 3 1 4 1 5 HexCurve
2 3 2 4 1 5 HexCurve
3 2 2 3 HexLine
3 2 HexWhitePiece
4 3 HexWhiteMarker
2 3 HexWhiteMarker


%------------ Trailer --------------

showpage

%%EndDocument
 @endspecial 2417 w @beginspecial 0 @llx 0 @lly 66 @urx
47 @ury 1700 @rwi @setspecial
%%BeginDocument: fz/pix/4x4.winners0.eps
%!PS-Adobe-3.0
%%Creator: Jack van Rijswijck, thanks to Cameron Browne
%%BoundingBox: 0 0 66 47
%%Pages: 0
%%EndComments

/OriginX -6 def
/OriginY 36 def
%---------------- Variables -------------------

/DimX 4 def
/DimY 4 def
/Scale 1.2 def


% draw  Hex boards, any size ... but labels only up to 26x26
% based on code by Cameron Browne, revised by Jack vR, revised by RBH
%-------------- state initializations -------------------------
1 setlinejoin   % lines meet at a point  ==>    use round join
%---------------- constants -------------------
/Root3Div2  0.86602540378444 def
/Chars   {[(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)
           (n)(o)(p)(q)(r)(s)(t)(u)(v)(w)(x)(y)(z)]} def
/CharsUC {[(A)(B)(C)(D)(E)(F)(G)(H)(I)(J)(K)(L)(M)
           (N)(O)(P)(Q)(R)(S)(T)(U)(V)(W)(X)(Y)(Z)]} def
/Digits  {[(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)(12)(13)
           (14)(15)(16)(17)(18)(19)(20)(21)(22)(23)(24)(25)(26)]} def
/HexRadius      5 Scale mul def % hexagon center-to-corner distance 
/HexLineWidth 0.1 Scale mul def 
/GraphVertexSize 1.0 Scale mul def
/GraphLineWidth 0.5 Scale mul def
/CircleRadius 3.0 Scale mul def 
/CircleLineWidth 0.346 Scale mul def 
/PerimeterWidth 0.5 Scale mul def 
/TextHeight 4.5 def
/TextWidth TextHeight 0.45 mul def 
/BoardShade 0.8 def
/CoordinatesShade 0.5 def
/MarkerSize 1.2 def
/CellOrientation 1 def   % 1: flat bottom  0: pointed bottom
/CellCorner [ % 6 cell corners, wrt center 0 0, plus "up" and "down"
   [ HexRadius  neg       0                           ] 
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul neg ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul neg ]
   [ HexRadius            0                           ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul     ]
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul neg ]
] def
%----- name cell corner indices ... see below
/Left  0 def /DownLeft 1 def /DownRight 2 def 
/Right 3 def /UpRight  4 def /UpLeft    5 def 
/Up    6 def /Down     7 def
%-----------------------------------------------------
% cell orientations:  flat bottom    flat side
%-----------------------------------------------------
% flat bottom 
% board cell indices            cell corner/top/bottom indices
%             --
%           /    \
%        --   1,3  --                  5 -6- 4
%      /    \    /    \               /       \
%   --   1,2  --   2,3  --           0         3
% /    \    /    \    /    \          \       /
%   1,1  --   2,2  --   3,3            1 -7- 2
% \    /    \    /    \    /
%   --   2,1  --   3,2  --
%      \    /    \    /   
%        --   3,1  --     
%----------------------------------------------------
% flat side 
%    /  \  /  \  /  \                       5
%   | 11 || 12 || 13 ||                   /   6
%    \  /  \  /  \  /  \                 0     4
%     || 21 || 22 || 23 |                |     |
%       \  /  \  /  \  /  \              1     3
%        || 31 || 32 || 33 |              7   /
%-------------------------------------------2--------
%----------- procedures -------------
/ScalePoint { % stack: ... x y size ==> ...  x*size y*size
   3 dict begin /size exch def /y exch def /x exch def
   x size mul           y size mul
end } def

/FlatTopBoard { FlatSideCells } def

/FlatSideCells {  % redefine cell orientation for flat side
  /CellOrientation 0 def   
  /CellCorner [ % 6 cell corners, wrt center 0 0  %xcoord ycoord
    [HexRadius Root3Div2 mul neg  HexRadius 2 div     ]
    [HexRadius Root3Div2 mul neg  HexRadius 2 div neg ]
    [0                            HexRadius neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div ]
    [0                            HexRadius ]
    [HexRadius Root3Div2 2 div mul HexRadius 0.75 mul ]
    [HexRadius Root3Div2 2 div mul neg HexRadius 0.75 mul neg ]
  ] def
} def

/HexCenterPoint { % center of cell (i,j)
    2 dict begin /j exch def /i exch def
    CellOrientation 1 eq {
    OriginX i j add HexRadius mul 1.5 mul add %Ox + (i+j)*HR*1.5
    OriginY i j sub HexRadius mul Root3Div2 mul sub %Oy - (i-j)*HR*R3/2
    }{
    OriginX i 2 j mul add HexRadius mul Root3Div2 mul add  %Ox + (2i+j)*HR
    OriginY i 1 sub HexRadius mul 1.5 mul sub %Oy - i*HR*R3/2
    } ifelse
end } def
 
/HexLine { % a b c d
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint lineto
    stroke
} def

/HexCurve { % a b c d e f
    /f exch def
    /e exch def
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint e f HexCenterPoint HexRadius 2 mul arcto
    e f HexCenterPoint lineto
    stroke
} def

/HxgnCorner { 5 dict begin /corn exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    x CellCorner corn get 0 get add
    y CellCorner corn get 1 get add
end } def

/Go { 2 dict begin /corn exch def /mag exch def
   % rlineto in a cell orientation direction
   CellCorner corn get aload pop mag ScalePoint rlineto
end } def

/TurnGo { rotate 1.0 Left Go } def % call: degrees TurnGo
/MagTurnGo { rotate Left Go } def % call: mag degrees TurnGo

/HexagonPath { % call: i j HexagonPath
    newpath 
    UpRight HxgnCorner moveto 
    6 { 1.0 Left Go 60 rotate } repeat 
} def

/FillAndStroke { 2 dict begin /sh exch def /wdth exch def
    gsave sh setgray fill
    grestore 0 setgray wdth setlinewidth stroke
end } def

/ShadedHexagon { 3 dict begin /shade exch def /j exch def /i exch def
    i j HexagonPath
    0 shade FillAndStroke
end } def

/Hexagon { % stack: ... i j
    HexagonPath 
    HexLineWidth BoardShade FillAndStroke
} def

/SemiHexagonPath { % stack: ... top i j
    newpath 
    1 eq { Left HxgnCorner moveto 
        1.0 UpRight Go 1.0 Right Go 1.0 DownRight Go stroke }{
        Right HxgnCorner moveto 
        1.0 DownLeft Go 1.0 Left Go 1.0 UpLeft Go stroke
    } ifelse
} def

/HexBoardPerimeter {
    newpath
    1 DimY UpRight HxgnCorner moveto 1.0 Left Go                      
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 rotate %restore rotation
} def

%----------- Havannah coordinates ----------------------
%                   ..  ..  ..
%                 d1  c2  b3  a4
%                   c1  b2  a3
%                     b1  a2
%                       a1
/HavannahPosn { % convert to usual coordinate, so ... x y  =>  ... 1+DimX-x  y
    exch DimX 1 add exch sub exch 
} def

/HavannahBoardPerimeter {
    newpath
    1 DimX UpRight HxgnCorner moveto 1.0 Left Go                      
    6 {Base 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo } repeat
} def

/DrawHexBoard { 2 dict begin
    gsave
    HexBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexPLBoard { 6 dict begin %point-line board
    gsave
    BoardShade setgray newpath
    -1 DimY 1 add 0.5 mul HexCenterPoint moveto
    1 DimY HexCenterPoint lineto
    DimX 1 add 0.5 mul DimY 2 add HexCenterPoint lineto
    DimX DimY HexCenterPoint lineto
    DimX 2 add DimY 1 add 0.5 mul HexCenterPoint lineto
    DimX 1 HexCenterPoint lineto
    DimX 1 add 0.5 mul -1 HexCenterPoint lineto
    1 1 HexCenterPoint lineto
    closepath fill 0 setgray
    1 DimY HexCenterPoint moveto
    1 1 DimX { /i exch def 
        i 1 i DimY HexLine 
        DimY 1 add 0.5 mul -1 i 1 HexLine
        DimY 1 add 0.5 mul DimY 2 add i DimY HexLine } for
    1 1 DimY { /j exch def 
        1 j DimX j HexLine 
        -1 DimX 1 add 0.5 mul 1 j HexLine
        DimX 2 add DimX 1 add 0.5 mul DimX j HexLine } for
    /topx 1 def /topy 1 def /btmx 1 def /btmy 1 def
    DimX DimY add 3 sub {
      topx DimX lt {/topx 1 topx add def}{/topy 1 topy add def} ifelse 
      btmy DimY lt {/btmy 1 btmy add def}{/btmx 1 btmx add def} ifelse 
      topx topy btmx btmy HexLine
      } repeat
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j HexVertex
	} for } for
    grestore
end } def

/DrawHavannahBoard { 3 dict begin
    /Base DimX 1 add 2 idiv  def
    gsave
    HavannahBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 Base { /j exch def
	Base j 1 sub sub 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    1 1 Base 1 sub { /j exch def
	1 1 DimX j sub { /i exch def
	   i j Base add 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexBorder{ 6 dict begin /start exch def 
    /cells exch def /isBlack exch def /which exch def
    gsave
    which UpLeft eq {1 DimY 1 add start sub Up HxgnCorner moveto /d Left def /r 60 def} if
    which UpRight eq {start DimY Up HxgnCorner moveto /d Right def /r 300 def} if
    which DownLeft eq {DimX 1 add start sub 1 Down HxgnCorner moveto /d Left def /r 300 def} if
    which DownRight eq {DimX start Down HxgnCorner moveto /d Right def /r 60 def} if
    0.5 d Go 
    which UpRight eq which DownRight eq or {180 rotate} if
    r TurnGo 
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.5 360 r sub MagTurnGo 1.5 360 r sub 2 mul MagTurnGo
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.75 360 r sub MagTurnGo
    closepath isBlack 1 eq {gsave fill grestore} if stroke grestore
end } def

/NoDrawHexBoard {  % dummy, used in creating bounding box
} def

/HexBoardBorders { 1 dict begin
    /upperLeftBlack exch def
    PerimeterWidth setlinewidth 0 setgray
    UpLeft    upperLeftBlack       DimY 1 DrawHexBorder
    UpRight   1 upperLeftBlack sub DimX 1 DrawHexBorder
    DownRight upperLeftBlack       DimY 1 DrawHexBorder
    DownLeft  1 upperLeftBlack sub DimX 1 DrawHexBorder
end } def

/YBoardPerimeter {
    newpath 1 1 DownRight HxgnCorner moveto 180 rotate
    3 { DimX 1 sub { 300 TurnGo 60 TurnGo } repeat 
        60 TurnGo 60 TurnGo} 
    repeat % now restore initial rotation state
    180 rotate % closepath
} def

/DrawYBoard { 2 dict begin
    YBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimX {/j exch def
        1 1 DimX 1 add j sub {/i exch def
	    i j 1 SemiHexagonPath stroke
        } for } for
end } def

/FontSelect { % bold italic FontSelect
    2 dict begin /italic exch def /bold exch def
    bold {
	italic 
	{ /Times-BoldItalic findfont TextHeight scalefont setfont } 
	{ /Times-Bold findfont TextHeight scalefont setfont }
	ifelse} 
        {
	italic {/Times-Italic findfont TextHeight scalefont setfont} 
	{ /Times findfont TextHeight scalefont setfont }
	ifelse}
    ifelse
end } def
	    
/LabelString {   % call: i j (str) strlen LabelString
%  to use with board rotation, remove comments
    6 dict begin /strlen exch def /str exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint /y exch def /x exch def
    %BoardRotation rotate
    x y moveto 
    %360 BoardRotation sub rotate
    TextWidth strlen mul 0.5 mul neg TextHeight 0.33 mul neg rmoveto
    str show 
end } def

/AbsLabelString { 4 dict begin
    /strlen exch def /str exch def /y exch def /x exch def
    newpath
    x AbsCoordX TextWidth strlen mul 0.5 mul sub
    y AbsCoordY TextHeight 0.33 mul sub
    moveto
    str
    show
end } def

/LabelStringVerb { % i j (str) strlen shade bold italic LabelStringVerb
    7 dict begin /italic exch def /bold exch def /shade exch def
    /strlen exch def /str exch def /j exch def /i exch def
    bold italic FontSelect shade setgray
    i j str strlen LabelString
end } def

/HexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimX { /i exch def
	i 0          Chars i 1 sub get 1 LabelString
	i DimY 1 add Chars i 1 sub get 1 LabelString
    } for
    1 1 DimY { /j exch def
	0 j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
	DimX 1 add j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HavannahBoardCoordinates { 3 dict begin
    false true FontSelect CoordinatesShade setgray
    /Base DimX 1 add 2 idiv  def
    1 1 Base { /i exch def
	i 0 HavannahPosn Chars  i 1 sub get 1 LabelString
	0 i HavannahPosn Digits i 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
    1 1 Base 1 sub { /i exch def
	i Base add i HavannahPosn Chars  i Base add 1 sub get 1 LabelString
	i i Base add HavannahPosn Digits i Base add 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/AltHexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimY { /j exch def
	0 j Chars j 1 sub get 1 LabelString
        %DimX 1 add j Chars j 1 sub get 1 LabelString
    } for
    1 1 DimX { /i exch def
	i 0 Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
	%i DimY 1 add Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HexDot { 3 dict begin /size exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint size 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexWhiteMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexWhitePiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexBlackMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexBlackPiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    1 setgray 0 setlinewidth fill
end } def

/HexDoubleMarker { 6 dict begin
    /shaderight exch def /shadeleft exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    gsave
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    shadeleft setgray 0 setlinewidth fill
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    shaderight setgray 0 setlinewidth fill
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    grestore
end } def

/HexBlackWhiteMarker { 0.0 1.0 HexDoubleMarker } def

/HexWhiteBlackMarker { 1.0 0.0 HexDoubleMarker } def
        
/HexMarker { 2 dict begin /j exch def /i exch def
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setlinewidth fill
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke  
end } def

/HexBlackMarker { 2 dict begin /j exch def /i exch def
    0 setgray
    i j HexMarker
end } def

/HexWhiteMarker { 2 dict begin /j exch def /i exch def
    1 setgray
    i j HexMarker
end } def
    
/HexPiece { 3 dict begin /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/MagicStone { 4 dict begin 
    /size exch def /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 1.3 mul size mul 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/HexWhitePiece { 1.0 HexPiece } def

/HexBlackPiece { 0.0 HexPiece } def

/HexWhiteLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def
    i j HexWhitePiece
    i j str strlen 0.0 true true LabelStringVerb
end } def

/HexBlackLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def 
    i j HexBlackPiece
    i j str strlen 1.0 true true LabelStringVerb
end } def

/AbsCoordX { 1 dict begin /x exch def
    OriginX x Scale mul add
end } def

/AbsCoordY { 1 dict begin /y exch def
    OriginY y Scale mul add
end } def

/DrawBox { /maxy exch def /maxx exch def /miny exch def /minx exch def
    newpath
    minx miny moveto
    maxx minx sub 0 rlineto
    0 maxy miny sub rlineto
    minx maxx sub 0 rlineto
    0 miny maxy sub rlineto
    HexLineWidth setlinewidth
    0 setgray
    stroke
} def

/HexVertex { 2 dict begin /j exch def /i exch def
    i j GraphVertexSize HexDot
end } def

/HexLine { 4 dict begin /j2 exch def /i2 exch def /j1 exch def /i1 exch def
    GraphLineWidth setlinewidth
    0 setgray
    newpath
    i1 j1 HexCenterPoint moveto
    i2 j2 HexCenterPoint lineto
    stroke
end } def

%%---------------- Program -------------------


FlatTopBoard
DrawHexBoard
1 HexBoardBorders
2 3 HexWhiteMarker
3 2 HexWhiteMarker


%------------ Trailer --------------

showpage

%%EndDocument
 @endspecial Black Black eop end
%%Page: 12 12
TeXDict begin 12 11 bop Black 181 -165 a Fj(Iv)-5 b(erson)55
b(exam)h(2016)p 1555 -165 4439 6 v 4656 w Fi(12)p Black
347 347 a(If)i(white)j(pla)-5 b(ys)60 b(\014rst)g(in)f(an)-5
b(y)60 b(of)f(the)h(unmark)-5 b(ed)61 b(cells)f(b)5 b(elo)-5
b(w)61 b(left,)f(then)g(blac)-5 b(k)61 b(can)e(win.)88
b(By)181 548 y(also)58 b(considering)h(the)f(symmetric)g(blac)-5
b(k)59 b(strategy)-14 b(,)59 b(w)-5 b(e)58 b(no)-5 b(w)58
b(ha)-5 b(v)g(e)58 b(10)g(losing)g(op)5 b(enings)58 b(\(b)5
b(elo)-5 b(w)181 748 y(righ)g(t\).)347 2645 y @beginspecial
0 @llx 0 @lly 66 @urx 47 @ury 1700 @rwi @setspecial
%%BeginDocument: fz/pix/4.1strat.eps
%!PS-Adobe-3.0
%%Creator: Jack van Rijswijck, thanks to Cameron Browne
%%BoundingBox: 0 0 66 47
%%Pages: 0
%%EndComments

/OriginX -6 def
/OriginY 36 def
%---------------- Variables -------------------

/DimX 4 def
/DimY 4 def
/Scale 1.2 def


% draw  Hex boards, any size ... but labels only up to 26x26
% based on code by Cameron Browne, revised by Jack vR, revised by RBH
%-------------- state initializations -------------------------
1 setlinejoin   % lines meet at a point  ==>    use round join
%---------------- constants -------------------
/Root3Div2  0.86602540378444 def
/Chars   {[(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)
           (n)(o)(p)(q)(r)(s)(t)(u)(v)(w)(x)(y)(z)]} def
/CharsUC {[(A)(B)(C)(D)(E)(F)(G)(H)(I)(J)(K)(L)(M)
           (N)(O)(P)(Q)(R)(S)(T)(U)(V)(W)(X)(Y)(Z)]} def
/Digits  {[(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)(12)(13)
           (14)(15)(16)(17)(18)(19)(20)(21)(22)(23)(24)(25)(26)]} def
/HexRadius      5 Scale mul def % hexagon center-to-corner distance 
/HexLineWidth 0.1 Scale mul def 
/GraphVertexSize 1.0 Scale mul def
/GraphLineWidth 0.5 Scale mul def
/CircleRadius 3.0 Scale mul def 
/CircleLineWidth 0.346 Scale mul def 
/PerimeterWidth 0.5 Scale mul def 
/TextHeight 4.5 def
/TextWidth TextHeight 0.45 mul def 
/BoardShade 0.8 def
/CoordinatesShade 0.5 def
/MarkerSize 1.2 def
/CellOrientation 1 def   % 1: flat bottom  0: pointed bottom
/CellCorner [ % 6 cell corners, wrt center 0 0, plus "up" and "down"
   [ HexRadius  neg       0                           ] 
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul neg ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul neg ]
   [ HexRadius            0                           ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul     ]
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul neg ]
] def
%----- name cell corner indices ... see below
/Left  0 def /DownLeft 1 def /DownRight 2 def 
/Right 3 def /UpRight  4 def /UpLeft    5 def 
/Up    6 def /Down     7 def
%-----------------------------------------------------
% cell orientations:  flat bottom    flat side
%-----------------------------------------------------
% flat bottom 
% board cell indices            cell corner/top/bottom indices
%             --
%           /    \
%        --   1,3  --                  5 -6- 4
%      /    \    /    \               /       \
%   --   1,2  --   2,3  --           0         3
% /    \    /    \    /    \          \       /
%   1,1  --   2,2  --   3,3            1 -7- 2
% \    /    \    /    \    /
%   --   2,1  --   3,2  --
%      \    /    \    /   
%        --   3,1  --     
%----------------------------------------------------
% flat side 
%    /  \  /  \  /  \                       5
%   | 11 || 12 || 13 ||                   /   6
%    \  /  \  /  \  /  \                 0     4
%     || 21 || 22 || 23 |                |     |
%       \  /  \  /  \  /  \              1     3
%        || 31 || 32 || 33 |              7   /
%-------------------------------------------2--------
%----------- procedures -------------
/ScalePoint { % stack: ... x y size ==> ...  x*size y*size
   3 dict begin /size exch def /y exch def /x exch def
   x size mul           y size mul
end } def

/FlatTopBoard { FlatSideCells } def

/FlatSideCells {  % redefine cell orientation for flat side
  /CellOrientation 0 def   
  /CellCorner [ % 6 cell corners, wrt center 0 0  %xcoord ycoord
    [HexRadius Root3Div2 mul neg  HexRadius 2 div     ]
    [HexRadius Root3Div2 mul neg  HexRadius 2 div neg ]
    [0                            HexRadius neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div ]
    [0                            HexRadius ]
    [HexRadius Root3Div2 2 div mul HexRadius 0.75 mul ]
    [HexRadius Root3Div2 2 div mul neg HexRadius 0.75 mul neg ]
  ] def
} def

/HexCenterPoint { % center of cell (i,j)
    2 dict begin /j exch def /i exch def
    CellOrientation 1 eq {
    OriginX i j add HexRadius mul 1.5 mul add %Ox + (i+j)*HR*1.5
    OriginY i j sub HexRadius mul Root3Div2 mul sub %Oy - (i-j)*HR*R3/2
    }{
    OriginX i 2 j mul add HexRadius mul Root3Div2 mul add  %Ox + (2i+j)*HR
    OriginY i 1 sub HexRadius mul 1.5 mul sub %Oy - i*HR*R3/2
    } ifelse
end } def
 
/HexLine { % a b c d
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint lineto
    stroke
} def

/HexCurve { % a b c d e f
    /f exch def
    /e exch def
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint e f HexCenterPoint HexRadius 2 mul arcto
    e f HexCenterPoint lineto
    stroke
} def

/HxgnCorner { 5 dict begin /corn exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    x CellCorner corn get 0 get add
    y CellCorner corn get 1 get add
end } def

/Go { 2 dict begin /corn exch def /mag exch def
   % rlineto in a cell orientation direction
   CellCorner corn get aload pop mag ScalePoint rlineto
end } def

/TurnGo { rotate 1.0 Left Go } def % call: degrees TurnGo
/MagTurnGo { rotate Left Go } def % call: mag degrees TurnGo

/HexagonPath { % call: i j HexagonPath
    newpath 
    UpRight HxgnCorner moveto 
    6 { 1.0 Left Go 60 rotate } repeat 
} def

/FillAndStroke { 2 dict begin /sh exch def /wdth exch def
    gsave sh setgray fill
    grestore 0 setgray wdth setlinewidth stroke
end } def

/ShadedHexagon { 3 dict begin /shade exch def /j exch def /i exch def
    i j HexagonPath
    0 shade FillAndStroke
end } def

/Hexagon { % stack: ... i j
    HexagonPath 
    HexLineWidth BoardShade FillAndStroke
} def

/SemiHexagonPath { % stack: ... top i j
    newpath 
    1 eq { Left HxgnCorner moveto 
        1.0 UpRight Go 1.0 Right Go 1.0 DownRight Go stroke }{
        Right HxgnCorner moveto 
        1.0 DownLeft Go 1.0 Left Go 1.0 UpLeft Go stroke
    } ifelse
} def

/HexBoardPerimeter {
    newpath
    1 DimY UpRight HxgnCorner moveto 1.0 Left Go                      
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 rotate %restore rotation
} def

%----------- Havannah coordinates ----------------------
%                   ..  ..  ..
%                 d1  c2  b3  a4
%                   c1  b2  a3
%                     b1  a2
%                       a1
/HavannahPosn { % convert to usual coordinate, so ... x y  =>  ... 1+DimX-x  y
    exch DimX 1 add exch sub exch 
} def

/HavannahBoardPerimeter {
    newpath
    1 DimX UpRight HxgnCorner moveto 1.0 Left Go                      
    6 {Base 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo } repeat
} def

/DrawHexBoard { 2 dict begin
    gsave
    HexBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexPLBoard { 6 dict begin %point-line board
    gsave
    BoardShade setgray newpath
    -1 DimY 1 add 0.5 mul HexCenterPoint moveto
    1 DimY HexCenterPoint lineto
    DimX 1 add 0.5 mul DimY 2 add HexCenterPoint lineto
    DimX DimY HexCenterPoint lineto
    DimX 2 add DimY 1 add 0.5 mul HexCenterPoint lineto
    DimX 1 HexCenterPoint lineto
    DimX 1 add 0.5 mul -1 HexCenterPoint lineto
    1 1 HexCenterPoint lineto
    closepath fill 0 setgray
    1 DimY HexCenterPoint moveto
    1 1 DimX { /i exch def 
        i 1 i DimY HexLine 
        DimY 1 add 0.5 mul -1 i 1 HexLine
        DimY 1 add 0.5 mul DimY 2 add i DimY HexLine } for
    1 1 DimY { /j exch def 
        1 j DimX j HexLine 
        -1 DimX 1 add 0.5 mul 1 j HexLine
        DimX 2 add DimX 1 add 0.5 mul DimX j HexLine } for
    /topx 1 def /topy 1 def /btmx 1 def /btmy 1 def
    DimX DimY add 3 sub {
      topx DimX lt {/topx 1 topx add def}{/topy 1 topy add def} ifelse 
      btmy DimY lt {/btmy 1 btmy add def}{/btmx 1 btmx add def} ifelse 
      topx topy btmx btmy HexLine
      } repeat
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j HexVertex
	} for } for
    grestore
end } def

/DrawHavannahBoard { 3 dict begin
    /Base DimX 1 add 2 idiv  def
    gsave
    HavannahBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 Base { /j exch def
	Base j 1 sub sub 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    1 1 Base 1 sub { /j exch def
	1 1 DimX j sub { /i exch def
	   i j Base add 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexBorder{ 6 dict begin /start exch def 
    /cells exch def /isBlack exch def /which exch def
    gsave
    which UpLeft eq {1 DimY 1 add start sub Up HxgnCorner moveto /d Left def /r 60 def} if
    which UpRight eq {start DimY Up HxgnCorner moveto /d Right def /r 300 def} if
    which DownLeft eq {DimX 1 add start sub 1 Down HxgnCorner moveto /d Left def /r 300 def} if
    which DownRight eq {DimX start Down HxgnCorner moveto /d Right def /r 60 def} if
    0.5 d Go 
    which UpRight eq which DownRight eq or {180 rotate} if
    r TurnGo 
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.5 360 r sub MagTurnGo 1.5 360 r sub 2 mul MagTurnGo
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.75 360 r sub MagTurnGo
    closepath isBlack 1 eq {gsave fill grestore} if stroke grestore
end } def

/NoDrawHexBoard {  % dummy, used in creating bounding box
} def

/HexBoardBorders { 1 dict begin
    /upperLeftBlack exch def
    PerimeterWidth setlinewidth 0 setgray
    UpLeft    upperLeftBlack       DimY 1 DrawHexBorder
    UpRight   1 upperLeftBlack sub DimX 1 DrawHexBorder
    DownRight upperLeftBlack       DimY 1 DrawHexBorder
    DownLeft  1 upperLeftBlack sub DimX 1 DrawHexBorder
end } def

/YBoardPerimeter {
    newpath 1 1 DownRight HxgnCorner moveto 180 rotate
    3 { DimX 1 sub { 300 TurnGo 60 TurnGo } repeat 
        60 TurnGo 60 TurnGo} 
    repeat % now restore initial rotation state
    180 rotate % closepath
} def

/DrawYBoard { 2 dict begin
    YBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimX {/j exch def
        1 1 DimX 1 add j sub {/i exch def
	    i j 1 SemiHexagonPath stroke
        } for } for
end } def

/FontSelect { % bold italic FontSelect
    2 dict begin /italic exch def /bold exch def
    bold {
	italic 
	{ /Times-BoldItalic findfont TextHeight scalefont setfont } 
	{ /Times-Bold findfont TextHeight scalefont setfont }
	ifelse} 
        {
	italic {/Times-Italic findfont TextHeight scalefont setfont} 
	{ /Times findfont TextHeight scalefont setfont }
	ifelse}
    ifelse
end } def
	    
/LabelString {   % call: i j (str) strlen LabelString
%  to use with board rotation, remove comments
    6 dict begin /strlen exch def /str exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint /y exch def /x exch def
    %BoardRotation rotate
    x y moveto 
    %360 BoardRotation sub rotate
    TextWidth strlen mul 0.5 mul neg TextHeight 0.33 mul neg rmoveto
    str show 
end } def

/AbsLabelString { 4 dict begin
    /strlen exch def /str exch def /y exch def /x exch def
    newpath
    x AbsCoordX TextWidth strlen mul 0.5 mul sub
    y AbsCoordY TextHeight 0.33 mul sub
    moveto
    str
    show
end } def

/LabelStringVerb { % i j (str) strlen shade bold italic LabelStringVerb
    7 dict begin /italic exch def /bold exch def /shade exch def
    /strlen exch def /str exch def /j exch def /i exch def
    bold italic FontSelect shade setgray
    i j str strlen LabelString
end } def

/HexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimX { /i exch def
	i 0          Chars i 1 sub get 1 LabelString
	i DimY 1 add Chars i 1 sub get 1 LabelString
    } for
    1 1 DimY { /j exch def
	0 j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
	DimX 1 add j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HavannahBoardCoordinates { 3 dict begin
    false true FontSelect CoordinatesShade setgray
    /Base DimX 1 add 2 idiv  def
    1 1 Base { /i exch def
	i 0 HavannahPosn Chars  i 1 sub get 1 LabelString
	0 i HavannahPosn Digits i 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
    1 1 Base 1 sub { /i exch def
	i Base add i HavannahPosn Chars  i Base add 1 sub get 1 LabelString
	i i Base add HavannahPosn Digits i Base add 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/AltHexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimY { /j exch def
	0 j Chars j 1 sub get 1 LabelString
        %DimX 1 add j Chars j 1 sub get 1 LabelString
    } for
    1 1 DimX { /i exch def
	i 0 Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
	%i DimY 1 add Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HexDot { 3 dict begin /size exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint size 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexWhiteMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexWhitePiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexBlackMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexBlackPiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    1 setgray 0 setlinewidth fill
end } def

/HexDoubleMarker { 6 dict begin
    /shaderight exch def /shadeleft exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    gsave
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    shadeleft setgray 0 setlinewidth fill
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    shaderight setgray 0 setlinewidth fill
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    grestore
end } def

/HexBlackWhiteMarker { 0.0 1.0 HexDoubleMarker } def

/HexWhiteBlackMarker { 1.0 0.0 HexDoubleMarker } def
        
/HexMarker { 2 dict begin /j exch def /i exch def
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setlinewidth fill
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke  
end } def

/HexBlackMarker { 2 dict begin /j exch def /i exch def
    0 setgray
    i j HexMarker
end } def

/HexWhiteMarker { 2 dict begin /j exch def /i exch def
    1 setgray
    i j HexMarker
end } def
    
/HexPiece { 3 dict begin /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/MagicStone { 4 dict begin 
    /size exch def /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 1.3 mul size mul 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/HexWhitePiece { 1.0 HexPiece } def

/HexBlackPiece { 0.0 HexPiece } def

/HexWhiteLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def
    i j HexWhitePiece
    i j str strlen 0.0 true true LabelStringVerb
end } def

/HexBlackLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def 
    i j HexBlackPiece
    i j str strlen 1.0 true true LabelStringVerb
end } def

/AbsCoordX { 1 dict begin /x exch def
    OriginX x Scale mul add
end } def

/AbsCoordY { 1 dict begin /y exch def
    OriginY y Scale mul add
end } def

/DrawBox { /maxy exch def /maxx exch def /miny exch def /minx exch def
    newpath
    minx miny moveto
    maxx minx sub 0 rlineto
    0 maxy miny sub rlineto
    minx maxx sub 0 rlineto
    0 miny maxy sub rlineto
    HexLineWidth setlinewidth
    0 setgray
    stroke
} def

/HexVertex { 2 dict begin /j exch def /i exch def
    i j GraphVertexSize HexDot
end } def

/HexLine { 4 dict begin /j2 exch def /i2 exch def /j1 exch def /i1 exch def
    GraphLineWidth setlinewidth
    0 setgray
    newpath
    i1 j1 HexCenterPoint moveto
    i2 j2 HexCenterPoint lineto
    stroke
end } def

%%---------------- Program -------------------


FlatTopBoard
DrawHexBoard
1 HexBoardBorders
AltHexBoardCoordinates

2 3 1 4 0 4 HexCurve
2 3 1 3 0 4 HexCurve
2 3 2 4 3 4 HexCurve
2 3 3 3 3 4 HexCurve
3 4 4 3 5 3 HexCurve
3 4 4 4 5 3 HexCurve
3 2 4 1 5 1 HexCurve
3 2 4 2 5 1 HexCurve
2 3 3 2 HexLine
2 3 HexBlackPiece
3 4 HexBlackMarker
3 2 HexBlackMarker


%------------ Trailer --------------

showpage

%%EndDocument
 @endspecial 2417 w @beginspecial 0 @llx 0 @lly 66 @urx
47 @ury 1700 @rwi @setspecial
%%BeginDocument: fz/pix/4x4.winners1.eps
%!PS-Adobe-3.0
%%Creator: Jack van Rijswijck, thanks to Cameron Browne
%%BoundingBox: 0 0 66 47
%%Pages: 0
%%EndComments

/OriginX -6 def
/OriginY 36 def
%---------------- Variables -------------------

/DimX 4 def
/DimY 4 def
/Scale 1.2 def


% draw  Hex boards, any size ... but labels only up to 26x26
% based on code by Cameron Browne, revised by Jack vR, revised by RBH
%-------------- state initializations -------------------------
1 setlinejoin   % lines meet at a point  ==>    use round join
%---------------- constants -------------------
/Root3Div2  0.86602540378444 def
/Chars   {[(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)
           (n)(o)(p)(q)(r)(s)(t)(u)(v)(w)(x)(y)(z)]} def
/CharsUC {[(A)(B)(C)(D)(E)(F)(G)(H)(I)(J)(K)(L)(M)
           (N)(O)(P)(Q)(R)(S)(T)(U)(V)(W)(X)(Y)(Z)]} def
/Digits  {[(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)(12)(13)
           (14)(15)(16)(17)(18)(19)(20)(21)(22)(23)(24)(25)(26)]} def
/HexRadius      5 Scale mul def % hexagon center-to-corner distance 
/HexLineWidth 0.1 Scale mul def 
/GraphVertexSize 1.0 Scale mul def
/GraphLineWidth 0.5 Scale mul def
/CircleRadius 3.0 Scale mul def 
/CircleLineWidth 0.346 Scale mul def 
/PerimeterWidth 0.5 Scale mul def 
/TextHeight 4.5 def
/TextWidth TextHeight 0.45 mul def 
/BoardShade 0.8 def
/CoordinatesShade 0.5 def
/MarkerSize 1.2 def
/CellOrientation 1 def   % 1: flat bottom  0: pointed bottom
/CellCorner [ % 6 cell corners, wrt center 0 0, plus "up" and "down"
   [ HexRadius  neg       0                           ] 
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul neg ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul neg ]
   [ HexRadius            0                           ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul     ]
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul neg ]
] def
%----- name cell corner indices ... see below
/Left  0 def /DownLeft 1 def /DownRight 2 def 
/Right 3 def /UpRight  4 def /UpLeft    5 def 
/Up    6 def /Down     7 def
%-----------------------------------------------------
% cell orientations:  flat bottom    flat side
%-----------------------------------------------------
% flat bottom 
% board cell indices            cell corner/top/bottom indices
%             --
%           /    \
%        --   1,3  --                  5 -6- 4
%      /    \    /    \               /       \
%   --   1,2  --   2,3  --           0         3
% /    \    /    \    /    \          \       /
%   1,1  --   2,2  --   3,3            1 -7- 2
% \    /    \    /    \    /
%   --   2,1  --   3,2  --
%      \    /    \    /   
%        --   3,1  --     
%----------------------------------------------------
% flat side 
%    /  \  /  \  /  \                       5
%   | 11 || 12 || 13 ||                   /   6
%    \  /  \  /  \  /  \                 0     4
%     || 21 || 22 || 23 |                |     |
%       \  /  \  /  \  /  \              1     3
%        || 31 || 32 || 33 |              7   /
%-------------------------------------------2--------
%----------- procedures -------------
/ScalePoint { % stack: ... x y size ==> ...  x*size y*size
   3 dict begin /size exch def /y exch def /x exch def
   x size mul           y size mul
end } def

/FlatTopBoard { FlatSideCells } def

/FlatSideCells {  % redefine cell orientation for flat side
  /CellOrientation 0 def   
  /CellCorner [ % 6 cell corners, wrt center 0 0  %xcoord ycoord
    [HexRadius Root3Div2 mul neg  HexRadius 2 div     ]
    [HexRadius Root3Div2 mul neg  HexRadius 2 div neg ]
    [0                            HexRadius neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div ]
    [0                            HexRadius ]
    [HexRadius Root3Div2 2 div mul HexRadius 0.75 mul ]
    [HexRadius Root3Div2 2 div mul neg HexRadius 0.75 mul neg ]
  ] def
} def

/HexCenterPoint { % center of cell (i,j)
    2 dict begin /j exch def /i exch def
    CellOrientation 1 eq {
    OriginX i j add HexRadius mul 1.5 mul add %Ox + (i+j)*HR*1.5
    OriginY i j sub HexRadius mul Root3Div2 mul sub %Oy - (i-j)*HR*R3/2
    }{
    OriginX i 2 j mul add HexRadius mul Root3Div2 mul add  %Ox + (2i+j)*HR
    OriginY i 1 sub HexRadius mul 1.5 mul sub %Oy - i*HR*R3/2
    } ifelse
end } def
 
/HexLine { % a b c d
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint lineto
    stroke
} def

/HexCurve { % a b c d e f
    /f exch def
    /e exch def
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint e f HexCenterPoint HexRadius 2 mul arcto
    e f HexCenterPoint lineto
    stroke
} def

/HxgnCorner { 5 dict begin /corn exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    x CellCorner corn get 0 get add
    y CellCorner corn get 1 get add
end } def

/Go { 2 dict begin /corn exch def /mag exch def
   % rlineto in a cell orientation direction
   CellCorner corn get aload pop mag ScalePoint rlineto
end } def

/TurnGo { rotate 1.0 Left Go } def % call: degrees TurnGo
/MagTurnGo { rotate Left Go } def % call: mag degrees TurnGo

/HexagonPath { % call: i j HexagonPath
    newpath 
    UpRight HxgnCorner moveto 
    6 { 1.0 Left Go 60 rotate } repeat 
} def

/FillAndStroke { 2 dict begin /sh exch def /wdth exch def
    gsave sh setgray fill
    grestore 0 setgray wdth setlinewidth stroke
end } def

/ShadedHexagon { 3 dict begin /shade exch def /j exch def /i exch def
    i j HexagonPath
    0 shade FillAndStroke
end } def

/Hexagon { % stack: ... i j
    HexagonPath 
    HexLineWidth BoardShade FillAndStroke
} def

/SemiHexagonPath { % stack: ... top i j
    newpath 
    1 eq { Left HxgnCorner moveto 
        1.0 UpRight Go 1.0 Right Go 1.0 DownRight Go stroke }{
        Right HxgnCorner moveto 
        1.0 DownLeft Go 1.0 Left Go 1.0 UpLeft Go stroke
    } ifelse
} def

/HexBoardPerimeter {
    newpath
    1 DimY UpRight HxgnCorner moveto 1.0 Left Go                      
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 rotate %restore rotation
} def

%----------- Havannah coordinates ----------------------
%                   ..  ..  ..
%                 d1  c2  b3  a4
%                   c1  b2  a3
%                     b1  a2
%                       a1
/HavannahPosn { % convert to usual coordinate, so ... x y  =>  ... 1+DimX-x  y
    exch DimX 1 add exch sub exch 
} def

/HavannahBoardPerimeter {
    newpath
    1 DimX UpRight HxgnCorner moveto 1.0 Left Go                      
    6 {Base 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo } repeat
} def

/DrawHexBoard { 2 dict begin
    gsave
    HexBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexPLBoard { 6 dict begin %point-line board
    gsave
    BoardShade setgray newpath
    -1 DimY 1 add 0.5 mul HexCenterPoint moveto
    1 DimY HexCenterPoint lineto
    DimX 1 add 0.5 mul DimY 2 add HexCenterPoint lineto
    DimX DimY HexCenterPoint lineto
    DimX 2 add DimY 1 add 0.5 mul HexCenterPoint lineto
    DimX 1 HexCenterPoint lineto
    DimX 1 add 0.5 mul -1 HexCenterPoint lineto
    1 1 HexCenterPoint lineto
    closepath fill 0 setgray
    1 DimY HexCenterPoint moveto
    1 1 DimX { /i exch def 
        i 1 i DimY HexLine 
        DimY 1 add 0.5 mul -1 i 1 HexLine
        DimY 1 add 0.5 mul DimY 2 add i DimY HexLine } for
    1 1 DimY { /j exch def 
        1 j DimX j HexLine 
        -1 DimX 1 add 0.5 mul 1 j HexLine
        DimX 2 add DimX 1 add 0.5 mul DimX j HexLine } for
    /topx 1 def /topy 1 def /btmx 1 def /btmy 1 def
    DimX DimY add 3 sub {
      topx DimX lt {/topx 1 topx add def}{/topy 1 topy add def} ifelse 
      btmy DimY lt {/btmy 1 btmy add def}{/btmx 1 btmx add def} ifelse 
      topx topy btmx btmy HexLine
      } repeat
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j HexVertex
	} for } for
    grestore
end } def

/DrawHavannahBoard { 3 dict begin
    /Base DimX 1 add 2 idiv  def
    gsave
    HavannahBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 Base { /j exch def
	Base j 1 sub sub 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    1 1 Base 1 sub { /j exch def
	1 1 DimX j sub { /i exch def
	   i j Base add 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexBorder{ 6 dict begin /start exch def 
    /cells exch def /isBlack exch def /which exch def
    gsave
    which UpLeft eq {1 DimY 1 add start sub Up HxgnCorner moveto /d Left def /r 60 def} if
    which UpRight eq {start DimY Up HxgnCorner moveto /d Right def /r 300 def} if
    which DownLeft eq {DimX 1 add start sub 1 Down HxgnCorner moveto /d Left def /r 300 def} if
    which DownRight eq {DimX start Down HxgnCorner moveto /d Right def /r 60 def} if
    0.5 d Go 
    which UpRight eq which DownRight eq or {180 rotate} if
    r TurnGo 
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.5 360 r sub MagTurnGo 1.5 360 r sub 2 mul MagTurnGo
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.75 360 r sub MagTurnGo
    closepath isBlack 1 eq {gsave fill grestore} if stroke grestore
end } def

/NoDrawHexBoard {  % dummy, used in creating bounding box
} def

/HexBoardBorders { 1 dict begin
    /upperLeftBlack exch def
    PerimeterWidth setlinewidth 0 setgray
    UpLeft    upperLeftBlack       DimY 1 DrawHexBorder
    UpRight   1 upperLeftBlack sub DimX 1 DrawHexBorder
    DownRight upperLeftBlack       DimY 1 DrawHexBorder
    DownLeft  1 upperLeftBlack sub DimX 1 DrawHexBorder
end } def

/YBoardPerimeter {
    newpath 1 1 DownRight HxgnCorner moveto 180 rotate
    3 { DimX 1 sub { 300 TurnGo 60 TurnGo } repeat 
        60 TurnGo 60 TurnGo} 
    repeat % now restore initial rotation state
    180 rotate % closepath
} def

/DrawYBoard { 2 dict begin
    YBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimX {/j exch def
        1 1 DimX 1 add j sub {/i exch def
	    i j 1 SemiHexagonPath stroke
        } for } for
end } def

/FontSelect { % bold italic FontSelect
    2 dict begin /italic exch def /bold exch def
    bold {
	italic 
	{ /Times-BoldItalic findfont TextHeight scalefont setfont } 
	{ /Times-Bold findfont TextHeight scalefont setfont }
	ifelse} 
        {
	italic {/Times-Italic findfont TextHeight scalefont setfont} 
	{ /Times findfont TextHeight scalefont setfont }
	ifelse}
    ifelse
end } def
	    
/LabelString {   % call: i j (str) strlen LabelString
%  to use with board rotation, remove comments
    6 dict begin /strlen exch def /str exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint /y exch def /x exch def
    %BoardRotation rotate
    x y moveto 
    %360 BoardRotation sub rotate
    TextWidth strlen mul 0.5 mul neg TextHeight 0.33 mul neg rmoveto
    str show 
end } def

/AbsLabelString { 4 dict begin
    /strlen exch def /str exch def /y exch def /x exch def
    newpath
    x AbsCoordX TextWidth strlen mul 0.5 mul sub
    y AbsCoordY TextHeight 0.33 mul sub
    moveto
    str
    show
end } def

/LabelStringVerb { % i j (str) strlen shade bold italic LabelStringVerb
    7 dict begin /italic exch def /bold exch def /shade exch def
    /strlen exch def /str exch def /j exch def /i exch def
    bold italic FontSelect shade setgray
    i j str strlen LabelString
end } def

/HexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimX { /i exch def
	i 0          Chars i 1 sub get 1 LabelString
	i DimY 1 add Chars i 1 sub get 1 LabelString
    } for
    1 1 DimY { /j exch def
	0 j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
	DimX 1 add j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HavannahBoardCoordinates { 3 dict begin
    false true FontSelect CoordinatesShade setgray
    /Base DimX 1 add 2 idiv  def
    1 1 Base { /i exch def
	i 0 HavannahPosn Chars  i 1 sub get 1 LabelString
	0 i HavannahPosn Digits i 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
    1 1 Base 1 sub { /i exch def
	i Base add i HavannahPosn Chars  i Base add 1 sub get 1 LabelString
	i i Base add HavannahPosn Digits i Base add 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/AltHexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimY { /j exch def
	0 j Chars j 1 sub get 1 LabelString
        %DimX 1 add j Chars j 1 sub get 1 LabelString
    } for
    1 1 DimX { /i exch def
	i 0 Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
	%i DimY 1 add Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HexDot { 3 dict begin /size exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint size 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexWhiteMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexWhitePiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexBlackMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexBlackPiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    1 setgray 0 setlinewidth fill
end } def

/HexDoubleMarker { 6 dict begin
    /shaderight exch def /shadeleft exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    gsave
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    shadeleft setgray 0 setlinewidth fill
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    shaderight setgray 0 setlinewidth fill
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    grestore
end } def

/HexBlackWhiteMarker { 0.0 1.0 HexDoubleMarker } def

/HexWhiteBlackMarker { 1.0 0.0 HexDoubleMarker } def
        
/HexMarker { 2 dict begin /j exch def /i exch def
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setlinewidth fill
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke  
end } def

/HexBlackMarker { 2 dict begin /j exch def /i exch def
    0 setgray
    i j HexMarker
end } def

/HexWhiteMarker { 2 dict begin /j exch def /i exch def
    1 setgray
    i j HexMarker
end } def
    
/HexPiece { 3 dict begin /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/MagicStone { 4 dict begin 
    /size exch def /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 1.3 mul size mul 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/HexWhitePiece { 1.0 HexPiece } def

/HexBlackPiece { 0.0 HexPiece } def

/HexWhiteLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def
    i j HexWhitePiece
    i j str strlen 0.0 true true LabelStringVerb
end } def

/HexBlackLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def 
    i j HexBlackPiece
    i j str strlen 1.0 true true LabelStringVerb
end } def

/AbsCoordX { 1 dict begin /x exch def
    OriginX x Scale mul add
end } def

/AbsCoordY { 1 dict begin /y exch def
    OriginY y Scale mul add
end } def

/DrawBox { /maxy exch def /maxx exch def /miny exch def /minx exch def
    newpath
    minx miny moveto
    maxx minx sub 0 rlineto
    0 maxy miny sub rlineto
    minx maxx sub 0 rlineto
    0 miny maxy sub rlineto
    HexLineWidth setlinewidth
    0 setgray
    stroke
} def

/HexVertex { 2 dict begin /j exch def /i exch def
    i j GraphVertexSize HexDot
end } def

/HexLine { 4 dict begin /j2 exch def /i2 exch def /j1 exch def /i1 exch def
    GraphLineWidth setlinewidth
    0 setgray
    newpath
    i1 j1 HexCenterPoint moveto
    i2 j2 HexCenterPoint lineto
    stroke
end } def

%%---------------- Program -------------------


FlatTopBoard
DrawHexBoard
1 HexBoardBorders
1 1 HexBlackMarker
1 2 HexBlackMarker
2 1 HexBlackMarker
2 2 HexBlackMarker
2 3 HexWhiteMarker
2 4 HexBlackMarker
3 1 HexBlackMarker
3 2 HexWhiteMarker
3 3 HexBlackMarker
3 4 HexBlackMarker
4 3 HexBlackMarker
4 4 HexBlackMarker


%------------ Trailer --------------

showpage

%%EndDocument
 @endspecial 347 3047 a(White)53 b(can)f(win)g(b)-5 b(y)52
b(pla)-5 b(ying)53 b(\014rst)f(at)g(a4.)72 b(If)51 b(blac)-5
b(k's)53 b(reply)f(is)g(not)g(in)g Ff(f)p Fi(b3,b4,c3,d2,d3)p
Ff(g)j Fi(then)181 3247 y(white)48 b(wins)g(b)-5 b(y)47
b(next)g(pla)-5 b(ying)48 b(c3.)71 b(If)45 b(blac)-5
b(k's)49 b(reply)e(is)g(in)g(one)g(of)g(these)g(5)g(cells,)i(then)f
(white)g(wins)181 3448 y(b)-5 b(y)50 b(pla)-5 b(ying)51
b(c2.)71 b(This)51 b(is)e(easy)h(to)g(see)g(if)f(blac)-5
b(k)50 b(pla)-5 b(y)g(ed)52 b(in)e Ff(f)p Fi(b3,c3,d3)p
Ff(g)p Fi(,)i(and)e(not)g(to)5 b(o)50 b(hard)g(to)g(see)181
3649 y(if)k(blac)-5 b(k)56 b(pla)-5 b(y)g(ed)56 b(in)f
Ff(f)p Fi(b4,d2)p Ff(g)p Fi(.)74 b(One)55 b(suc)-5 b(h)55
b(line)h(of)e(pla)-5 b(y)55 b(is)f(sho)-5 b(wn)57 b(b)5
b(elo)-5 b(w.)347 3849 y(By)54 b(symmetry)-14 b(,)57
b(White)e(also)g(wins)g(b)-5 b(y)55 b(pla)-5 b(ying)56
b(\014rst)f(at)g(d1.)347 5578 y @beginspecial 0 @llx
0 @lly 66 @urx 47 @ury 1700 @rwi @setspecial
%%BeginDocument: fz/pix/4z.eps
%!PS-Adobe-3.0
%%Creator: Jack van Rijswijck, thanks to Cameron Browne
%%BoundingBox: 0 0 66 47
%%Pages: 0
%%EndComments

/OriginX -6 def
/OriginY 36 def
%---------------- Variables -------------------

/DimX 4 def
/DimY 4 def
/Scale 1.2 def


% draw  Hex boards, any size ... but labels only up to 26x26
% based on code by Cameron Browne, revised by Jack vR, revised by RBH
%-------------- state initializations -------------------------
1 setlinejoin   % lines meet at a point  ==>    use round join
%---------------- constants -------------------
/Root3Div2  0.86602540378444 def
/Chars   {[(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)
           (n)(o)(p)(q)(r)(s)(t)(u)(v)(w)(x)(y)(z)]} def
/CharsUC {[(A)(B)(C)(D)(E)(F)(G)(H)(I)(J)(K)(L)(M)
           (N)(O)(P)(Q)(R)(S)(T)(U)(V)(W)(X)(Y)(Z)]} def
/Digits  {[(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)(12)(13)
           (14)(15)(16)(17)(18)(19)(20)(21)(22)(23)(24)(25)(26)]} def
/HexRadius      5 Scale mul def % hexagon center-to-corner distance 
/HexLineWidth 0.1 Scale mul def 
/GraphVertexSize 1.0 Scale mul def
/GraphLineWidth 0.5 Scale mul def
/CircleRadius 3.0 Scale mul def 
/CircleLineWidth 0.346 Scale mul def 
/PerimeterWidth 0.5 Scale mul def 
/TextHeight 4.5 def
/TextWidth TextHeight 0.45 mul def 
/BoardShade 0.8 def
/CoordinatesShade 0.5 def
/MarkerSize 1.2 def
/CellOrientation 1 def   % 1: flat bottom  0: pointed bottom
/CellCorner [ % 6 cell corners, wrt center 0 0, plus "up" and "down"
   [ HexRadius  neg       0                           ] 
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul neg ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul neg ]
   [ HexRadius            0                           ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul     ]
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul neg ]
] def
%----- name cell corner indices ... see below
/Left  0 def /DownLeft 1 def /DownRight 2 def 
/Right 3 def /UpRight  4 def /UpLeft    5 def 
/Up    6 def /Down     7 def
%-----------------------------------------------------
% cell orientations:  flat bottom    flat side
%-----------------------------------------------------
% flat bottom 
% board cell indices            cell corner/top/bottom indices
%             --
%           /    \
%        --   1,3  --                  5 -6- 4
%      /    \    /    \               /       \
%   --   1,2  --   2,3  --           0         3
% /    \    /    \    /    \          \       /
%   1,1  --   2,2  --   3,3            1 -7- 2
% \    /    \    /    \    /
%   --   2,1  --   3,2  --
%      \    /    \    /   
%        --   3,1  --     
%----------------------------------------------------
% flat side 
%    /  \  /  \  /  \                       5
%   | 11 || 12 || 13 ||                   /   6
%    \  /  \  /  \  /  \                 0     4
%     || 21 || 22 || 23 |                |     |
%       \  /  \  /  \  /  \              1     3
%        || 31 || 32 || 33 |              7   /
%-------------------------------------------2--------
%----------- procedures -------------
/ScalePoint { % stack: ... x y size ==> ...  x*size y*size
   3 dict begin /size exch def /y exch def /x exch def
   x size mul           y size mul
end } def

/FlatTopBoard { FlatSideCells } def

/FlatSideCells {  % redefine cell orientation for flat side
  /CellOrientation 0 def   
  /CellCorner [ % 6 cell corners, wrt center 0 0  %xcoord ycoord
    [HexRadius Root3Div2 mul neg  HexRadius 2 div     ]
    [HexRadius Root3Div2 mul neg  HexRadius 2 div neg ]
    [0                            HexRadius neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div ]
    [0                            HexRadius ]
    [HexRadius Root3Div2 2 div mul HexRadius 0.75 mul ]
    [HexRadius Root3Div2 2 div mul neg HexRadius 0.75 mul neg ]
  ] def
} def

/HexCenterPoint { % center of cell (i,j)
    2 dict begin /j exch def /i exch def
    CellOrientation 1 eq {
    OriginX i j add HexRadius mul 1.5 mul add %Ox + (i+j)*HR*1.5
    OriginY i j sub HexRadius mul Root3Div2 mul sub %Oy - (i-j)*HR*R3/2
    }{
    OriginX i 2 j mul add HexRadius mul Root3Div2 mul add  %Ox + (2i+j)*HR
    OriginY i 1 sub HexRadius mul 1.5 mul sub %Oy - i*HR*R3/2
    } ifelse
end } def
 
/HexLine { % a b c d
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint lineto
    stroke
} def

/HexCurve { % a b c d e f
    /f exch def
    /e exch def
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint e f HexCenterPoint HexRadius 2 mul arcto
    e f HexCenterPoint lineto
    stroke
} def

/HxgnCorner { 5 dict begin /corn exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    x CellCorner corn get 0 get add
    y CellCorner corn get 1 get add
end } def

/Go { 2 dict begin /corn exch def /mag exch def
   % rlineto in a cell orientation direction
   CellCorner corn get aload pop mag ScalePoint rlineto
end } def

/TurnGo { rotate 1.0 Left Go } def % call: degrees TurnGo
/MagTurnGo { rotate Left Go } def % call: mag degrees TurnGo

/HexagonPath { % call: i j HexagonPath
    newpath 
    UpRight HxgnCorner moveto 
    6 { 1.0 Left Go 60 rotate } repeat 
} def

/FillAndStroke { 2 dict begin /sh exch def /wdth exch def
    gsave sh setgray fill
    grestore 0 setgray wdth setlinewidth stroke
end } def

/ShadedHexagon { 3 dict begin /shade exch def /j exch def /i exch def
    i j HexagonPath
    0 shade FillAndStroke
end } def

/Hexagon { % stack: ... i j
    HexagonPath 
    HexLineWidth BoardShade FillAndStroke
} def

/SemiHexagonPath { % stack: ... top i j
    newpath 
    1 eq { Left HxgnCorner moveto 
        1.0 UpRight Go 1.0 Right Go 1.0 DownRight Go stroke }{
        Right HxgnCorner moveto 
        1.0 DownLeft Go 1.0 Left Go 1.0 UpLeft Go stroke
    } ifelse
} def

/HexBoardPerimeter {
    newpath
    1 DimY UpRight HxgnCorner moveto 1.0 Left Go                      
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 rotate %restore rotation
} def

%----------- Havannah coordinates ----------------------
%                   ..  ..  ..
%                 d1  c2  b3  a4
%                   c1  b2  a3
%                     b1  a2
%                       a1
/HavannahPosn { % convert to usual coordinate, so ... x y  =>  ... 1+DimX-x  y
    exch DimX 1 add exch sub exch 
} def

/HavannahBoardPerimeter {
    newpath
    1 DimX UpRight HxgnCorner moveto 1.0 Left Go                      
    6 {Base 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo } repeat
} def

/DrawHexBoard { 2 dict begin
    gsave
    HexBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexPLBoard { 6 dict begin %point-line board
    gsave
    BoardShade setgray newpath
    -1 DimY 1 add 0.5 mul HexCenterPoint moveto
    1 DimY HexCenterPoint lineto
    DimX 1 add 0.5 mul DimY 2 add HexCenterPoint lineto
    DimX DimY HexCenterPoint lineto
    DimX 2 add DimY 1 add 0.5 mul HexCenterPoint lineto
    DimX 1 HexCenterPoint lineto
    DimX 1 add 0.5 mul -1 HexCenterPoint lineto
    1 1 HexCenterPoint lineto
    closepath fill 0 setgray
    1 DimY HexCenterPoint moveto
    1 1 DimX { /i exch def 
        i 1 i DimY HexLine 
        DimY 1 add 0.5 mul -1 i 1 HexLine
        DimY 1 add 0.5 mul DimY 2 add i DimY HexLine } for
    1 1 DimY { /j exch def 
        1 j DimX j HexLine 
        -1 DimX 1 add 0.5 mul 1 j HexLine
        DimX 2 add DimX 1 add 0.5 mul DimX j HexLine } for
    /topx 1 def /topy 1 def /btmx 1 def /btmy 1 def
    DimX DimY add 3 sub {
      topx DimX lt {/topx 1 topx add def}{/topy 1 topy add def} ifelse 
      btmy DimY lt {/btmy 1 btmy add def}{/btmx 1 btmx add def} ifelse 
      topx topy btmx btmy HexLine
      } repeat
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j HexVertex
	} for } for
    grestore
end } def

/DrawHavannahBoard { 3 dict begin
    /Base DimX 1 add 2 idiv  def
    gsave
    HavannahBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 Base { /j exch def
	Base j 1 sub sub 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    1 1 Base 1 sub { /j exch def
	1 1 DimX j sub { /i exch def
	   i j Base add 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexBorder{ 6 dict begin /start exch def 
    /cells exch def /isBlack exch def /which exch def
    gsave
    which UpLeft eq {1 DimY 1 add start sub Up HxgnCorner moveto /d Left def /r 60 def} if
    which UpRight eq {start DimY Up HxgnCorner moveto /d Right def /r 300 def} if
    which DownLeft eq {DimX 1 add start sub 1 Down HxgnCorner moveto /d Left def /r 300 def} if
    which DownRight eq {DimX start Down HxgnCorner moveto /d Right def /r 60 def} if
    0.5 d Go 
    which UpRight eq which DownRight eq or {180 rotate} if
    r TurnGo 
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.5 360 r sub MagTurnGo 1.5 360 r sub 2 mul MagTurnGo
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.75 360 r sub MagTurnGo
    closepath isBlack 1 eq {gsave fill grestore} if stroke grestore
end } def

/NoDrawHexBoard {  % dummy, used in creating bounding box
} def

/HexBoardBorders { 1 dict begin
    /upperLeftBlack exch def
    PerimeterWidth setlinewidth 0 setgray
    UpLeft    upperLeftBlack       DimY 1 DrawHexBorder
    UpRight   1 upperLeftBlack sub DimX 1 DrawHexBorder
    DownRight upperLeftBlack       DimY 1 DrawHexBorder
    DownLeft  1 upperLeftBlack sub DimX 1 DrawHexBorder
end } def

/YBoardPerimeter {
    newpath 1 1 DownRight HxgnCorner moveto 180 rotate
    3 { DimX 1 sub { 300 TurnGo 60 TurnGo } repeat 
        60 TurnGo 60 TurnGo} 
    repeat % now restore initial rotation state
    180 rotate % closepath
} def

/DrawYBoard { 2 dict begin
    YBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimX {/j exch def
        1 1 DimX 1 add j sub {/i exch def
	    i j 1 SemiHexagonPath stroke
        } for } for
end } def

/FontSelect { % bold italic FontSelect
    2 dict begin /italic exch def /bold exch def
    bold {
	italic 
	{ /Times-BoldItalic findfont TextHeight scalefont setfont } 
	{ /Times-Bold findfont TextHeight scalefont setfont }
	ifelse} 
        {
	italic {/Times-Italic findfont TextHeight scalefont setfont} 
	{ /Times findfont TextHeight scalefont setfont }
	ifelse}
    ifelse
end } def
	    
/LabelString {   % call: i j (str) strlen LabelString
%  to use with board rotation, remove comments
    6 dict begin /strlen exch def /str exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint /y exch def /x exch def
    %BoardRotation rotate
    x y moveto 
    %360 BoardRotation sub rotate
    TextWidth strlen mul 0.5 mul neg TextHeight 0.33 mul neg rmoveto
    str show 
end } def

/AbsLabelString { 4 dict begin
    /strlen exch def /str exch def /y exch def /x exch def
    newpath
    x AbsCoordX TextWidth strlen mul 0.5 mul sub
    y AbsCoordY TextHeight 0.33 mul sub
    moveto
    str
    show
end } def

/LabelStringVerb { % i j (str) strlen shade bold italic LabelStringVerb
    7 dict begin /italic exch def /bold exch def /shade exch def
    /strlen exch def /str exch def /j exch def /i exch def
    bold italic FontSelect shade setgray
    i j str strlen LabelString
end } def

/HexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimX { /i exch def
	i 0          Chars i 1 sub get 1 LabelString
	i DimY 1 add Chars i 1 sub get 1 LabelString
    } for
    1 1 DimY { /j exch def
	0 j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
	DimX 1 add j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HavannahBoardCoordinates { 3 dict begin
    false true FontSelect CoordinatesShade setgray
    /Base DimX 1 add 2 idiv  def
    1 1 Base { /i exch def
	i 0 HavannahPosn Chars  i 1 sub get 1 LabelString
	0 i HavannahPosn Digits i 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
    1 1 Base 1 sub { /i exch def
	i Base add i HavannahPosn Chars  i Base add 1 sub get 1 LabelString
	i i Base add HavannahPosn Digits i Base add 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/AltHexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimY { /j exch def
	0 j Chars j 1 sub get 1 LabelString
        %DimX 1 add j Chars j 1 sub get 1 LabelString
    } for
    1 1 DimX { /i exch def
	i 0 Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
	%i DimY 1 add Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HexDot { 3 dict begin /size exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint size 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexWhiteMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexWhitePiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexBlackMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexBlackPiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    1 setgray 0 setlinewidth fill
end } def

/HexDoubleMarker { 6 dict begin
    /shaderight exch def /shadeleft exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    gsave
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    shadeleft setgray 0 setlinewidth fill
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    shaderight setgray 0 setlinewidth fill
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    grestore
end } def

/HexBlackWhiteMarker { 0.0 1.0 HexDoubleMarker } def

/HexWhiteBlackMarker { 1.0 0.0 HexDoubleMarker } def
        
/HexMarker { 2 dict begin /j exch def /i exch def
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setlinewidth fill
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke  
end } def

/HexBlackMarker { 2 dict begin /j exch def /i exch def
    0 setgray
    i j HexMarker
end } def

/HexWhiteMarker { 2 dict begin /j exch def /i exch def
    1 setgray
    i j HexMarker
end } def
    
/HexPiece { 3 dict begin /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/MagicStone { 4 dict begin 
    /size exch def /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 1.3 mul size mul 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/HexWhitePiece { 1.0 HexPiece } def

/HexBlackPiece { 0.0 HexPiece } def

/HexWhiteLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def
    i j HexWhitePiece
    i j str strlen 0.0 true true LabelStringVerb
end } def

/HexBlackLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def 
    i j HexBlackPiece
    i j str strlen 1.0 true true LabelStringVerb
end } def

/AbsCoordX { 1 dict begin /x exch def
    OriginX x Scale mul add
end } def

/AbsCoordY { 1 dict begin /y exch def
    OriginY y Scale mul add
end } def

/DrawBox { /maxy exch def /maxx exch def /miny exch def /minx exch def
    newpath
    minx miny moveto
    maxx minx sub 0 rlineto
    0 maxy miny sub rlineto
    minx maxx sub 0 rlineto
    0 miny maxy sub rlineto
    HexLineWidth setlinewidth
    0 setgray
    stroke
} def

/HexVertex { 2 dict begin /j exch def /i exch def
    i j GraphVertexSize HexDot
end } def

/HexLine { 4 dict begin /j2 exch def /i2 exch def /j1 exch def /i1 exch def
    GraphLineWidth setlinewidth
    0 setgray
    newpath
    i1 j1 HexCenterPoint moveto
    i2 j2 HexCenterPoint lineto
    stroke
end } def

%%---------------- Program -------------------

FlatTopBoard
DrawHexBoard
1 HexBoardBorders
AltHexBoardCoordinates

4 1 (1) 1 HexWhiteLabelledPiece 
2 4 (2) 1 HexBlackLabelledPiece 
2 3 (3) 1 HexWhiteLabelledPiece 
1 4 (4) 1 HexBlackLabelledPiece 
4 3 (5) 1 HexWhiteLabelledPiece 
4 2 (6) 1 HexBlackLabelledPiece 
3 3 (7) 1 HexWhiteLabelledPiece 
3 2 (8) 1 HexBlackLabelledPiece 
2 2 (9) 1 HexWhiteLabelledPiece 
3 1 (10) 2 HexBlackLabelledPiece 
2 1 (11) 2 HexWhiteLabelledPiece 


%------------ Trailer --------------

showpage

%%EndDocument
 @endspecial 2417 w @beginspecial 0 @llx 0 @lly 66 @urx
47 @ury 1700 @rwi @setspecial
%%BeginDocument: fz/pix/4x4.winners2.eps
%!PS-Adobe-3.0
%%Creator: Jack van Rijswijck, thanks to Cameron Browne
%%BoundingBox: 0 0 66 47
%%Pages: 0
%%EndComments

/OriginX -6 def
/OriginY 36 def
%---------------- Variables -------------------

/DimX 4 def
/DimY 4 def
/Scale 1.2 def


% draw  Hex boards, any size ... but labels only up to 26x26
% based on code by Cameron Browne, revised by Jack vR, revised by RBH
%-------------- state initializations -------------------------
1 setlinejoin   % lines meet at a point  ==>    use round join
%---------------- constants -------------------
/Root3Div2  0.86602540378444 def
/Chars   {[(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)
           (n)(o)(p)(q)(r)(s)(t)(u)(v)(w)(x)(y)(z)]} def
/CharsUC {[(A)(B)(C)(D)(E)(F)(G)(H)(I)(J)(K)(L)(M)
           (N)(O)(P)(Q)(R)(S)(T)(U)(V)(W)(X)(Y)(Z)]} def
/Digits  {[(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)(12)(13)
           (14)(15)(16)(17)(18)(19)(20)(21)(22)(23)(24)(25)(26)]} def
/HexRadius      5 Scale mul def % hexagon center-to-corner distance 
/HexLineWidth 0.1 Scale mul def 
/GraphVertexSize 1.0 Scale mul def
/GraphLineWidth 0.5 Scale mul def
/CircleRadius 3.0 Scale mul def 
/CircleLineWidth 0.346 Scale mul def 
/PerimeterWidth 0.5 Scale mul def 
/TextHeight 4.5 def
/TextWidth TextHeight 0.45 mul def 
/BoardShade 0.8 def
/CoordinatesShade 0.5 def
/MarkerSize 1.2 def
/CellOrientation 1 def   % 1: flat bottom  0: pointed bottom
/CellCorner [ % 6 cell corners, wrt center 0 0, plus "up" and "down"
   [ HexRadius  neg       0                           ] 
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul neg ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul neg ]
   [ HexRadius            0                           ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul     ]
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul neg ]
] def
%----- name cell corner indices ... see below
/Left  0 def /DownLeft 1 def /DownRight 2 def 
/Right 3 def /UpRight  4 def /UpLeft    5 def 
/Up    6 def /Down     7 def
%-----------------------------------------------------
% cell orientations:  flat bottom    flat side
%-----------------------------------------------------
% flat bottom 
% board cell indices            cell corner/top/bottom indices
%             --
%           /    \
%        --   1,3  --                  5 -6- 4
%      /    \    /    \               /       \
%   --   1,2  --   2,3  --           0         3
% /    \    /    \    /    \          \       /
%   1,1  --   2,2  --   3,3            1 -7- 2
% \    /    \    /    \    /
%   --   2,1  --   3,2  --
%      \    /    \    /   
%        --   3,1  --     
%----------------------------------------------------
% flat side 
%    /  \  /  \  /  \                       5
%   | 11 || 12 || 13 ||                   /   6
%    \  /  \  /  \  /  \                 0     4
%     || 21 || 22 || 23 |                |     |
%       \  /  \  /  \  /  \              1     3
%        || 31 || 32 || 33 |              7   /
%-------------------------------------------2--------
%----------- procedures -------------
/ScalePoint { % stack: ... x y size ==> ...  x*size y*size
   3 dict begin /size exch def /y exch def /x exch def
   x size mul           y size mul
end } def

/FlatTopBoard { FlatSideCells } def

/FlatSideCells {  % redefine cell orientation for flat side
  /CellOrientation 0 def   
  /CellCorner [ % 6 cell corners, wrt center 0 0  %xcoord ycoord
    [HexRadius Root3Div2 mul neg  HexRadius 2 div     ]
    [HexRadius Root3Div2 mul neg  HexRadius 2 div neg ]
    [0                            HexRadius neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div ]
    [0                            HexRadius ]
    [HexRadius Root3Div2 2 div mul HexRadius 0.75 mul ]
    [HexRadius Root3Div2 2 div mul neg HexRadius 0.75 mul neg ]
  ] def
} def

/HexCenterPoint { % center of cell (i,j)
    2 dict begin /j exch def /i exch def
    CellOrientation 1 eq {
    OriginX i j add HexRadius mul 1.5 mul add %Ox + (i+j)*HR*1.5
    OriginY i j sub HexRadius mul Root3Div2 mul sub %Oy - (i-j)*HR*R3/2
    }{
    OriginX i 2 j mul add HexRadius mul Root3Div2 mul add  %Ox + (2i+j)*HR
    OriginY i 1 sub HexRadius mul 1.5 mul sub %Oy - i*HR*R3/2
    } ifelse
end } def
 
/HexLine { % a b c d
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint lineto
    stroke
} def

/HexCurve { % a b c d e f
    /f exch def
    /e exch def
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint e f HexCenterPoint HexRadius 2 mul arcto
    e f HexCenterPoint lineto
    stroke
} def

/HxgnCorner { 5 dict begin /corn exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    x CellCorner corn get 0 get add
    y CellCorner corn get 1 get add
end } def

/Go { 2 dict begin /corn exch def /mag exch def
   % rlineto in a cell orientation direction
   CellCorner corn get aload pop mag ScalePoint rlineto
end } def

/TurnGo { rotate 1.0 Left Go } def % call: degrees TurnGo
/MagTurnGo { rotate Left Go } def % call: mag degrees TurnGo

/HexagonPath { % call: i j HexagonPath
    newpath 
    UpRight HxgnCorner moveto 
    6 { 1.0 Left Go 60 rotate } repeat 
} def

/FillAndStroke { 2 dict begin /sh exch def /wdth exch def
    gsave sh setgray fill
    grestore 0 setgray wdth setlinewidth stroke
end } def

/ShadedHexagon { 3 dict begin /shade exch def /j exch def /i exch def
    i j HexagonPath
    0 shade FillAndStroke
end } def

/Hexagon { % stack: ... i j
    HexagonPath 
    HexLineWidth BoardShade FillAndStroke
} def

/SemiHexagonPath { % stack: ... top i j
    newpath 
    1 eq { Left HxgnCorner moveto 
        1.0 UpRight Go 1.0 Right Go 1.0 DownRight Go stroke }{
        Right HxgnCorner moveto 
        1.0 DownLeft Go 1.0 Left Go 1.0 UpLeft Go stroke
    } ifelse
} def

/HexBoardPerimeter {
    newpath
    1 DimY UpRight HxgnCorner moveto 1.0 Left Go                      
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 rotate %restore rotation
} def

%----------- Havannah coordinates ----------------------
%                   ..  ..  ..
%                 d1  c2  b3  a4
%                   c1  b2  a3
%                     b1  a2
%                       a1
/HavannahPosn { % convert to usual coordinate, so ... x y  =>  ... 1+DimX-x  y
    exch DimX 1 add exch sub exch 
} def

/HavannahBoardPerimeter {
    newpath
    1 DimX UpRight HxgnCorner moveto 1.0 Left Go                      
    6 {Base 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo } repeat
} def

/DrawHexBoard { 2 dict begin
    gsave
    HexBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexPLBoard { 6 dict begin %point-line board
    gsave
    BoardShade setgray newpath
    -1 DimY 1 add 0.5 mul HexCenterPoint moveto
    1 DimY HexCenterPoint lineto
    DimX 1 add 0.5 mul DimY 2 add HexCenterPoint lineto
    DimX DimY HexCenterPoint lineto
    DimX 2 add DimY 1 add 0.5 mul HexCenterPoint lineto
    DimX 1 HexCenterPoint lineto
    DimX 1 add 0.5 mul -1 HexCenterPoint lineto
    1 1 HexCenterPoint lineto
    closepath fill 0 setgray
    1 DimY HexCenterPoint moveto
    1 1 DimX { /i exch def 
        i 1 i DimY HexLine 
        DimY 1 add 0.5 mul -1 i 1 HexLine
        DimY 1 add 0.5 mul DimY 2 add i DimY HexLine } for
    1 1 DimY { /j exch def 
        1 j DimX j HexLine 
        -1 DimX 1 add 0.5 mul 1 j HexLine
        DimX 2 add DimX 1 add 0.5 mul DimX j HexLine } for
    /topx 1 def /topy 1 def /btmx 1 def /btmy 1 def
    DimX DimY add 3 sub {
      topx DimX lt {/topx 1 topx add def}{/topy 1 topy add def} ifelse 
      btmy DimY lt {/btmy 1 btmy add def}{/btmx 1 btmx add def} ifelse 
      topx topy btmx btmy HexLine
      } repeat
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j HexVertex
	} for } for
    grestore
end } def

/DrawHavannahBoard { 3 dict begin
    /Base DimX 1 add 2 idiv  def
    gsave
    HavannahBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 Base { /j exch def
	Base j 1 sub sub 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    1 1 Base 1 sub { /j exch def
	1 1 DimX j sub { /i exch def
	   i j Base add 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexBorder{ 6 dict begin /start exch def 
    /cells exch def /isBlack exch def /which exch def
    gsave
    which UpLeft eq {1 DimY 1 add start sub Up HxgnCorner moveto /d Left def /r 60 def} if
    which UpRight eq {start DimY Up HxgnCorner moveto /d Right def /r 300 def} if
    which DownLeft eq {DimX 1 add start sub 1 Down HxgnCorner moveto /d Left def /r 300 def} if
    which DownRight eq {DimX start Down HxgnCorner moveto /d Right def /r 60 def} if
    0.5 d Go 
    which UpRight eq which DownRight eq or {180 rotate} if
    r TurnGo 
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.5 360 r sub MagTurnGo 1.5 360 r sub 2 mul MagTurnGo
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.75 360 r sub MagTurnGo
    closepath isBlack 1 eq {gsave fill grestore} if stroke grestore
end } def

/NoDrawHexBoard {  % dummy, used in creating bounding box
} def

/HexBoardBorders { 1 dict begin
    /upperLeftBlack exch def
    PerimeterWidth setlinewidth 0 setgray
    UpLeft    upperLeftBlack       DimY 1 DrawHexBorder
    UpRight   1 upperLeftBlack sub DimX 1 DrawHexBorder
    DownRight upperLeftBlack       DimY 1 DrawHexBorder
    DownLeft  1 upperLeftBlack sub DimX 1 DrawHexBorder
end } def

/YBoardPerimeter {
    newpath 1 1 DownRight HxgnCorner moveto 180 rotate
    3 { DimX 1 sub { 300 TurnGo 60 TurnGo } repeat 
        60 TurnGo 60 TurnGo} 
    repeat % now restore initial rotation state
    180 rotate % closepath
} def

/DrawYBoard { 2 dict begin
    YBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimX {/j exch def
        1 1 DimX 1 add j sub {/i exch def
	    i j 1 SemiHexagonPath stroke
        } for } for
end } def

/FontSelect { % bold italic FontSelect
    2 dict begin /italic exch def /bold exch def
    bold {
	italic 
	{ /Times-BoldItalic findfont TextHeight scalefont setfont } 
	{ /Times-Bold findfont TextHeight scalefont setfont }
	ifelse} 
        {
	italic {/Times-Italic findfont TextHeight scalefont setfont} 
	{ /Times findfont TextHeight scalefont setfont }
	ifelse}
    ifelse
end } def
	    
/LabelString {   % call: i j (str) strlen LabelString
%  to use with board rotation, remove comments
    6 dict begin /strlen exch def /str exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint /y exch def /x exch def
    %BoardRotation rotate
    x y moveto 
    %360 BoardRotation sub rotate
    TextWidth strlen mul 0.5 mul neg TextHeight 0.33 mul neg rmoveto
    str show 
end } def

/AbsLabelString { 4 dict begin
    /strlen exch def /str exch def /y exch def /x exch def
    newpath
    x AbsCoordX TextWidth strlen mul 0.5 mul sub
    y AbsCoordY TextHeight 0.33 mul sub
    moveto
    str
    show
end } def

/LabelStringVerb { % i j (str) strlen shade bold italic LabelStringVerb
    7 dict begin /italic exch def /bold exch def /shade exch def
    /strlen exch def /str exch def /j exch def /i exch def
    bold italic FontSelect shade setgray
    i j str strlen LabelString
end } def

/HexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimX { /i exch def
	i 0          Chars i 1 sub get 1 LabelString
	i DimY 1 add Chars i 1 sub get 1 LabelString
    } for
    1 1 DimY { /j exch def
	0 j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
	DimX 1 add j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HavannahBoardCoordinates { 3 dict begin
    false true FontSelect CoordinatesShade setgray
    /Base DimX 1 add 2 idiv  def
    1 1 Base { /i exch def
	i 0 HavannahPosn Chars  i 1 sub get 1 LabelString
	0 i HavannahPosn Digits i 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
    1 1 Base 1 sub { /i exch def
	i Base add i HavannahPosn Chars  i Base add 1 sub get 1 LabelString
	i i Base add HavannahPosn Digits i Base add 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/AltHexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimY { /j exch def
	0 j Chars j 1 sub get 1 LabelString
        %DimX 1 add j Chars j 1 sub get 1 LabelString
    } for
    1 1 DimX { /i exch def
	i 0 Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
	%i DimY 1 add Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HexDot { 3 dict begin /size exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint size 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexWhiteMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexWhitePiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexBlackMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexBlackPiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    1 setgray 0 setlinewidth fill
end } def

/HexDoubleMarker { 6 dict begin
    /shaderight exch def /shadeleft exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    gsave
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    shadeleft setgray 0 setlinewidth fill
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    shaderight setgray 0 setlinewidth fill
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    grestore
end } def

/HexBlackWhiteMarker { 0.0 1.0 HexDoubleMarker } def

/HexWhiteBlackMarker { 1.0 0.0 HexDoubleMarker } def
        
/HexMarker { 2 dict begin /j exch def /i exch def
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setlinewidth fill
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke  
end } def

/HexBlackMarker { 2 dict begin /j exch def /i exch def
    0 setgray
    i j HexMarker
end } def

/HexWhiteMarker { 2 dict begin /j exch def /i exch def
    1 setgray
    i j HexMarker
end } def
    
/HexPiece { 3 dict begin /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/MagicStone { 4 dict begin 
    /size exch def /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 1.3 mul size mul 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/HexWhitePiece { 1.0 HexPiece } def

/HexBlackPiece { 0.0 HexPiece } def

/HexWhiteLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def
    i j HexWhitePiece
    i j str strlen 0.0 true true LabelStringVerb
end } def

/HexBlackLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def 
    i j HexBlackPiece
    i j str strlen 1.0 true true LabelStringVerb
end } def

/AbsCoordX { 1 dict begin /x exch def
    OriginX x Scale mul add
end } def

/AbsCoordY { 1 dict begin /y exch def
    OriginY y Scale mul add
end } def

/DrawBox { /maxy exch def /maxx exch def /miny exch def /minx exch def
    newpath
    minx miny moveto
    maxx minx sub 0 rlineto
    0 maxy miny sub rlineto
    minx maxx sub 0 rlineto
    0 miny maxy sub rlineto
    HexLineWidth setlinewidth
    0 setgray
    stroke
} def

/HexVertex { 2 dict begin /j exch def /i exch def
    i j GraphVertexSize HexDot
end } def

/HexLine { 4 dict begin /j2 exch def /i2 exch def /j1 exch def /i1 exch def
    GraphLineWidth setlinewidth
    0 setgray
    newpath
    i1 j1 HexCenterPoint moveto
    i2 j2 HexCenterPoint lineto
    stroke
end } def

%%---------------- Program -------------------


FlatTopBoard
DrawHexBoard
1 HexBoardBorders
1 1 HexBlackMarker
1 2 HexBlackMarker
1 4 HexWhiteMarker
2 1 HexBlackMarker
2 2 HexBlackMarker
2 3 HexWhiteMarker
2 4 HexBlackMarker
3 1 HexBlackMarker
3 2 HexWhiteMarker
3 3 HexBlackMarker
3 4 HexBlackMarker
4 1 HexWhiteMarker
4 3 HexBlackMarker
4 4 HexBlackMarker


%------------ Trailer --------------

showpage

%%EndDocument
 @endspecial 347 5778 a(There)j(are)f(only)g(t)-5 b(w)g(o)58
b(op)5 b(ening)58 b(mo)-5 b(v)g(es)58 b(left,)f(and)h(they)e(are)h
(symmetric.)81 b(If)56 b(white)i(pla)-5 b(ys)57 b(\014rst)181
5979 y(at)k(c1)h(\(b)5 b(elo)-5 b(w)62 b(left\),)h(blac)-5
b(k)62 b(can)g(win:)86 b(the)62 b(main)g(v)-9 b(ariation)62
b(is)f(sho)-5 b(wn,)65 b(this)c(is)g(not)h(a)f(complete)181
6180 y(pro)5 b(of.)73 b(By)54 b(symmetry)-14 b(,)56 b(if)e(white)i(pla)
-5 b(ys)55 b(\014rst)g(at)g(b4,)g(blac)-5 b(k)56 b(wins.)73
b(So)55 b(w)-5 b(e)55 b(are)g(done.)347 8077 y @beginspecial
0 @llx 0 @lly 66 @urx 47 @ury 1700 @rwi @setspecial
%%BeginDocument: fz/pix/4last.eps
%!PS-Adobe-3.0
%%Creator: Jack van Rijswijck, thanks to Cameron Browne
%%BoundingBox: 0 0 66 47
%%Pages: 0
%%EndComments

/OriginX -6 def
/OriginY 36 def
%---------------- Variables -------------------

/DimX 4 def
/DimY 4 def
/Scale 1.2 def


% draw  Hex boards, any size ... but labels only up to 26x26
% based on code by Cameron Browne, revised by Jack vR, revised by RBH
%-------------- state initializations -------------------------
1 setlinejoin   % lines meet at a point  ==>    use round join
%---------------- constants -------------------
/Root3Div2  0.86602540378444 def
/Chars   {[(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)
           (n)(o)(p)(q)(r)(s)(t)(u)(v)(w)(x)(y)(z)]} def
/CharsUC {[(A)(B)(C)(D)(E)(F)(G)(H)(I)(J)(K)(L)(M)
           (N)(O)(P)(Q)(R)(S)(T)(U)(V)(W)(X)(Y)(Z)]} def
/Digits  {[(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)(12)(13)
           (14)(15)(16)(17)(18)(19)(20)(21)(22)(23)(24)(25)(26)]} def
/HexRadius      5 Scale mul def % hexagon center-to-corner distance 
/HexLineWidth 0.1 Scale mul def 
/GraphVertexSize 1.0 Scale mul def
/GraphLineWidth 0.5 Scale mul def
/CircleRadius 3.0 Scale mul def 
/CircleLineWidth 0.346 Scale mul def 
/PerimeterWidth 0.5 Scale mul def 
/TextHeight 4.5 def
/TextWidth TextHeight 0.45 mul def 
/BoardShade 0.8 def
/CoordinatesShade 0.5 def
/MarkerSize 1.2 def
/CellOrientation 1 def   % 1: flat bottom  0: pointed bottom
/CellCorner [ % 6 cell corners, wrt center 0 0, plus "up" and "down"
   [ HexRadius  neg       0                           ] 
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul neg ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul neg ]
   [ HexRadius            0                           ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul     ]
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul neg ]
] def
%----- name cell corner indices ... see below
/Left  0 def /DownLeft 1 def /DownRight 2 def 
/Right 3 def /UpRight  4 def /UpLeft    5 def 
/Up    6 def /Down     7 def
%-----------------------------------------------------
% cell orientations:  flat bottom    flat side
%-----------------------------------------------------
% flat bottom 
% board cell indices            cell corner/top/bottom indices
%             --
%           /    \
%        --   1,3  --                  5 -6- 4
%      /    \    /    \               /       \
%   --   1,2  --   2,3  --           0         3
% /    \    /    \    /    \          \       /
%   1,1  --   2,2  --   3,3            1 -7- 2
% \    /    \    /    \    /
%   --   2,1  --   3,2  --
%      \    /    \    /   
%        --   3,1  --     
%----------------------------------------------------
% flat side 
%    /  \  /  \  /  \                       5
%   | 11 || 12 || 13 ||                   /   6
%    \  /  \  /  \  /  \                 0     4
%     || 21 || 22 || 23 |                |     |
%       \  /  \  /  \  /  \              1     3
%        || 31 || 32 || 33 |              7   /
%-------------------------------------------2--------
%----------- procedures -------------
/ScalePoint { % stack: ... x y size ==> ...  x*size y*size
   3 dict begin /size exch def /y exch def /x exch def
   x size mul           y size mul
end } def

/FlatTopBoard { FlatSideCells } def

/FlatSideCells {  % redefine cell orientation for flat side
  /CellOrientation 0 def   
  /CellCorner [ % 6 cell corners, wrt center 0 0  %xcoord ycoord
    [HexRadius Root3Div2 mul neg  HexRadius 2 div     ]
    [HexRadius Root3Div2 mul neg  HexRadius 2 div neg ]
    [0                            HexRadius neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div ]
    [0                            HexRadius ]
    [HexRadius Root3Div2 2 div mul HexRadius 0.75 mul ]
    [HexRadius Root3Div2 2 div mul neg HexRadius 0.75 mul neg ]
  ] def
} def

/HexCenterPoint { % center of cell (i,j)
    2 dict begin /j exch def /i exch def
    CellOrientation 1 eq {
    OriginX i j add HexRadius mul 1.5 mul add %Ox + (i+j)*HR*1.5
    OriginY i j sub HexRadius mul Root3Div2 mul sub %Oy - (i-j)*HR*R3/2
    }{
    OriginX i 2 j mul add HexRadius mul Root3Div2 mul add  %Ox + (2i+j)*HR
    OriginY i 1 sub HexRadius mul 1.5 mul sub %Oy - i*HR*R3/2
    } ifelse
end } def
 
/HexLine { % a b c d
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint lineto
    stroke
} def

/HexCurve { % a b c d e f
    /f exch def
    /e exch def
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint e f HexCenterPoint HexRadius 2 mul arcto
    e f HexCenterPoint lineto
    stroke
} def

/HxgnCorner { 5 dict begin /corn exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    x CellCorner corn get 0 get add
    y CellCorner corn get 1 get add
end } def

/Go { 2 dict begin /corn exch def /mag exch def
   % rlineto in a cell orientation direction
   CellCorner corn get aload pop mag ScalePoint rlineto
end } def

/TurnGo { rotate 1.0 Left Go } def % call: degrees TurnGo
/MagTurnGo { rotate Left Go } def % call: mag degrees TurnGo

/HexagonPath { % call: i j HexagonPath
    newpath 
    UpRight HxgnCorner moveto 
    6 { 1.0 Left Go 60 rotate } repeat 
} def

/FillAndStroke { 2 dict begin /sh exch def /wdth exch def
    gsave sh setgray fill
    grestore 0 setgray wdth setlinewidth stroke
end } def

/ShadedHexagon { 3 dict begin /shade exch def /j exch def /i exch def
    i j HexagonPath
    0 shade FillAndStroke
end } def

/Hexagon { % stack: ... i j
    HexagonPath 
    HexLineWidth BoardShade FillAndStroke
} def

/SemiHexagonPath { % stack: ... top i j
    newpath 
    1 eq { Left HxgnCorner moveto 
        1.0 UpRight Go 1.0 Right Go 1.0 DownRight Go stroke }{
        Right HxgnCorner moveto 
        1.0 DownLeft Go 1.0 Left Go 1.0 UpLeft Go stroke
    } ifelse
} def

/HexBoardPerimeter {
    newpath
    1 DimY UpRight HxgnCorner moveto 1.0 Left Go                      
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 rotate %restore rotation
} def

%----------- Havannah coordinates ----------------------
%                   ..  ..  ..
%                 d1  c2  b3  a4
%                   c1  b2  a3
%                     b1  a2
%                       a1
/HavannahPosn { % convert to usual coordinate, so ... x y  =>  ... 1+DimX-x  y
    exch DimX 1 add exch sub exch 
} def

/HavannahBoardPerimeter {
    newpath
    1 DimX UpRight HxgnCorner moveto 1.0 Left Go                      
    6 {Base 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo } repeat
} def

/DrawHexBoard { 2 dict begin
    gsave
    HexBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexPLBoard { 6 dict begin %point-line board
    gsave
    BoardShade setgray newpath
    -1 DimY 1 add 0.5 mul HexCenterPoint moveto
    1 DimY HexCenterPoint lineto
    DimX 1 add 0.5 mul DimY 2 add HexCenterPoint lineto
    DimX DimY HexCenterPoint lineto
    DimX 2 add DimY 1 add 0.5 mul HexCenterPoint lineto
    DimX 1 HexCenterPoint lineto
    DimX 1 add 0.5 mul -1 HexCenterPoint lineto
    1 1 HexCenterPoint lineto
    closepath fill 0 setgray
    1 DimY HexCenterPoint moveto
    1 1 DimX { /i exch def 
        i 1 i DimY HexLine 
        DimY 1 add 0.5 mul -1 i 1 HexLine
        DimY 1 add 0.5 mul DimY 2 add i DimY HexLine } for
    1 1 DimY { /j exch def 
        1 j DimX j HexLine 
        -1 DimX 1 add 0.5 mul 1 j HexLine
        DimX 2 add DimX 1 add 0.5 mul DimX j HexLine } for
    /topx 1 def /topy 1 def /btmx 1 def /btmy 1 def
    DimX DimY add 3 sub {
      topx DimX lt {/topx 1 topx add def}{/topy 1 topy add def} ifelse 
      btmy DimY lt {/btmy 1 btmy add def}{/btmx 1 btmx add def} ifelse 
      topx topy btmx btmy HexLine
      } repeat
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j HexVertex
	} for } for
    grestore
end } def

/DrawHavannahBoard { 3 dict begin
    /Base DimX 1 add 2 idiv  def
    gsave
    HavannahBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 Base { /j exch def
	Base j 1 sub sub 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    1 1 Base 1 sub { /j exch def
	1 1 DimX j sub { /i exch def
	   i j Base add 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexBorder{ 6 dict begin /start exch def 
    /cells exch def /isBlack exch def /which exch def
    gsave
    which UpLeft eq {1 DimY 1 add start sub Up HxgnCorner moveto /d Left def /r 60 def} if
    which UpRight eq {start DimY Up HxgnCorner moveto /d Right def /r 300 def} if
    which DownLeft eq {DimX 1 add start sub 1 Down HxgnCorner moveto /d Left def /r 300 def} if
    which DownRight eq {DimX start Down HxgnCorner moveto /d Right def /r 60 def} if
    0.5 d Go 
    which UpRight eq which DownRight eq or {180 rotate} if
    r TurnGo 
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.5 360 r sub MagTurnGo 1.5 360 r sub 2 mul MagTurnGo
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.75 360 r sub MagTurnGo
    closepath isBlack 1 eq {gsave fill grestore} if stroke grestore
end } def

/NoDrawHexBoard {  % dummy, used in creating bounding box
} def

/HexBoardBorders { 1 dict begin
    /upperLeftBlack exch def
    PerimeterWidth setlinewidth 0 setgray
    UpLeft    upperLeftBlack       DimY 1 DrawHexBorder
    UpRight   1 upperLeftBlack sub DimX 1 DrawHexBorder
    DownRight upperLeftBlack       DimY 1 DrawHexBorder
    DownLeft  1 upperLeftBlack sub DimX 1 DrawHexBorder
end } def

/YBoardPerimeter {
    newpath 1 1 DownRight HxgnCorner moveto 180 rotate
    3 { DimX 1 sub { 300 TurnGo 60 TurnGo } repeat 
        60 TurnGo 60 TurnGo} 
    repeat % now restore initial rotation state
    180 rotate % closepath
} def

/DrawYBoard { 2 dict begin
    YBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimX {/j exch def
        1 1 DimX 1 add j sub {/i exch def
	    i j 1 SemiHexagonPath stroke
        } for } for
end } def

/FontSelect { % bold italic FontSelect
    2 dict begin /italic exch def /bold exch def
    bold {
	italic 
	{ /Times-BoldItalic findfont TextHeight scalefont setfont } 
	{ /Times-Bold findfont TextHeight scalefont setfont }
	ifelse} 
        {
	italic {/Times-Italic findfont TextHeight scalefont setfont} 
	{ /Times findfont TextHeight scalefont setfont }
	ifelse}
    ifelse
end } def
	    
/LabelString {   % call: i j (str) strlen LabelString
%  to use with board rotation, remove comments
    6 dict begin /strlen exch def /str exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint /y exch def /x exch def
    %BoardRotation rotate
    x y moveto 
    %360 BoardRotation sub rotate
    TextWidth strlen mul 0.5 mul neg TextHeight 0.33 mul neg rmoveto
    str show 
end } def

/AbsLabelString { 4 dict begin
    /strlen exch def /str exch def /y exch def /x exch def
    newpath
    x AbsCoordX TextWidth strlen mul 0.5 mul sub
    y AbsCoordY TextHeight 0.33 mul sub
    moveto
    str
    show
end } def

/LabelStringVerb { % i j (str) strlen shade bold italic LabelStringVerb
    7 dict begin /italic exch def /bold exch def /shade exch def
    /strlen exch def /str exch def /j exch def /i exch def
    bold italic FontSelect shade setgray
    i j str strlen LabelString
end } def

/HexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimX { /i exch def
	i 0          Chars i 1 sub get 1 LabelString
	i DimY 1 add Chars i 1 sub get 1 LabelString
    } for
    1 1 DimY { /j exch def
	0 j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
	DimX 1 add j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HavannahBoardCoordinates { 3 dict begin
    false true FontSelect CoordinatesShade setgray
    /Base DimX 1 add 2 idiv  def
    1 1 Base { /i exch def
	i 0 HavannahPosn Chars  i 1 sub get 1 LabelString
	0 i HavannahPosn Digits i 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
    1 1 Base 1 sub { /i exch def
	i Base add i HavannahPosn Chars  i Base add 1 sub get 1 LabelString
	i i Base add HavannahPosn Digits i Base add 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/AltHexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimY { /j exch def
	0 j Chars j 1 sub get 1 LabelString
        %DimX 1 add j Chars j 1 sub get 1 LabelString
    } for
    1 1 DimX { /i exch def
	i 0 Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
	%i DimY 1 add Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HexDot { 3 dict begin /size exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint size 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexWhiteMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexWhitePiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexBlackMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexBlackPiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    1 setgray 0 setlinewidth fill
end } def

/HexDoubleMarker { 6 dict begin
    /shaderight exch def /shadeleft exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    gsave
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    shadeleft setgray 0 setlinewidth fill
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    shaderight setgray 0 setlinewidth fill
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    grestore
end } def

/HexBlackWhiteMarker { 0.0 1.0 HexDoubleMarker } def

/HexWhiteBlackMarker { 1.0 0.0 HexDoubleMarker } def
        
/HexMarker { 2 dict begin /j exch def /i exch def
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setlinewidth fill
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke  
end } def

/HexBlackMarker { 2 dict begin /j exch def /i exch def
    0 setgray
    i j HexMarker
end } def

/HexWhiteMarker { 2 dict begin /j exch def /i exch def
    1 setgray
    i j HexMarker
end } def
    
/HexPiece { 3 dict begin /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/MagicStone { 4 dict begin 
    /size exch def /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 1.3 mul size mul 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/HexWhitePiece { 1.0 HexPiece } def

/HexBlackPiece { 0.0 HexPiece } def

/HexWhiteLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def
    i j HexWhitePiece
    i j str strlen 0.0 true true LabelStringVerb
end } def

/HexBlackLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def 
    i j HexBlackPiece
    i j str strlen 1.0 true true LabelStringVerb
end } def

/AbsCoordX { 1 dict begin /x exch def
    OriginX x Scale mul add
end } def

/AbsCoordY { 1 dict begin /y exch def
    OriginY y Scale mul add
end } def

/DrawBox { /maxy exch def /maxx exch def /miny exch def /minx exch def
    newpath
    minx miny moveto
    maxx minx sub 0 rlineto
    0 maxy miny sub rlineto
    minx maxx sub 0 rlineto
    0 miny maxy sub rlineto
    HexLineWidth setlinewidth
    0 setgray
    stroke
} def

/HexVertex { 2 dict begin /j exch def /i exch def
    i j GraphVertexSize HexDot
end } def

/HexLine { 4 dict begin /j2 exch def /i2 exch def /j1 exch def /i1 exch def
    GraphLineWidth setlinewidth
    0 setgray
    newpath
    i1 j1 HexCenterPoint moveto
    i2 j2 HexCenterPoint lineto
    stroke
end } def

%%---------------- Program -------------------

FlatTopBoard
DrawHexBoard
1 HexBoardBorders
AltHexBoardCoordinates

1 3 (1) 1 HexWhiteLabelledPiece 
3 2 (2) 1 HexBlackLabelledPiece 
2 1 (3) 1 HexWhiteLabelledPiece 
1 4 (4) 1 HexBlackLabelledPiece 
2 3 (5) 1 HexWhiteLabelledPiece 
2 4 (6) 1 HexBlackLabelledPiece 
3 3 (7) 1 HexWhiteLabelledPiece 
3 4 (8) 1 HexBlackLabelledPiece 
4 3 (9) 1 HexWhiteLabelledPiece 
4 4 (10) 2 HexBlackLabelledPiece 


%------------ Trailer --------------

showpage

%%EndDocument
 @endspecial 2417 w @beginspecial 0 @llx 0 @lly 66 @urx
47 @ury 1700 @rwi @setspecial
%%BeginDocument: fz/pix/4x4.winners.eps
%!PS-Adobe-3.0
%%Creator: Jack van Rijswijck, thanks to Cameron Browne
%%BoundingBox: 0 0 66 47
%%Pages: 0
%%EndComments

/OriginX -6 def
/OriginY 36 def
%---------------- Variables -------------------

/DimX 4 def
/DimY 4 def
/Scale 1.2 def


% draw  Hex boards, any size ... but labels only up to 26x26
% based on code by Cameron Browne, revised by Jack vR, revised by RBH
%-------------- state initializations -------------------------
1 setlinejoin   % lines meet at a point  ==>    use round join
%---------------- constants -------------------
/Root3Div2  0.86602540378444 def
/Chars   {[(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)
           (n)(o)(p)(q)(r)(s)(t)(u)(v)(w)(x)(y)(z)]} def
/CharsUC {[(A)(B)(C)(D)(E)(F)(G)(H)(I)(J)(K)(L)(M)
           (N)(O)(P)(Q)(R)(S)(T)(U)(V)(W)(X)(Y)(Z)]} def
/Digits  {[(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)(12)(13)
           (14)(15)(16)(17)(18)(19)(20)(21)(22)(23)(24)(25)(26)]} def
/HexRadius      5 Scale mul def % hexagon center-to-corner distance 
/HexLineWidth 0.1 Scale mul def 
/GraphVertexSize 1.0 Scale mul def
/GraphLineWidth 0.5 Scale mul def
/CircleRadius 3.0 Scale mul def 
/CircleLineWidth 0.346 Scale mul def 
/PerimeterWidth 0.5 Scale mul def 
/TextHeight 4.5 def
/TextWidth TextHeight 0.45 mul def 
/BoardShade 0.8 def
/CoordinatesShade 0.5 def
/MarkerSize 1.2 def
/CellOrientation 1 def   % 1: flat bottom  0: pointed bottom
/CellCorner [ % 6 cell corners, wrt center 0 0, plus "up" and "down"
   [ HexRadius  neg       0                           ] 
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul neg ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul neg ]
   [ HexRadius            0                           ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul     ]
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul neg ]
] def
%----- name cell corner indices ... see below
/Left  0 def /DownLeft 1 def /DownRight 2 def 
/Right 3 def /UpRight  4 def /UpLeft    5 def 
/Up    6 def /Down     7 def
%-----------------------------------------------------
% cell orientations:  flat bottom    flat side
%-----------------------------------------------------
% flat bottom 
% board cell indices            cell corner/top/bottom indices
%             --
%           /    \
%        --   1,3  --                  5 -6- 4
%      /    \    /    \               /       \
%   --   1,2  --   2,3  --           0         3
% /    \    /    \    /    \          \       /
%   1,1  --   2,2  --   3,3            1 -7- 2
% \    /    \    /    \    /
%   --   2,1  --   3,2  --
%      \    /    \    /   
%        --   3,1  --     
%----------------------------------------------------
% flat side 
%    /  \  /  \  /  \                       5
%   | 11 || 12 || 13 ||                   /   6
%    \  /  \  /  \  /  \                 0     4
%     || 21 || 22 || 23 |                |     |
%       \  /  \  /  \  /  \              1     3
%        || 31 || 32 || 33 |              7   /
%-------------------------------------------2--------
%----------- procedures -------------
/ScalePoint { % stack: ... x y size ==> ...  x*size y*size
   3 dict begin /size exch def /y exch def /x exch def
   x size mul           y size mul
end } def

/FlatTopBoard { FlatSideCells } def

/FlatSideCells {  % redefine cell orientation for flat side
  /CellOrientation 0 def   
  /CellCorner [ % 6 cell corners, wrt center 0 0  %xcoord ycoord
    [HexRadius Root3Div2 mul neg  HexRadius 2 div     ]
    [HexRadius Root3Div2 mul neg  HexRadius 2 div neg ]
    [0                            HexRadius neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div ]
    [0                            HexRadius ]
    [HexRadius Root3Div2 2 div mul HexRadius 0.75 mul ]
    [HexRadius Root3Div2 2 div mul neg HexRadius 0.75 mul neg ]
  ] def
} def

/HexCenterPoint { % center of cell (i,j)
    2 dict begin /j exch def /i exch def
    CellOrientation 1 eq {
    OriginX i j add HexRadius mul 1.5 mul add %Ox + (i+j)*HR*1.5
    OriginY i j sub HexRadius mul Root3Div2 mul sub %Oy - (i-j)*HR*R3/2
    }{
    OriginX i 2 j mul add HexRadius mul Root3Div2 mul add  %Ox + (2i+j)*HR
    OriginY i 1 sub HexRadius mul 1.5 mul sub %Oy - i*HR*R3/2
    } ifelse
end } def
 
/HexLine { % a b c d
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint lineto
    stroke
} def

/HexCurve { % a b c d e f
    /f exch def
    /e exch def
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint e f HexCenterPoint HexRadius 2 mul arcto
    e f HexCenterPoint lineto
    stroke
} def

/HxgnCorner { 5 dict begin /corn exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    x CellCorner corn get 0 get add
    y CellCorner corn get 1 get add
end } def

/Go { 2 dict begin /corn exch def /mag exch def
   % rlineto in a cell orientation direction
   CellCorner corn get aload pop mag ScalePoint rlineto
end } def

/TurnGo { rotate 1.0 Left Go } def % call: degrees TurnGo
/MagTurnGo { rotate Left Go } def % call: mag degrees TurnGo

/HexagonPath { % call: i j HexagonPath
    newpath 
    UpRight HxgnCorner moveto 
    6 { 1.0 Left Go 60 rotate } repeat 
} def

/FillAndStroke { 2 dict begin /sh exch def /wdth exch def
    gsave sh setgray fill
    grestore 0 setgray wdth setlinewidth stroke
end } def

/ShadedHexagon { 3 dict begin /shade exch def /j exch def /i exch def
    i j HexagonPath
    0 shade FillAndStroke
end } def

/Hexagon { % stack: ... i j
    HexagonPath 
    HexLineWidth BoardShade FillAndStroke
} def

/SemiHexagonPath { % stack: ... top i j
    newpath 
    1 eq { Left HxgnCorner moveto 
        1.0 UpRight Go 1.0 Right Go 1.0 DownRight Go stroke }{
        Right HxgnCorner moveto 
        1.0 DownLeft Go 1.0 Left Go 1.0 UpLeft Go stroke
    } ifelse
} def

/HexBoardPerimeter {
    newpath
    1 DimY UpRight HxgnCorner moveto 1.0 Left Go                      
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 rotate %restore rotation
} def

%----------- Havannah coordinates ----------------------
%                   ..  ..  ..
%                 d1  c2  b3  a4
%                   c1  b2  a3
%                     b1  a2
%                       a1
/HavannahPosn { % convert to usual coordinate, so ... x y  =>  ... 1+DimX-x  y
    exch DimX 1 add exch sub exch 
} def

/HavannahBoardPerimeter {
    newpath
    1 DimX UpRight HxgnCorner moveto 1.0 Left Go                      
    6 {Base 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo } repeat
} def

/DrawHexBoard { 2 dict begin
    gsave
    HexBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexPLBoard { 6 dict begin %point-line board
    gsave
    BoardShade setgray newpath
    -1 DimY 1 add 0.5 mul HexCenterPoint moveto
    1 DimY HexCenterPoint lineto
    DimX 1 add 0.5 mul DimY 2 add HexCenterPoint lineto
    DimX DimY HexCenterPoint lineto
    DimX 2 add DimY 1 add 0.5 mul HexCenterPoint lineto
    DimX 1 HexCenterPoint lineto
    DimX 1 add 0.5 mul -1 HexCenterPoint lineto
    1 1 HexCenterPoint lineto
    closepath fill 0 setgray
    1 DimY HexCenterPoint moveto
    1 1 DimX { /i exch def 
        i 1 i DimY HexLine 
        DimY 1 add 0.5 mul -1 i 1 HexLine
        DimY 1 add 0.5 mul DimY 2 add i DimY HexLine } for
    1 1 DimY { /j exch def 
        1 j DimX j HexLine 
        -1 DimX 1 add 0.5 mul 1 j HexLine
        DimX 2 add DimX 1 add 0.5 mul DimX j HexLine } for
    /topx 1 def /topy 1 def /btmx 1 def /btmy 1 def
    DimX DimY add 3 sub {
      topx DimX lt {/topx 1 topx add def}{/topy 1 topy add def} ifelse 
      btmy DimY lt {/btmy 1 btmy add def}{/btmx 1 btmx add def} ifelse 
      topx topy btmx btmy HexLine
      } repeat
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j HexVertex
	} for } for
    grestore
end } def

/DrawHavannahBoard { 3 dict begin
    /Base DimX 1 add 2 idiv  def
    gsave
    HavannahBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 Base { /j exch def
	Base j 1 sub sub 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    1 1 Base 1 sub { /j exch def
	1 1 DimX j sub { /i exch def
	   i j Base add 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexBorder{ 6 dict begin /start exch def 
    /cells exch def /isBlack exch def /which exch def
    gsave
    which UpLeft eq {1 DimY 1 add start sub Up HxgnCorner moveto /d Left def /r 60 def} if
    which UpRight eq {start DimY Up HxgnCorner moveto /d Right def /r 300 def} if
    which DownLeft eq {DimX 1 add start sub 1 Down HxgnCorner moveto /d Left def /r 300 def} if
    which DownRight eq {DimX start Down HxgnCorner moveto /d Right def /r 60 def} if
    0.5 d Go 
    which UpRight eq which DownRight eq or {180 rotate} if
    r TurnGo 
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.5 360 r sub MagTurnGo 1.5 360 r sub 2 mul MagTurnGo
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.75 360 r sub MagTurnGo
    closepath isBlack 1 eq {gsave fill grestore} if stroke grestore
end } def

/NoDrawHexBoard {  % dummy, used in creating bounding box
} def

/HexBoardBorders { 1 dict begin
    /upperLeftBlack exch def
    PerimeterWidth setlinewidth 0 setgray
    UpLeft    upperLeftBlack       DimY 1 DrawHexBorder
    UpRight   1 upperLeftBlack sub DimX 1 DrawHexBorder
    DownRight upperLeftBlack       DimY 1 DrawHexBorder
    DownLeft  1 upperLeftBlack sub DimX 1 DrawHexBorder
end } def

/YBoardPerimeter {
    newpath 1 1 DownRight HxgnCorner moveto 180 rotate
    3 { DimX 1 sub { 300 TurnGo 60 TurnGo } repeat 
        60 TurnGo 60 TurnGo} 
    repeat % now restore initial rotation state
    180 rotate % closepath
} def

/DrawYBoard { 2 dict begin
    YBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimX {/j exch def
        1 1 DimX 1 add j sub {/i exch def
	    i j 1 SemiHexagonPath stroke
        } for } for
end } def

/FontSelect { % bold italic FontSelect
    2 dict begin /italic exch def /bold exch def
    bold {
	italic 
	{ /Times-BoldItalic findfont TextHeight scalefont setfont } 
	{ /Times-Bold findfont TextHeight scalefont setfont }
	ifelse} 
        {
	italic {/Times-Italic findfont TextHeight scalefont setfont} 
	{ /Times findfont TextHeight scalefont setfont }
	ifelse}
    ifelse
end } def
	    
/LabelString {   % call: i j (str) strlen LabelString
%  to use with board rotation, remove comments
    6 dict begin /strlen exch def /str exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint /y exch def /x exch def
    %BoardRotation rotate
    x y moveto 
    %360 BoardRotation sub rotate
    TextWidth strlen mul 0.5 mul neg TextHeight 0.33 mul neg rmoveto
    str show 
end } def

/AbsLabelString { 4 dict begin
    /strlen exch def /str exch def /y exch def /x exch def
    newpath
    x AbsCoordX TextWidth strlen mul 0.5 mul sub
    y AbsCoordY TextHeight 0.33 mul sub
    moveto
    str
    show
end } def

/LabelStringVerb { % i j (str) strlen shade bold italic LabelStringVerb
    7 dict begin /italic exch def /bold exch def /shade exch def
    /strlen exch def /str exch def /j exch def /i exch def
    bold italic FontSelect shade setgray
    i j str strlen LabelString
end } def

/HexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimX { /i exch def
	i 0          Chars i 1 sub get 1 LabelString
	i DimY 1 add Chars i 1 sub get 1 LabelString
    } for
    1 1 DimY { /j exch def
	0 j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
	DimX 1 add j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HavannahBoardCoordinates { 3 dict begin
    false true FontSelect CoordinatesShade setgray
    /Base DimX 1 add 2 idiv  def
    1 1 Base { /i exch def
	i 0 HavannahPosn Chars  i 1 sub get 1 LabelString
	0 i HavannahPosn Digits i 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
    1 1 Base 1 sub { /i exch def
	i Base add i HavannahPosn Chars  i Base add 1 sub get 1 LabelString
	i i Base add HavannahPosn Digits i Base add 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/AltHexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimY { /j exch def
	0 j Chars j 1 sub get 1 LabelString
        %DimX 1 add j Chars j 1 sub get 1 LabelString
    } for
    1 1 DimX { /i exch def
	i 0 Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
	%i DimY 1 add Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HexDot { 3 dict begin /size exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint size 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexWhiteMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexWhitePiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexBlackMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexBlackPiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    1 setgray 0 setlinewidth fill
end } def

/HexDoubleMarker { 6 dict begin
    /shaderight exch def /shadeleft exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    gsave
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    shadeleft setgray 0 setlinewidth fill
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    shaderight setgray 0 setlinewidth fill
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    grestore
end } def

/HexBlackWhiteMarker { 0.0 1.0 HexDoubleMarker } def

/HexWhiteBlackMarker { 1.0 0.0 HexDoubleMarker } def
        
/HexMarker { 2 dict begin /j exch def /i exch def
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setlinewidth fill
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke  
end } def

/HexBlackMarker { 2 dict begin /j exch def /i exch def
    0 setgray
    i j HexMarker
end } def

/HexWhiteMarker { 2 dict begin /j exch def /i exch def
    1 setgray
    i j HexMarker
end } def
    
/HexPiece { 3 dict begin /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/MagicStone { 4 dict begin 
    /size exch def /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 1.3 mul size mul 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/HexWhitePiece { 1.0 HexPiece } def

/HexBlackPiece { 0.0 HexPiece } def

/HexWhiteLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def
    i j HexWhitePiece
    i j str strlen 0.0 true true LabelStringVerb
end } def

/HexBlackLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def 
    i j HexBlackPiece
    i j str strlen 1.0 true true LabelStringVerb
end } def

/AbsCoordX { 1 dict begin /x exch def
    OriginX x Scale mul add
end } def

/AbsCoordY { 1 dict begin /y exch def
    OriginY y Scale mul add
end } def

/DrawBox { /maxy exch def /maxx exch def /miny exch def /minx exch def
    newpath
    minx miny moveto
    maxx minx sub 0 rlineto
    0 maxy miny sub rlineto
    minx maxx sub 0 rlineto
    0 miny maxy sub rlineto
    HexLineWidth setlinewidth
    0 setgray
    stroke
} def

/HexVertex { 2 dict begin /j exch def /i exch def
    i j GraphVertexSize HexDot
end } def

/HexLine { 4 dict begin /j2 exch def /i2 exch def /j1 exch def /i1 exch def
    GraphLineWidth setlinewidth
    0 setgray
    newpath
    i1 j1 HexCenterPoint moveto
    i2 j2 HexCenterPoint lineto
    stroke
end } def

%%---------------- Program -------------------


FlatTopBoard
DrawHexBoard
1 HexBoardBorders
1 1 HexBlackMarker
1 2 HexBlackMarker
1 3 HexBlackMarker
1 4 HexWhiteMarker
2 1 HexBlackMarker
2 2 HexBlackMarker
2 3 HexWhiteMarker
2 4 HexBlackMarker
3 1 HexBlackMarker
3 2 HexWhiteMarker
3 3 HexBlackMarker
3 4 HexBlackMarker
4 1 HexWhiteMarker
4 2 HexBlackMarker
4 3 HexBlackMarker
4 4 HexBlackMarker


%------------ Trailer --------------

showpage

%%EndDocument
 @endspecial 347 8478 a(PS.)i(Ry)-5 b(an)58 b(Ha)-5 b(yw)g(ard)60
b(is)d(writing)i(a)f(b)5 b(o)g(ok)57 b(on)h(Hex.)81 b(If)57
b(y)-5 b(ou)58 b(w)-5 b(ould)59 b(lik)-5 b(e)58 b(to)g(b)5
b(e)57 b(noti\014ed)j(when)181 8679 y(it)55 b(is)f(published,)j(send)e
(him)g(email:)74 b Fd(hayward@ualberta.ca)63 b Fi(.)p
Black Black eop end
%%Page: 13 13
TeXDict begin 13 12 bop Black 181 -165 a Fj(Iv)-5 b(erson)55
b(exam)h(2016)p 1555 -165 4439 6 v 4656 w Fi(13)p Black
Black Black 563 1355 a @beginspecial 0 @llx 0 @lly 51
@urx 38 @ury 1133 @rwi @setspecial
%%BeginDocument: fz/pix/3x3.eps
%!PS-Adobe-3.0
%%Creator: Jack van Rijswijck, thanks to Cameron Browne
%%BoundingBox: 0 0 51 38
%%Pages: 0
%%EndComments

/OriginX -6 def
/OriginY 27 def
%---------------- Variables -------------------

/DimX 3 def
/DimY 3 def
/Scale 1.2 def


% draw  Hex boards, any size ... but labels only up to 26x26
% based on code by Cameron Browne, revised by Jack vR, revised by RBH
%-------------- state initializations -------------------------
1 setlinejoin   % lines meet at a point  ==>    use round join
%---------------- constants -------------------
/Root3Div2  0.86602540378444 def
/Chars   {[(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)
           (n)(o)(p)(q)(r)(s)(t)(u)(v)(w)(x)(y)(z)]} def
/CharsUC {[(A)(B)(C)(D)(E)(F)(G)(H)(I)(J)(K)(L)(M)
           (N)(O)(P)(Q)(R)(S)(T)(U)(V)(W)(X)(Y)(Z)]} def
/Digits  {[(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)(12)(13)
           (14)(15)(16)(17)(18)(19)(20)(21)(22)(23)(24)(25)(26)]} def
/HexRadius      5 Scale mul def % hexagon center-to-corner distance 
/HexLineWidth 0.1 Scale mul def 
/GraphVertexSize 1.0 Scale mul def
/GraphLineWidth 0.5 Scale mul def
/CircleRadius 3.0 Scale mul def 
/CircleLineWidth 0.346 Scale mul def 
/PerimeterWidth 0.5 Scale mul def 
/TextHeight 4.5 def
/TextWidth TextHeight 0.45 mul def 
/BoardShade 0.8 def
/CoordinatesShade 0.5 def
/MarkerSize 1.2 def
/CellOrientation 1 def   % 1: flat bottom  0: pointed bottom
/CellCorner [ % 6 cell corners, wrt center 0 0, plus "up" and "down"
   [ HexRadius  neg       0                           ] 
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul neg ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul neg ]
   [ HexRadius            0                           ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul     ]
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul neg ]
] def
%----- name cell corner indices ... see below
/Left  0 def /DownLeft 1 def /DownRight 2 def 
/Right 3 def /UpRight  4 def /UpLeft    5 def 
/Up    6 def /Down     7 def
%-----------------------------------------------------
% cell orientations:  flat bottom    flat side
%-----------------------------------------------------
% flat bottom 
% board cell indices            cell corner/top/bottom indices
%             --
%           /    \
%        --   1,3  --                  5 -6- 4
%      /    \    /    \               /       \
%   --   1,2  --   2,3  --           0         3
% /    \    /    \    /    \          \       /
%   1,1  --   2,2  --   3,3            1 -7- 2
% \    /    \    /    \    /
%   --   2,1  --   3,2  --
%      \    /    \    /   
%        --   3,1  --     
%----------------------------------------------------
% flat side 
%    /  \  /  \  /  \                       5
%   | 11 || 12 || 13 ||                   /   6
%    \  /  \  /  \  /  \                 0     4
%     || 21 || 22 || 23 |                |     |
%       \  /  \  /  \  /  \              1     3
%        || 31 || 32 || 33 |              7   /
%-------------------------------------------2--------
%----------- procedures -------------
/ScalePoint { % stack: ... x y size ==> ...  x*size y*size
   3 dict begin /size exch def /y exch def /x exch def
   x size mul           y size mul
end } def

/FlatTopBoard { FlatSideCells } def

/FlatSideCells {  % redefine cell orientation for flat side
  /CellOrientation 0 def   
  /CellCorner [ % 6 cell corners, wrt center 0 0  %xcoord ycoord
    [HexRadius Root3Div2 mul neg  HexRadius 2 div     ]
    [HexRadius Root3Div2 mul neg  HexRadius 2 div neg ]
    [0                            HexRadius neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div ]
    [0                            HexRadius ]
    [HexRadius Root3Div2 2 div mul HexRadius 0.75 mul ]
    [HexRadius Root3Div2 2 div mul neg HexRadius 0.75 mul neg ]
  ] def
} def

/HexCenterPoint { % center of cell (i,j)
    2 dict begin /j exch def /i exch def
    CellOrientation 1 eq {
    OriginX i j add HexRadius mul 1.5 mul add %Ox + (i+j)*HR*1.5
    OriginY i j sub HexRadius mul Root3Div2 mul sub %Oy - (i-j)*HR*R3/2
    }{
    OriginX i 2 j mul add HexRadius mul Root3Div2 mul add  %Ox + (2i+j)*HR
    OriginY i 1 sub HexRadius mul 1.5 mul sub %Oy - i*HR*R3/2
    } ifelse
end } def
 
/HexLine { % a b c d
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint lineto
    stroke
} def

/HexCurve { % a b c d e f
    /f exch def
    /e exch def
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint e f HexCenterPoint HexRadius 2 mul arcto
    e f HexCenterPoint lineto
    stroke
} def

/HxgnCorner { 5 dict begin /corn exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    x CellCorner corn get 0 get add
    y CellCorner corn get 1 get add
end } def

/Go { 2 dict begin /corn exch def /mag exch def
   % rlineto in a cell orientation direction
   CellCorner corn get aload pop mag ScalePoint rlineto
end } def

/TurnGo { rotate 1.0 Left Go } def % call: degrees TurnGo
/MagTurnGo { rotate Left Go } def % call: mag degrees TurnGo

/HexagonPath { % call: i j HexagonPath
    newpath 
    UpRight HxgnCorner moveto 
    6 { 1.0 Left Go 60 rotate } repeat 
} def

/FillAndStroke { 2 dict begin /sh exch def /wdth exch def
    gsave sh setgray fill
    grestore 0 setgray wdth setlinewidth stroke
end } def

/ShadedHexagon { 3 dict begin /shade exch def /j exch def /i exch def
    i j HexagonPath
    0 shade FillAndStroke
end } def

/Hexagon { % stack: ... i j
    HexagonPath 
    HexLineWidth BoardShade FillAndStroke
} def

/SemiHexagonPath { % stack: ... top i j
    newpath 
    1 eq { Left HxgnCorner moveto 
        1.0 UpRight Go 1.0 Right Go 1.0 DownRight Go stroke }{
        Right HxgnCorner moveto 
        1.0 DownLeft Go 1.0 Left Go 1.0 UpLeft Go stroke
    } ifelse
} def

/HexBoardPerimeter {
    newpath
    1 DimY UpRight HxgnCorner moveto 1.0 Left Go                      
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 rotate %restore rotation
} def

%----------- Havannah coordinates ----------------------
%                   ..  ..  ..
%                 d1  c2  b3  a4
%                   c1  b2  a3
%                     b1  a2
%                       a1
/HavannahPosn { % convert to usual coordinate, so ... x y  =>  ... 1+DimX-x  y
    exch DimX 1 add exch sub exch 
} def

/HavannahBoardPerimeter {
    newpath
    1 DimX UpRight HxgnCorner moveto 1.0 Left Go                      
    6 {Base 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo } repeat
} def

/DrawHexBoard { 2 dict begin
    gsave
    HexBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexPLBoard { 6 dict begin %point-line board
    gsave
    BoardShade setgray newpath
    -1 DimY 1 add 0.5 mul HexCenterPoint moveto
    1 DimY HexCenterPoint lineto
    DimX 1 add 0.5 mul DimY 2 add HexCenterPoint lineto
    DimX DimY HexCenterPoint lineto
    DimX 2 add DimY 1 add 0.5 mul HexCenterPoint lineto
    DimX 1 HexCenterPoint lineto
    DimX 1 add 0.5 mul -1 HexCenterPoint lineto
    1 1 HexCenterPoint lineto
    closepath fill 0 setgray
    1 DimY HexCenterPoint moveto
    1 1 DimX { /i exch def 
        i 1 i DimY HexLine 
        DimY 1 add 0.5 mul -1 i 1 HexLine
        DimY 1 add 0.5 mul DimY 2 add i DimY HexLine } for
    1 1 DimY { /j exch def 
        1 j DimX j HexLine 
        -1 DimX 1 add 0.5 mul 1 j HexLine
        DimX 2 add DimX 1 add 0.5 mul DimX j HexLine } for
    /topx 1 def /topy 1 def /btmx 1 def /btmy 1 def
    DimX DimY add 3 sub {
      topx DimX lt {/topx 1 topx add def}{/topy 1 topy add def} ifelse 
      btmy DimY lt {/btmy 1 btmy add def}{/btmx 1 btmx add def} ifelse 
      topx topy btmx btmy HexLine
      } repeat
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j HexVertex
	} for } for
    grestore
end } def

/DrawHavannahBoard { 3 dict begin
    /Base DimX 1 add 2 idiv  def
    gsave
    HavannahBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 Base { /j exch def
	Base j 1 sub sub 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    1 1 Base 1 sub { /j exch def
	1 1 DimX j sub { /i exch def
	   i j Base add 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexBorder{ 6 dict begin /start exch def 
    /cells exch def /isBlack exch def /which exch def
    gsave
    which UpLeft eq {1 DimY 1 add start sub Up HxgnCorner moveto /d Left def /r 60 def} if
    which UpRight eq {start DimY Up HxgnCorner moveto /d Right def /r 300 def} if
    which DownLeft eq {DimX 1 add start sub 1 Down HxgnCorner moveto /d Left def /r 300 def} if
    which DownRight eq {DimX start Down HxgnCorner moveto /d Right def /r 60 def} if
    0.5 d Go 
    which UpRight eq which DownRight eq or {180 rotate} if
    r TurnGo 
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.5 360 r sub MagTurnGo 1.5 360 r sub 2 mul MagTurnGo
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.75 360 r sub MagTurnGo
    closepath isBlack 1 eq {gsave fill grestore} if stroke grestore
end } def

/NoDrawHexBoard {  % dummy, used in creating bounding box
} def

/HexBoardBorders { 1 dict begin
    /upperLeftBlack exch def
    PerimeterWidth setlinewidth 0 setgray
    UpLeft    upperLeftBlack       DimY 1 DrawHexBorder
    UpRight   1 upperLeftBlack sub DimX 1 DrawHexBorder
    DownRight upperLeftBlack       DimY 1 DrawHexBorder
    DownLeft  1 upperLeftBlack sub DimX 1 DrawHexBorder
end } def

/YBoardPerimeter {
    newpath 1 1 DownRight HxgnCorner moveto 180 rotate
    3 { DimX 1 sub { 300 TurnGo 60 TurnGo } repeat 
        60 TurnGo 60 TurnGo} 
    repeat % now restore initial rotation state
    180 rotate % closepath
} def

/DrawYBoard { 2 dict begin
    YBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimX {/j exch def
        1 1 DimX 1 add j sub {/i exch def
	    i j 1 SemiHexagonPath stroke
        } for } for
end } def

/FontSelect { % bold italic FontSelect
    2 dict begin /italic exch def /bold exch def
    bold {
	italic 
	{ /Times-BoldItalic findfont TextHeight scalefont setfont } 
	{ /Times-Bold findfont TextHeight scalefont setfont }
	ifelse} 
        {
	italic {/Times-Italic findfont TextHeight scalefont setfont} 
	{ /Times findfont TextHeight scalefont setfont }
	ifelse}
    ifelse
end } def
	    
/LabelString {   % call: i j (str) strlen LabelString
%  to use with board rotation, remove comments
    6 dict begin /strlen exch def /str exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint /y exch def /x exch def
    %BoardRotation rotate
    x y moveto 
    %360 BoardRotation sub rotate
    TextWidth strlen mul 0.5 mul neg TextHeight 0.33 mul neg rmoveto
    str show 
end } def

/AbsLabelString { 4 dict begin
    /strlen exch def /str exch def /y exch def /x exch def
    newpath
    x AbsCoordX TextWidth strlen mul 0.5 mul sub
    y AbsCoordY TextHeight 0.33 mul sub
    moveto
    str
    show
end } def

/LabelStringVerb { % i j (str) strlen shade bold italic LabelStringVerb
    7 dict begin /italic exch def /bold exch def /shade exch def
    /strlen exch def /str exch def /j exch def /i exch def
    bold italic FontSelect shade setgray
    i j str strlen LabelString
end } def

/HexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimX { /i exch def
	i 0          Chars i 1 sub get 1 LabelString
	i DimY 1 add Chars i 1 sub get 1 LabelString
    } for
    1 1 DimY { /j exch def
	0 j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
	DimX 1 add j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HavannahBoardCoordinates { 3 dict begin
    false true FontSelect CoordinatesShade setgray
    /Base DimX 1 add 2 idiv  def
    1 1 Base { /i exch def
	i 0 HavannahPosn Chars  i 1 sub get 1 LabelString
	0 i HavannahPosn Digits i 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
    1 1 Base 1 sub { /i exch def
	i Base add i HavannahPosn Chars  i Base add 1 sub get 1 LabelString
	i i Base add HavannahPosn Digits i Base add 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/AltHexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimY { /j exch def
	0 j Chars j 1 sub get 1 LabelString
        %DimX 1 add j Chars j 1 sub get 1 LabelString
    } for
    1 1 DimX { /i exch def
	i 0 Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
	%i DimY 1 add Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HexDot { 3 dict begin /size exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint size 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexWhiteMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexWhitePiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexBlackMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexBlackPiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    1 setgray 0 setlinewidth fill
end } def

/HexDoubleMarker { 6 dict begin
    /shaderight exch def /shadeleft exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    gsave
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    shadeleft setgray 0 setlinewidth fill
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    shaderight setgray 0 setlinewidth fill
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    grestore
end } def

/HexBlackWhiteMarker { 0.0 1.0 HexDoubleMarker } def

/HexWhiteBlackMarker { 1.0 0.0 HexDoubleMarker } def
        
/HexMarker { 2 dict begin /j exch def /i exch def
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setlinewidth fill
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke  
end } def

/HexBlackMarker { 2 dict begin /j exch def /i exch def
    0 setgray
    i j HexMarker
end } def

/HexWhiteMarker { 2 dict begin /j exch def /i exch def
    1 setgray
    i j HexMarker
end } def
    
/HexPiece { 3 dict begin /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/MagicStone { 4 dict begin 
    /size exch def /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 1.3 mul size mul 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/HexWhitePiece { 1.0 HexPiece } def

/HexBlackPiece { 0.0 HexPiece } def

/HexWhiteLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def
    i j HexWhitePiece
    i j str strlen 0.0 true true LabelStringVerb
end } def

/HexBlackLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def 
    i j HexBlackPiece
    i j str strlen 1.0 true true LabelStringVerb
end } def

/AbsCoordX { 1 dict begin /x exch def
    OriginX x Scale mul add
end } def

/AbsCoordY { 1 dict begin /y exch def
    OriginY y Scale mul add
end } def

/DrawBox { /maxy exch def /maxx exch def /miny exch def /minx exch def
    newpath
    minx miny moveto
    maxx minx sub 0 rlineto
    0 maxy miny sub rlineto
    minx maxx sub 0 rlineto
    0 miny maxy sub rlineto
    HexLineWidth setlinewidth
    0 setgray
    stroke
} def

/HexVertex { 2 dict begin /j exch def /i exch def
    i j GraphVertexSize HexDot
end } def

/HexLine { 4 dict begin /j2 exch def /i2 exch def /j1 exch def /i1 exch def
    GraphLineWidth setlinewidth
    0 setgray
    newpath
    i1 j1 HexCenterPoint moveto
    i2 j2 HexCenterPoint lineto
    stroke
end } def

%%---------------- Program -------------------


FlatTopBoard
DrawHexBoard
1 HexBoardBorders


%------------ Trailer --------------

showpage

%%EndDocument
 @endspecial 1900 w @beginspecial 0 @llx 0 @lly 51 @urx
38 @ury 1133 @rwi @setspecial
%%BeginDocument: fz/pix/3x3.eps
%!PS-Adobe-3.0
%%Creator: Jack van Rijswijck, thanks to Cameron Browne
%%BoundingBox: 0 0 51 38
%%Pages: 0
%%EndComments

/OriginX -6 def
/OriginY 27 def
%---------------- Variables -------------------

/DimX 3 def
/DimY 3 def
/Scale 1.2 def


% draw  Hex boards, any size ... but labels only up to 26x26
% based on code by Cameron Browne, revised by Jack vR, revised by RBH
%-------------- state initializations -------------------------
1 setlinejoin   % lines meet at a point  ==>    use round join
%---------------- constants -------------------
/Root3Div2  0.86602540378444 def
/Chars   {[(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)
           (n)(o)(p)(q)(r)(s)(t)(u)(v)(w)(x)(y)(z)]} def
/CharsUC {[(A)(B)(C)(D)(E)(F)(G)(H)(I)(J)(K)(L)(M)
           (N)(O)(P)(Q)(R)(S)(T)(U)(V)(W)(X)(Y)(Z)]} def
/Digits  {[(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)(12)(13)
           (14)(15)(16)(17)(18)(19)(20)(21)(22)(23)(24)(25)(26)]} def
/HexRadius      5 Scale mul def % hexagon center-to-corner distance 
/HexLineWidth 0.1 Scale mul def 
/GraphVertexSize 1.0 Scale mul def
/GraphLineWidth 0.5 Scale mul def
/CircleRadius 3.0 Scale mul def 
/CircleLineWidth 0.346 Scale mul def 
/PerimeterWidth 0.5 Scale mul def 
/TextHeight 4.5 def
/TextWidth TextHeight 0.45 mul def 
/BoardShade 0.8 def
/CoordinatesShade 0.5 def
/MarkerSize 1.2 def
/CellOrientation 1 def   % 1: flat bottom  0: pointed bottom
/CellCorner [ % 6 cell corners, wrt center 0 0, plus "up" and "down"
   [ HexRadius  neg       0                           ] 
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul neg ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul neg ]
   [ HexRadius            0                           ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul     ]
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul neg ]
] def
%----- name cell corner indices ... see below
/Left  0 def /DownLeft 1 def /DownRight 2 def 
/Right 3 def /UpRight  4 def /UpLeft    5 def 
/Up    6 def /Down     7 def
%-----------------------------------------------------
% cell orientations:  flat bottom    flat side
%-----------------------------------------------------
% flat bottom 
% board cell indices            cell corner/top/bottom indices
%             --
%           /    \
%        --   1,3  --                  5 -6- 4
%      /    \    /    \               /       \
%   --   1,2  --   2,3  --           0         3
% /    \    /    \    /    \          \       /
%   1,1  --   2,2  --   3,3            1 -7- 2
% \    /    \    /    \    /
%   --   2,1  --   3,2  --
%      \    /    \    /   
%        --   3,1  --     
%----------------------------------------------------
% flat side 
%    /  \  /  \  /  \                       5
%   | 11 || 12 || 13 ||                   /   6
%    \  /  \  /  \  /  \                 0     4
%     || 21 || 22 || 23 |                |     |
%       \  /  \  /  \  /  \              1     3
%        || 31 || 32 || 33 |              7   /
%-------------------------------------------2--------
%----------- procedures -------------
/ScalePoint { % stack: ... x y size ==> ...  x*size y*size
   3 dict begin /size exch def /y exch def /x exch def
   x size mul           y size mul
end } def

/FlatTopBoard { FlatSideCells } def

/FlatSideCells {  % redefine cell orientation for flat side
  /CellOrientation 0 def   
  /CellCorner [ % 6 cell corners, wrt center 0 0  %xcoord ycoord
    [HexRadius Root3Div2 mul neg  HexRadius 2 div     ]
    [HexRadius Root3Div2 mul neg  HexRadius 2 div neg ]
    [0                            HexRadius neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div ]
    [0                            HexRadius ]
    [HexRadius Root3Div2 2 div mul HexRadius 0.75 mul ]
    [HexRadius Root3Div2 2 div mul neg HexRadius 0.75 mul neg ]
  ] def
} def

/HexCenterPoint { % center of cell (i,j)
    2 dict begin /j exch def /i exch def
    CellOrientation 1 eq {
    OriginX i j add HexRadius mul 1.5 mul add %Ox + (i+j)*HR*1.5
    OriginY i j sub HexRadius mul Root3Div2 mul sub %Oy - (i-j)*HR*R3/2
    }{
    OriginX i 2 j mul add HexRadius mul Root3Div2 mul add  %Ox + (2i+j)*HR
    OriginY i 1 sub HexRadius mul 1.5 mul sub %Oy - i*HR*R3/2
    } ifelse
end } def
 
/HexLine { % a b c d
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint lineto
    stroke
} def

/HexCurve { % a b c d e f
    /f exch def
    /e exch def
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint e f HexCenterPoint HexRadius 2 mul arcto
    e f HexCenterPoint lineto
    stroke
} def

/HxgnCorner { 5 dict begin /corn exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    x CellCorner corn get 0 get add
    y CellCorner corn get 1 get add
end } def

/Go { 2 dict begin /corn exch def /mag exch def
   % rlineto in a cell orientation direction
   CellCorner corn get aload pop mag ScalePoint rlineto
end } def

/TurnGo { rotate 1.0 Left Go } def % call: degrees TurnGo
/MagTurnGo { rotate Left Go } def % call: mag degrees TurnGo

/HexagonPath { % call: i j HexagonPath
    newpath 
    UpRight HxgnCorner moveto 
    6 { 1.0 Left Go 60 rotate } repeat 
} def

/FillAndStroke { 2 dict begin /sh exch def /wdth exch def
    gsave sh setgray fill
    grestore 0 setgray wdth setlinewidth stroke
end } def

/ShadedHexagon { 3 dict begin /shade exch def /j exch def /i exch def
    i j HexagonPath
    0 shade FillAndStroke
end } def

/Hexagon { % stack: ... i j
    HexagonPath 
    HexLineWidth BoardShade FillAndStroke
} def

/SemiHexagonPath { % stack: ... top i j
    newpath 
    1 eq { Left HxgnCorner moveto 
        1.0 UpRight Go 1.0 Right Go 1.0 DownRight Go stroke }{
        Right HxgnCorner moveto 
        1.0 DownLeft Go 1.0 Left Go 1.0 UpLeft Go stroke
    } ifelse
} def

/HexBoardPerimeter {
    newpath
    1 DimY UpRight HxgnCorner moveto 1.0 Left Go                      
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 rotate %restore rotation
} def

%----------- Havannah coordinates ----------------------
%                   ..  ..  ..
%                 d1  c2  b3  a4
%                   c1  b2  a3
%                     b1  a2
%                       a1
/HavannahPosn { % convert to usual coordinate, so ... x y  =>  ... 1+DimX-x  y
    exch DimX 1 add exch sub exch 
} def

/HavannahBoardPerimeter {
    newpath
    1 DimX UpRight HxgnCorner moveto 1.0 Left Go                      
    6 {Base 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo } repeat
} def

/DrawHexBoard { 2 dict begin
    gsave
    HexBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexPLBoard { 6 dict begin %point-line board
    gsave
    BoardShade setgray newpath
    -1 DimY 1 add 0.5 mul HexCenterPoint moveto
    1 DimY HexCenterPoint lineto
    DimX 1 add 0.5 mul DimY 2 add HexCenterPoint lineto
    DimX DimY HexCenterPoint lineto
    DimX 2 add DimY 1 add 0.5 mul HexCenterPoint lineto
    DimX 1 HexCenterPoint lineto
    DimX 1 add 0.5 mul -1 HexCenterPoint lineto
    1 1 HexCenterPoint lineto
    closepath fill 0 setgray
    1 DimY HexCenterPoint moveto
    1 1 DimX { /i exch def 
        i 1 i DimY HexLine 
        DimY 1 add 0.5 mul -1 i 1 HexLine
        DimY 1 add 0.5 mul DimY 2 add i DimY HexLine } for
    1 1 DimY { /j exch def 
        1 j DimX j HexLine 
        -1 DimX 1 add 0.5 mul 1 j HexLine
        DimX 2 add DimX 1 add 0.5 mul DimX j HexLine } for
    /topx 1 def /topy 1 def /btmx 1 def /btmy 1 def
    DimX DimY add 3 sub {
      topx DimX lt {/topx 1 topx add def}{/topy 1 topy add def} ifelse 
      btmy DimY lt {/btmy 1 btmy add def}{/btmx 1 btmx add def} ifelse 
      topx topy btmx btmy HexLine
      } repeat
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j HexVertex
	} for } for
    grestore
end } def

/DrawHavannahBoard { 3 dict begin
    /Base DimX 1 add 2 idiv  def
    gsave
    HavannahBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 Base { /j exch def
	Base j 1 sub sub 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    1 1 Base 1 sub { /j exch def
	1 1 DimX j sub { /i exch def
	   i j Base add 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexBorder{ 6 dict begin /start exch def 
    /cells exch def /isBlack exch def /which exch def
    gsave
    which UpLeft eq {1 DimY 1 add start sub Up HxgnCorner moveto /d Left def /r 60 def} if
    which UpRight eq {start DimY Up HxgnCorner moveto /d Right def /r 300 def} if
    which DownLeft eq {DimX 1 add start sub 1 Down HxgnCorner moveto /d Left def /r 300 def} if
    which DownRight eq {DimX start Down HxgnCorner moveto /d Right def /r 60 def} if
    0.5 d Go 
    which UpRight eq which DownRight eq or {180 rotate} if
    r TurnGo 
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.5 360 r sub MagTurnGo 1.5 360 r sub 2 mul MagTurnGo
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.75 360 r sub MagTurnGo
    closepath isBlack 1 eq {gsave fill grestore} if stroke grestore
end } def

/NoDrawHexBoard {  % dummy, used in creating bounding box
} def

/HexBoardBorders { 1 dict begin
    /upperLeftBlack exch def
    PerimeterWidth setlinewidth 0 setgray
    UpLeft    upperLeftBlack       DimY 1 DrawHexBorder
    UpRight   1 upperLeftBlack sub DimX 1 DrawHexBorder
    DownRight upperLeftBlack       DimY 1 DrawHexBorder
    DownLeft  1 upperLeftBlack sub DimX 1 DrawHexBorder
end } def

/YBoardPerimeter {
    newpath 1 1 DownRight HxgnCorner moveto 180 rotate
    3 { DimX 1 sub { 300 TurnGo 60 TurnGo } repeat 
        60 TurnGo 60 TurnGo} 
    repeat % now restore initial rotation state
    180 rotate % closepath
} def

/DrawYBoard { 2 dict begin
    YBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimX {/j exch def
        1 1 DimX 1 add j sub {/i exch def
	    i j 1 SemiHexagonPath stroke
        } for } for
end } def

/FontSelect { % bold italic FontSelect
    2 dict begin /italic exch def /bold exch def
    bold {
	italic 
	{ /Times-BoldItalic findfont TextHeight scalefont setfont } 
	{ /Times-Bold findfont TextHeight scalefont setfont }
	ifelse} 
        {
	italic {/Times-Italic findfont TextHeight scalefont setfont} 
	{ /Times findfont TextHeight scalefont setfont }
	ifelse}
    ifelse
end } def
	    
/LabelString {   % call: i j (str) strlen LabelString
%  to use with board rotation, remove comments
    6 dict begin /strlen exch def /str exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint /y exch def /x exch def
    %BoardRotation rotate
    x y moveto 
    %360 BoardRotation sub rotate
    TextWidth strlen mul 0.5 mul neg TextHeight 0.33 mul neg rmoveto
    str show 
end } def

/AbsLabelString { 4 dict begin
    /strlen exch def /str exch def /y exch def /x exch def
    newpath
    x AbsCoordX TextWidth strlen mul 0.5 mul sub
    y AbsCoordY TextHeight 0.33 mul sub
    moveto
    str
    show
end } def

/LabelStringVerb { % i j (str) strlen shade bold italic LabelStringVerb
    7 dict begin /italic exch def /bold exch def /shade exch def
    /strlen exch def /str exch def /j exch def /i exch def
    bold italic FontSelect shade setgray
    i j str strlen LabelString
end } def

/HexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimX { /i exch def
	i 0          Chars i 1 sub get 1 LabelString
	i DimY 1 add Chars i 1 sub get 1 LabelString
    } for
    1 1 DimY { /j exch def
	0 j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
	DimX 1 add j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HavannahBoardCoordinates { 3 dict begin
    false true FontSelect CoordinatesShade setgray
    /Base DimX 1 add 2 idiv  def
    1 1 Base { /i exch def
	i 0 HavannahPosn Chars  i 1 sub get 1 LabelString
	0 i HavannahPosn Digits i 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
    1 1 Base 1 sub { /i exch def
	i Base add i HavannahPosn Chars  i Base add 1 sub get 1 LabelString
	i i Base add HavannahPosn Digits i Base add 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/AltHexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimY { /j exch def
	0 j Chars j 1 sub get 1 LabelString
        %DimX 1 add j Chars j 1 sub get 1 LabelString
    } for
    1 1 DimX { /i exch def
	i 0 Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
	%i DimY 1 add Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HexDot { 3 dict begin /size exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint size 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexWhiteMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexWhitePiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexBlackMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexBlackPiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    1 setgray 0 setlinewidth fill
end } def

/HexDoubleMarker { 6 dict begin
    /shaderight exch def /shadeleft exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    gsave
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    shadeleft setgray 0 setlinewidth fill
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    shaderight setgray 0 setlinewidth fill
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    grestore
end } def

/HexBlackWhiteMarker { 0.0 1.0 HexDoubleMarker } def

/HexWhiteBlackMarker { 1.0 0.0 HexDoubleMarker } def
        
/HexMarker { 2 dict begin /j exch def /i exch def
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setlinewidth fill
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke  
end } def

/HexBlackMarker { 2 dict begin /j exch def /i exch def
    0 setgray
    i j HexMarker
end } def

/HexWhiteMarker { 2 dict begin /j exch def /i exch def
    1 setgray
    i j HexMarker
end } def
    
/HexPiece { 3 dict begin /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/MagicStone { 4 dict begin 
    /size exch def /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 1.3 mul size mul 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/HexWhitePiece { 1.0 HexPiece } def

/HexBlackPiece { 0.0 HexPiece } def

/HexWhiteLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def
    i j HexWhitePiece
    i j str strlen 0.0 true true LabelStringVerb
end } def

/HexBlackLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def 
    i j HexBlackPiece
    i j str strlen 1.0 true true LabelStringVerb
end } def

/AbsCoordX { 1 dict begin /x exch def
    OriginX x Scale mul add
end } def

/AbsCoordY { 1 dict begin /y exch def
    OriginY y Scale mul add
end } def

/DrawBox { /maxy exch def /maxx exch def /miny exch def /minx exch def
    newpath
    minx miny moveto
    maxx minx sub 0 rlineto
    0 maxy miny sub rlineto
    minx maxx sub 0 rlineto
    0 miny maxy sub rlineto
    HexLineWidth setlinewidth
    0 setgray
    stroke
} def

/HexVertex { 2 dict begin /j exch def /i exch def
    i j GraphVertexSize HexDot
end } def

/HexLine { 4 dict begin /j2 exch def /i2 exch def /j1 exch def /i1 exch def
    GraphLineWidth setlinewidth
    0 setgray
    newpath
    i1 j1 HexCenterPoint moveto
    i2 j2 HexCenterPoint lineto
    stroke
end } def

%%---------------- Program -------------------


FlatTopBoard
DrawHexBoard
1 HexBoardBorders


%------------ Trailer --------------

showpage

%%EndDocument
 @endspecial 1900 w @beginspecial 0 @llx 0 @lly 51 @urx
38 @ury 1133 @rwi @setspecial
%%BeginDocument: fz/pix/3x3.eps
%!PS-Adobe-3.0
%%Creator: Jack van Rijswijck, thanks to Cameron Browne
%%BoundingBox: 0 0 51 38
%%Pages: 0
%%EndComments

/OriginX -6 def
/OriginY 27 def
%---------------- Variables -------------------

/DimX 3 def
/DimY 3 def
/Scale 1.2 def


% draw  Hex boards, any size ... but labels only up to 26x26
% based on code by Cameron Browne, revised by Jack vR, revised by RBH
%-------------- state initializations -------------------------
1 setlinejoin   % lines meet at a point  ==>    use round join
%---------------- constants -------------------
/Root3Div2  0.86602540378444 def
/Chars   {[(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)
           (n)(o)(p)(q)(r)(s)(t)(u)(v)(w)(x)(y)(z)]} def
/CharsUC {[(A)(B)(C)(D)(E)(F)(G)(H)(I)(J)(K)(L)(M)
           (N)(O)(P)(Q)(R)(S)(T)(U)(V)(W)(X)(Y)(Z)]} def
/Digits  {[(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)(12)(13)
           (14)(15)(16)(17)(18)(19)(20)(21)(22)(23)(24)(25)(26)]} def
/HexRadius      5 Scale mul def % hexagon center-to-corner distance 
/HexLineWidth 0.1 Scale mul def 
/GraphVertexSize 1.0 Scale mul def
/GraphLineWidth 0.5 Scale mul def
/CircleRadius 3.0 Scale mul def 
/CircleLineWidth 0.346 Scale mul def 
/PerimeterWidth 0.5 Scale mul def 
/TextHeight 4.5 def
/TextWidth TextHeight 0.45 mul def 
/BoardShade 0.8 def
/CoordinatesShade 0.5 def
/MarkerSize 1.2 def
/CellOrientation 1 def   % 1: flat bottom  0: pointed bottom
/CellCorner [ % 6 cell corners, wrt center 0 0, plus "up" and "down"
   [ HexRadius  neg       0                           ] 
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul neg ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul neg ]
   [ HexRadius            0                           ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul     ]
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul neg ]
] def
%----- name cell corner indices ... see below
/Left  0 def /DownLeft 1 def /DownRight 2 def 
/Right 3 def /UpRight  4 def /UpLeft    5 def 
/Up    6 def /Down     7 def
%-----------------------------------------------------
% cell orientations:  flat bottom    flat side
%-----------------------------------------------------
% flat bottom 
% board cell indices            cell corner/top/bottom indices
%             --
%           /    \
%        --   1,3  --                  5 -6- 4
%      /    \    /    \               /       \
%   --   1,2  --   2,3  --           0         3
% /    \    /    \    /    \          \       /
%   1,1  --   2,2  --   3,3            1 -7- 2
% \    /    \    /    \    /
%   --   2,1  --   3,2  --
%      \    /    \    /   
%        --   3,1  --     
%----------------------------------------------------
% flat side 
%    /  \  /  \  /  \                       5
%   | 11 || 12 || 13 ||                   /   6
%    \  /  \  /  \  /  \                 0     4
%     || 21 || 22 || 23 |                |     |
%       \  /  \  /  \  /  \              1     3
%        || 31 || 32 || 33 |              7   /
%-------------------------------------------2--------
%----------- procedures -------------
/ScalePoint { % stack: ... x y size ==> ...  x*size y*size
   3 dict begin /size exch def /y exch def /x exch def
   x size mul           y size mul
end } def

/FlatTopBoard { FlatSideCells } def

/FlatSideCells {  % redefine cell orientation for flat side
  /CellOrientation 0 def   
  /CellCorner [ % 6 cell corners, wrt center 0 0  %xcoord ycoord
    [HexRadius Root3Div2 mul neg  HexRadius 2 div     ]
    [HexRadius Root3Div2 mul neg  HexRadius 2 div neg ]
    [0                            HexRadius neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div ]
    [0                            HexRadius ]
    [HexRadius Root3Div2 2 div mul HexRadius 0.75 mul ]
    [HexRadius Root3Div2 2 div mul neg HexRadius 0.75 mul neg ]
  ] def
} def

/HexCenterPoint { % center of cell (i,j)
    2 dict begin /j exch def /i exch def
    CellOrientation 1 eq {
    OriginX i j add HexRadius mul 1.5 mul add %Ox + (i+j)*HR*1.5
    OriginY i j sub HexRadius mul Root3Div2 mul sub %Oy - (i-j)*HR*R3/2
    }{
    OriginX i 2 j mul add HexRadius mul Root3Div2 mul add  %Ox + (2i+j)*HR
    OriginY i 1 sub HexRadius mul 1.5 mul sub %Oy - i*HR*R3/2
    } ifelse
end } def
 
/HexLine { % a b c d
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint lineto
    stroke
} def

/HexCurve { % a b c d e f
    /f exch def
    /e exch def
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint e f HexCenterPoint HexRadius 2 mul arcto
    e f HexCenterPoint lineto
    stroke
} def

/HxgnCorner { 5 dict begin /corn exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    x CellCorner corn get 0 get add
    y CellCorner corn get 1 get add
end } def

/Go { 2 dict begin /corn exch def /mag exch def
   % rlineto in a cell orientation direction
   CellCorner corn get aload pop mag ScalePoint rlineto
end } def

/TurnGo { rotate 1.0 Left Go } def % call: degrees TurnGo
/MagTurnGo { rotate Left Go } def % call: mag degrees TurnGo

/HexagonPath { % call: i j HexagonPath
    newpath 
    UpRight HxgnCorner moveto 
    6 { 1.0 Left Go 60 rotate } repeat 
} def

/FillAndStroke { 2 dict begin /sh exch def /wdth exch def
    gsave sh setgray fill
    grestore 0 setgray wdth setlinewidth stroke
end } def

/ShadedHexagon { 3 dict begin /shade exch def /j exch def /i exch def
    i j HexagonPath
    0 shade FillAndStroke
end } def

/Hexagon { % stack: ... i j
    HexagonPath 
    HexLineWidth BoardShade FillAndStroke
} def

/SemiHexagonPath { % stack: ... top i j
    newpath 
    1 eq { Left HxgnCorner moveto 
        1.0 UpRight Go 1.0 Right Go 1.0 DownRight Go stroke }{
        Right HxgnCorner moveto 
        1.0 DownLeft Go 1.0 Left Go 1.0 UpLeft Go stroke
    } ifelse
} def

/HexBoardPerimeter {
    newpath
    1 DimY UpRight HxgnCorner moveto 1.0 Left Go                      
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 rotate %restore rotation
} def

%----------- Havannah coordinates ----------------------
%                   ..  ..  ..
%                 d1  c2  b3  a4
%                   c1  b2  a3
%                     b1  a2
%                       a1
/HavannahPosn { % convert to usual coordinate, so ... x y  =>  ... 1+DimX-x  y
    exch DimX 1 add exch sub exch 
} def

/HavannahBoardPerimeter {
    newpath
    1 DimX UpRight HxgnCorner moveto 1.0 Left Go                      
    6 {Base 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo } repeat
} def

/DrawHexBoard { 2 dict begin
    gsave
    HexBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexPLBoard { 6 dict begin %point-line board
    gsave
    BoardShade setgray newpath
    -1 DimY 1 add 0.5 mul HexCenterPoint moveto
    1 DimY HexCenterPoint lineto
    DimX 1 add 0.5 mul DimY 2 add HexCenterPoint lineto
    DimX DimY HexCenterPoint lineto
    DimX 2 add DimY 1 add 0.5 mul HexCenterPoint lineto
    DimX 1 HexCenterPoint lineto
    DimX 1 add 0.5 mul -1 HexCenterPoint lineto
    1 1 HexCenterPoint lineto
    closepath fill 0 setgray
    1 DimY HexCenterPoint moveto
    1 1 DimX { /i exch def 
        i 1 i DimY HexLine 
        DimY 1 add 0.5 mul -1 i 1 HexLine
        DimY 1 add 0.5 mul DimY 2 add i DimY HexLine } for
    1 1 DimY { /j exch def 
        1 j DimX j HexLine 
        -1 DimX 1 add 0.5 mul 1 j HexLine
        DimX 2 add DimX 1 add 0.5 mul DimX j HexLine } for
    /topx 1 def /topy 1 def /btmx 1 def /btmy 1 def
    DimX DimY add 3 sub {
      topx DimX lt {/topx 1 topx add def}{/topy 1 topy add def} ifelse 
      btmy DimY lt {/btmy 1 btmy add def}{/btmx 1 btmx add def} ifelse 
      topx topy btmx btmy HexLine
      } repeat
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j HexVertex
	} for } for
    grestore
end } def

/DrawHavannahBoard { 3 dict begin
    /Base DimX 1 add 2 idiv  def
    gsave
    HavannahBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 Base { /j exch def
	Base j 1 sub sub 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    1 1 Base 1 sub { /j exch def
	1 1 DimX j sub { /i exch def
	   i j Base add 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexBorder{ 6 dict begin /start exch def 
    /cells exch def /isBlack exch def /which exch def
    gsave
    which UpLeft eq {1 DimY 1 add start sub Up HxgnCorner moveto /d Left def /r 60 def} if
    which UpRight eq {start DimY Up HxgnCorner moveto /d Right def /r 300 def} if
    which DownLeft eq {DimX 1 add start sub 1 Down HxgnCorner moveto /d Left def /r 300 def} if
    which DownRight eq {DimX start Down HxgnCorner moveto /d Right def /r 60 def} if
    0.5 d Go 
    which UpRight eq which DownRight eq or {180 rotate} if
    r TurnGo 
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.5 360 r sub MagTurnGo 1.5 360 r sub 2 mul MagTurnGo
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.75 360 r sub MagTurnGo
    closepath isBlack 1 eq {gsave fill grestore} if stroke grestore
end } def

/NoDrawHexBoard {  % dummy, used in creating bounding box
} def

/HexBoardBorders { 1 dict begin
    /upperLeftBlack exch def
    PerimeterWidth setlinewidth 0 setgray
    UpLeft    upperLeftBlack       DimY 1 DrawHexBorder
    UpRight   1 upperLeftBlack sub DimX 1 DrawHexBorder
    DownRight upperLeftBlack       DimY 1 DrawHexBorder
    DownLeft  1 upperLeftBlack sub DimX 1 DrawHexBorder
end } def

/YBoardPerimeter {
    newpath 1 1 DownRight HxgnCorner moveto 180 rotate
    3 { DimX 1 sub { 300 TurnGo 60 TurnGo } repeat 
        60 TurnGo 60 TurnGo} 
    repeat % now restore initial rotation state
    180 rotate % closepath
} def

/DrawYBoard { 2 dict begin
    YBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimX {/j exch def
        1 1 DimX 1 add j sub {/i exch def
	    i j 1 SemiHexagonPath stroke
        } for } for
end } def

/FontSelect { % bold italic FontSelect
    2 dict begin /italic exch def /bold exch def
    bold {
	italic 
	{ /Times-BoldItalic findfont TextHeight scalefont setfont } 
	{ /Times-Bold findfont TextHeight scalefont setfont }
	ifelse} 
        {
	italic {/Times-Italic findfont TextHeight scalefont setfont} 
	{ /Times findfont TextHeight scalefont setfont }
	ifelse}
    ifelse
end } def
	    
/LabelString {   % call: i j (str) strlen LabelString
%  to use with board rotation, remove comments
    6 dict begin /strlen exch def /str exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint /y exch def /x exch def
    %BoardRotation rotate
    x y moveto 
    %360 BoardRotation sub rotate
    TextWidth strlen mul 0.5 mul neg TextHeight 0.33 mul neg rmoveto
    str show 
end } def

/AbsLabelString { 4 dict begin
    /strlen exch def /str exch def /y exch def /x exch def
    newpath
    x AbsCoordX TextWidth strlen mul 0.5 mul sub
    y AbsCoordY TextHeight 0.33 mul sub
    moveto
    str
    show
end } def

/LabelStringVerb { % i j (str) strlen shade bold italic LabelStringVerb
    7 dict begin /italic exch def /bold exch def /shade exch def
    /strlen exch def /str exch def /j exch def /i exch def
    bold italic FontSelect shade setgray
    i j str strlen LabelString
end } def

/HexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimX { /i exch def
	i 0          Chars i 1 sub get 1 LabelString
	i DimY 1 add Chars i 1 sub get 1 LabelString
    } for
    1 1 DimY { /j exch def
	0 j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
	DimX 1 add j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HavannahBoardCoordinates { 3 dict begin
    false true FontSelect CoordinatesShade setgray
    /Base DimX 1 add 2 idiv  def
    1 1 Base { /i exch def
	i 0 HavannahPosn Chars  i 1 sub get 1 LabelString
	0 i HavannahPosn Digits i 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
    1 1 Base 1 sub { /i exch def
	i Base add i HavannahPosn Chars  i Base add 1 sub get 1 LabelString
	i i Base add HavannahPosn Digits i Base add 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/AltHexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimY { /j exch def
	0 j Chars j 1 sub get 1 LabelString
        %DimX 1 add j Chars j 1 sub get 1 LabelString
    } for
    1 1 DimX { /i exch def
	i 0 Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
	%i DimY 1 add Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HexDot { 3 dict begin /size exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint size 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexWhiteMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexWhitePiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexBlackMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexBlackPiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    1 setgray 0 setlinewidth fill
end } def

/HexDoubleMarker { 6 dict begin
    /shaderight exch def /shadeleft exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    gsave
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    shadeleft setgray 0 setlinewidth fill
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    shaderight setgray 0 setlinewidth fill
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    grestore
end } def

/HexBlackWhiteMarker { 0.0 1.0 HexDoubleMarker } def

/HexWhiteBlackMarker { 1.0 0.0 HexDoubleMarker } def
        
/HexMarker { 2 dict begin /j exch def /i exch def
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setlinewidth fill
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke  
end } def

/HexBlackMarker { 2 dict begin /j exch def /i exch def
    0 setgray
    i j HexMarker
end } def

/HexWhiteMarker { 2 dict begin /j exch def /i exch def
    1 setgray
    i j HexMarker
end } def
    
/HexPiece { 3 dict begin /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/MagicStone { 4 dict begin 
    /size exch def /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 1.3 mul size mul 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/HexWhitePiece { 1.0 HexPiece } def

/HexBlackPiece { 0.0 HexPiece } def

/HexWhiteLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def
    i j HexWhitePiece
    i j str strlen 0.0 true true LabelStringVerb
end } def

/HexBlackLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def 
    i j HexBlackPiece
    i j str strlen 1.0 true true LabelStringVerb
end } def

/AbsCoordX { 1 dict begin /x exch def
    OriginX x Scale mul add
end } def

/AbsCoordY { 1 dict begin /y exch def
    OriginY y Scale mul add
end } def

/DrawBox { /maxy exch def /maxx exch def /miny exch def /minx exch def
    newpath
    minx miny moveto
    maxx minx sub 0 rlineto
    0 maxy miny sub rlineto
    minx maxx sub 0 rlineto
    0 miny maxy sub rlineto
    HexLineWidth setlinewidth
    0 setgray
    stroke
} def

/HexVertex { 2 dict begin /j exch def /i exch def
    i j GraphVertexSize HexDot
end } def

/HexLine { 4 dict begin /j2 exch def /i2 exch def /j1 exch def /i1 exch def
    GraphLineWidth setlinewidth
    0 setgray
    newpath
    i1 j1 HexCenterPoint moveto
    i2 j2 HexCenterPoint lineto
    stroke
end } def

%%---------------- Program -------------------


FlatTopBoard
DrawHexBoard
1 HexBoardBorders


%------------ Trailer --------------

showpage

%%EndDocument
 @endspecial 563 3373 a @beginspecial 0 @llx 0 @lly 51
@urx 38 @ury 1133 @rwi @setspecial
%%BeginDocument: fz/pix/3x3.eps
%!PS-Adobe-3.0
%%Creator: Jack van Rijswijck, thanks to Cameron Browne
%%BoundingBox: 0 0 51 38
%%Pages: 0
%%EndComments

/OriginX -6 def
/OriginY 27 def
%---------------- Variables -------------------

/DimX 3 def
/DimY 3 def
/Scale 1.2 def


% draw  Hex boards, any size ... but labels only up to 26x26
% based on code by Cameron Browne, revised by Jack vR, revised by RBH
%-------------- state initializations -------------------------
1 setlinejoin   % lines meet at a point  ==>    use round join
%---------------- constants -------------------
/Root3Div2  0.86602540378444 def
/Chars   {[(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)
           (n)(o)(p)(q)(r)(s)(t)(u)(v)(w)(x)(y)(z)]} def
/CharsUC {[(A)(B)(C)(D)(E)(F)(G)(H)(I)(J)(K)(L)(M)
           (N)(O)(P)(Q)(R)(S)(T)(U)(V)(W)(X)(Y)(Z)]} def
/Digits  {[(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)(12)(13)
           (14)(15)(16)(17)(18)(19)(20)(21)(22)(23)(24)(25)(26)]} def
/HexRadius      5 Scale mul def % hexagon center-to-corner distance 
/HexLineWidth 0.1 Scale mul def 
/GraphVertexSize 1.0 Scale mul def
/GraphLineWidth 0.5 Scale mul def
/CircleRadius 3.0 Scale mul def 
/CircleLineWidth 0.346 Scale mul def 
/PerimeterWidth 0.5 Scale mul def 
/TextHeight 4.5 def
/TextWidth TextHeight 0.45 mul def 
/BoardShade 0.8 def
/CoordinatesShade 0.5 def
/MarkerSize 1.2 def
/CellOrientation 1 def   % 1: flat bottom  0: pointed bottom
/CellCorner [ % 6 cell corners, wrt center 0 0, plus "up" and "down"
   [ HexRadius  neg       0                           ] 
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul neg ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul neg ]
   [ HexRadius            0                           ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul     ]
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul neg ]
] def
%----- name cell corner indices ... see below
/Left  0 def /DownLeft 1 def /DownRight 2 def 
/Right 3 def /UpRight  4 def /UpLeft    5 def 
/Up    6 def /Down     7 def
%-----------------------------------------------------
% cell orientations:  flat bottom    flat side
%-----------------------------------------------------
% flat bottom 
% board cell indices            cell corner/top/bottom indices
%             --
%           /    \
%        --   1,3  --                  5 -6- 4
%      /    \    /    \               /       \
%   --   1,2  --   2,3  --           0         3
% /    \    /    \    /    \          \       /
%   1,1  --   2,2  --   3,3            1 -7- 2
% \    /    \    /    \    /
%   --   2,1  --   3,2  --
%      \    /    \    /   
%        --   3,1  --     
%----------------------------------------------------
% flat side 
%    /  \  /  \  /  \                       5
%   | 11 || 12 || 13 ||                   /   6
%    \  /  \  /  \  /  \                 0     4
%     || 21 || 22 || 23 |                |     |
%       \  /  \  /  \  /  \              1     3
%        || 31 || 32 || 33 |              7   /
%-------------------------------------------2--------
%----------- procedures -------------
/ScalePoint { % stack: ... x y size ==> ...  x*size y*size
   3 dict begin /size exch def /y exch def /x exch def
   x size mul           y size mul
end } def

/FlatTopBoard { FlatSideCells } def

/FlatSideCells {  % redefine cell orientation for flat side
  /CellOrientation 0 def   
  /CellCorner [ % 6 cell corners, wrt center 0 0  %xcoord ycoord
    [HexRadius Root3Div2 mul neg  HexRadius 2 div     ]
    [HexRadius Root3Div2 mul neg  HexRadius 2 div neg ]
    [0                            HexRadius neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div ]
    [0                            HexRadius ]
    [HexRadius Root3Div2 2 div mul HexRadius 0.75 mul ]
    [HexRadius Root3Div2 2 div mul neg HexRadius 0.75 mul neg ]
  ] def
} def

/HexCenterPoint { % center of cell (i,j)
    2 dict begin /j exch def /i exch def
    CellOrientation 1 eq {
    OriginX i j add HexRadius mul 1.5 mul add %Ox + (i+j)*HR*1.5
    OriginY i j sub HexRadius mul Root3Div2 mul sub %Oy - (i-j)*HR*R3/2
    }{
    OriginX i 2 j mul add HexRadius mul Root3Div2 mul add  %Ox + (2i+j)*HR
    OriginY i 1 sub HexRadius mul 1.5 mul sub %Oy - i*HR*R3/2
    } ifelse
end } def
 
/HexLine { % a b c d
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint lineto
    stroke
} def

/HexCurve { % a b c d e f
    /f exch def
    /e exch def
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint e f HexCenterPoint HexRadius 2 mul arcto
    e f HexCenterPoint lineto
    stroke
} def

/HxgnCorner { 5 dict begin /corn exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    x CellCorner corn get 0 get add
    y CellCorner corn get 1 get add
end } def

/Go { 2 dict begin /corn exch def /mag exch def
   % rlineto in a cell orientation direction
   CellCorner corn get aload pop mag ScalePoint rlineto
end } def

/TurnGo { rotate 1.0 Left Go } def % call: degrees TurnGo
/MagTurnGo { rotate Left Go } def % call: mag degrees TurnGo

/HexagonPath { % call: i j HexagonPath
    newpath 
    UpRight HxgnCorner moveto 
    6 { 1.0 Left Go 60 rotate } repeat 
} def

/FillAndStroke { 2 dict begin /sh exch def /wdth exch def
    gsave sh setgray fill
    grestore 0 setgray wdth setlinewidth stroke
end } def

/ShadedHexagon { 3 dict begin /shade exch def /j exch def /i exch def
    i j HexagonPath
    0 shade FillAndStroke
end } def

/Hexagon { % stack: ... i j
    HexagonPath 
    HexLineWidth BoardShade FillAndStroke
} def

/SemiHexagonPath { % stack: ... top i j
    newpath 
    1 eq { Left HxgnCorner moveto 
        1.0 UpRight Go 1.0 Right Go 1.0 DownRight Go stroke }{
        Right HxgnCorner moveto 
        1.0 DownLeft Go 1.0 Left Go 1.0 UpLeft Go stroke
    } ifelse
} def

/HexBoardPerimeter {
    newpath
    1 DimY UpRight HxgnCorner moveto 1.0 Left Go                      
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 rotate %restore rotation
} def

%----------- Havannah coordinates ----------------------
%                   ..  ..  ..
%                 d1  c2  b3  a4
%                   c1  b2  a3
%                     b1  a2
%                       a1
/HavannahPosn { % convert to usual coordinate, so ... x y  =>  ... 1+DimX-x  y
    exch DimX 1 add exch sub exch 
} def

/HavannahBoardPerimeter {
    newpath
    1 DimX UpRight HxgnCorner moveto 1.0 Left Go                      
    6 {Base 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo } repeat
} def

/DrawHexBoard { 2 dict begin
    gsave
    HexBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexPLBoard { 6 dict begin %point-line board
    gsave
    BoardShade setgray newpath
    -1 DimY 1 add 0.5 mul HexCenterPoint moveto
    1 DimY HexCenterPoint lineto
    DimX 1 add 0.5 mul DimY 2 add HexCenterPoint lineto
    DimX DimY HexCenterPoint lineto
    DimX 2 add DimY 1 add 0.5 mul HexCenterPoint lineto
    DimX 1 HexCenterPoint lineto
    DimX 1 add 0.5 mul -1 HexCenterPoint lineto
    1 1 HexCenterPoint lineto
    closepath fill 0 setgray
    1 DimY HexCenterPoint moveto
    1 1 DimX { /i exch def 
        i 1 i DimY HexLine 
        DimY 1 add 0.5 mul -1 i 1 HexLine
        DimY 1 add 0.5 mul DimY 2 add i DimY HexLine } for
    1 1 DimY { /j exch def 
        1 j DimX j HexLine 
        -1 DimX 1 add 0.5 mul 1 j HexLine
        DimX 2 add DimX 1 add 0.5 mul DimX j HexLine } for
    /topx 1 def /topy 1 def /btmx 1 def /btmy 1 def
    DimX DimY add 3 sub {
      topx DimX lt {/topx 1 topx add def}{/topy 1 topy add def} ifelse 
      btmy DimY lt {/btmy 1 btmy add def}{/btmx 1 btmx add def} ifelse 
      topx topy btmx btmy HexLine
      } repeat
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j HexVertex
	} for } for
    grestore
end } def

/DrawHavannahBoard { 3 dict begin
    /Base DimX 1 add 2 idiv  def
    gsave
    HavannahBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 Base { /j exch def
	Base j 1 sub sub 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    1 1 Base 1 sub { /j exch def
	1 1 DimX j sub { /i exch def
	   i j Base add 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexBorder{ 6 dict begin /start exch def 
    /cells exch def /isBlack exch def /which exch def
    gsave
    which UpLeft eq {1 DimY 1 add start sub Up HxgnCorner moveto /d Left def /r 60 def} if
    which UpRight eq {start DimY Up HxgnCorner moveto /d Right def /r 300 def} if
    which DownLeft eq {DimX 1 add start sub 1 Down HxgnCorner moveto /d Left def /r 300 def} if
    which DownRight eq {DimX start Down HxgnCorner moveto /d Right def /r 60 def} if
    0.5 d Go 
    which UpRight eq which DownRight eq or {180 rotate} if
    r TurnGo 
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.5 360 r sub MagTurnGo 1.5 360 r sub 2 mul MagTurnGo
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.75 360 r sub MagTurnGo
    closepath isBlack 1 eq {gsave fill grestore} if stroke grestore
end } def

/NoDrawHexBoard {  % dummy, used in creating bounding box
} def

/HexBoardBorders { 1 dict begin
    /upperLeftBlack exch def
    PerimeterWidth setlinewidth 0 setgray
    UpLeft    upperLeftBlack       DimY 1 DrawHexBorder
    UpRight   1 upperLeftBlack sub DimX 1 DrawHexBorder
    DownRight upperLeftBlack       DimY 1 DrawHexBorder
    DownLeft  1 upperLeftBlack sub DimX 1 DrawHexBorder
end } def

/YBoardPerimeter {
    newpath 1 1 DownRight HxgnCorner moveto 180 rotate
    3 { DimX 1 sub { 300 TurnGo 60 TurnGo } repeat 
        60 TurnGo 60 TurnGo} 
    repeat % now restore initial rotation state
    180 rotate % closepath
} def

/DrawYBoard { 2 dict begin
    YBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimX {/j exch def
        1 1 DimX 1 add j sub {/i exch def
	    i j 1 SemiHexagonPath stroke
        } for } for
end } def

/FontSelect { % bold italic FontSelect
    2 dict begin /italic exch def /bold exch def
    bold {
	italic 
	{ /Times-BoldItalic findfont TextHeight scalefont setfont } 
	{ /Times-Bold findfont TextHeight scalefont setfont }
	ifelse} 
        {
	italic {/Times-Italic findfont TextHeight scalefont setfont} 
	{ /Times findfont TextHeight scalefont setfont }
	ifelse}
    ifelse
end } def
	    
/LabelString {   % call: i j (str) strlen LabelString
%  to use with board rotation, remove comments
    6 dict begin /strlen exch def /str exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint /y exch def /x exch def
    %BoardRotation rotate
    x y moveto 
    %360 BoardRotation sub rotate
    TextWidth strlen mul 0.5 mul neg TextHeight 0.33 mul neg rmoveto
    str show 
end } def

/AbsLabelString { 4 dict begin
    /strlen exch def /str exch def /y exch def /x exch def
    newpath
    x AbsCoordX TextWidth strlen mul 0.5 mul sub
    y AbsCoordY TextHeight 0.33 mul sub
    moveto
    str
    show
end } def

/LabelStringVerb { % i j (str) strlen shade bold italic LabelStringVerb
    7 dict begin /italic exch def /bold exch def /shade exch def
    /strlen exch def /str exch def /j exch def /i exch def
    bold italic FontSelect shade setgray
    i j str strlen LabelString
end } def

/HexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimX { /i exch def
	i 0          Chars i 1 sub get 1 LabelString
	i DimY 1 add Chars i 1 sub get 1 LabelString
    } for
    1 1 DimY { /j exch def
	0 j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
	DimX 1 add j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HavannahBoardCoordinates { 3 dict begin
    false true FontSelect CoordinatesShade setgray
    /Base DimX 1 add 2 idiv  def
    1 1 Base { /i exch def
	i 0 HavannahPosn Chars  i 1 sub get 1 LabelString
	0 i HavannahPosn Digits i 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
    1 1 Base 1 sub { /i exch def
	i Base add i HavannahPosn Chars  i Base add 1 sub get 1 LabelString
	i i Base add HavannahPosn Digits i Base add 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/AltHexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimY { /j exch def
	0 j Chars j 1 sub get 1 LabelString
        %DimX 1 add j Chars j 1 sub get 1 LabelString
    } for
    1 1 DimX { /i exch def
	i 0 Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
	%i DimY 1 add Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HexDot { 3 dict begin /size exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint size 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexWhiteMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexWhitePiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexBlackMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexBlackPiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    1 setgray 0 setlinewidth fill
end } def

/HexDoubleMarker { 6 dict begin
    /shaderight exch def /shadeleft exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    gsave
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    shadeleft setgray 0 setlinewidth fill
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    shaderight setgray 0 setlinewidth fill
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    grestore
end } def

/HexBlackWhiteMarker { 0.0 1.0 HexDoubleMarker } def

/HexWhiteBlackMarker { 1.0 0.0 HexDoubleMarker } def
        
/HexMarker { 2 dict begin /j exch def /i exch def
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setlinewidth fill
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke  
end } def

/HexBlackMarker { 2 dict begin /j exch def /i exch def
    0 setgray
    i j HexMarker
end } def

/HexWhiteMarker { 2 dict begin /j exch def /i exch def
    1 setgray
    i j HexMarker
end } def
    
/HexPiece { 3 dict begin /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/MagicStone { 4 dict begin 
    /size exch def /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 1.3 mul size mul 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/HexWhitePiece { 1.0 HexPiece } def

/HexBlackPiece { 0.0 HexPiece } def

/HexWhiteLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def
    i j HexWhitePiece
    i j str strlen 0.0 true true LabelStringVerb
end } def

/HexBlackLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def 
    i j HexBlackPiece
    i j str strlen 1.0 true true LabelStringVerb
end } def

/AbsCoordX { 1 dict begin /x exch def
    OriginX x Scale mul add
end } def

/AbsCoordY { 1 dict begin /y exch def
    OriginY y Scale mul add
end } def

/DrawBox { /maxy exch def /maxx exch def /miny exch def /minx exch def
    newpath
    minx miny moveto
    maxx minx sub 0 rlineto
    0 maxy miny sub rlineto
    minx maxx sub 0 rlineto
    0 miny maxy sub rlineto
    HexLineWidth setlinewidth
    0 setgray
    stroke
} def

/HexVertex { 2 dict begin /j exch def /i exch def
    i j GraphVertexSize HexDot
end } def

/HexLine { 4 dict begin /j2 exch def /i2 exch def /j1 exch def /i1 exch def
    GraphLineWidth setlinewidth
    0 setgray
    newpath
    i1 j1 HexCenterPoint moveto
    i2 j2 HexCenterPoint lineto
    stroke
end } def

%%---------------- Program -------------------


FlatTopBoard
DrawHexBoard
1 HexBoardBorders


%------------ Trailer --------------

showpage

%%EndDocument
 @endspecial 1900 w @beginspecial 0 @llx 0 @lly 51 @urx
38 @ury 1133 @rwi @setspecial
%%BeginDocument: fz/pix/3x3.eps
%!PS-Adobe-3.0
%%Creator: Jack van Rijswijck, thanks to Cameron Browne
%%BoundingBox: 0 0 51 38
%%Pages: 0
%%EndComments

/OriginX -6 def
/OriginY 27 def
%---------------- Variables -------------------

/DimX 3 def
/DimY 3 def
/Scale 1.2 def


% draw  Hex boards, any size ... but labels only up to 26x26
% based on code by Cameron Browne, revised by Jack vR, revised by RBH
%-------------- state initializations -------------------------
1 setlinejoin   % lines meet at a point  ==>    use round join
%---------------- constants -------------------
/Root3Div2  0.86602540378444 def
/Chars   {[(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)
           (n)(o)(p)(q)(r)(s)(t)(u)(v)(w)(x)(y)(z)]} def
/CharsUC {[(A)(B)(C)(D)(E)(F)(G)(H)(I)(J)(K)(L)(M)
           (N)(O)(P)(Q)(R)(S)(T)(U)(V)(W)(X)(Y)(Z)]} def
/Digits  {[(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)(12)(13)
           (14)(15)(16)(17)(18)(19)(20)(21)(22)(23)(24)(25)(26)]} def
/HexRadius      5 Scale mul def % hexagon center-to-corner distance 
/HexLineWidth 0.1 Scale mul def 
/GraphVertexSize 1.0 Scale mul def
/GraphLineWidth 0.5 Scale mul def
/CircleRadius 3.0 Scale mul def 
/CircleLineWidth 0.346 Scale mul def 
/PerimeterWidth 0.5 Scale mul def 
/TextHeight 4.5 def
/TextWidth TextHeight 0.45 mul def 
/BoardShade 0.8 def
/CoordinatesShade 0.5 def
/MarkerSize 1.2 def
/CellOrientation 1 def   % 1: flat bottom  0: pointed bottom
/CellCorner [ % 6 cell corners, wrt center 0 0, plus "up" and "down"
   [ HexRadius  neg       0                           ] 
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul neg ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul neg ]
   [ HexRadius            0                           ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul     ]
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul neg ]
] def
%----- name cell corner indices ... see below
/Left  0 def /DownLeft 1 def /DownRight 2 def 
/Right 3 def /UpRight  4 def /UpLeft    5 def 
/Up    6 def /Down     7 def
%-----------------------------------------------------
% cell orientations:  flat bottom    flat side
%-----------------------------------------------------
% flat bottom 
% board cell indices            cell corner/top/bottom indices
%             --
%           /    \
%        --   1,3  --                  5 -6- 4
%      /    \    /    \               /       \
%   --   1,2  --   2,3  --           0         3
% /    \    /    \    /    \          \       /
%   1,1  --   2,2  --   3,3            1 -7- 2
% \    /    \    /    \    /
%   --   2,1  --   3,2  --
%      \    /    \    /   
%        --   3,1  --     
%----------------------------------------------------
% flat side 
%    /  \  /  \  /  \                       5
%   | 11 || 12 || 13 ||                   /   6
%    \  /  \  /  \  /  \                 0     4
%     || 21 || 22 || 23 |                |     |
%       \  /  \  /  \  /  \              1     3
%        || 31 || 32 || 33 |              7   /
%-------------------------------------------2--------
%----------- procedures -------------
/ScalePoint { % stack: ... x y size ==> ...  x*size y*size
   3 dict begin /size exch def /y exch def /x exch def
   x size mul           y size mul
end } def

/FlatTopBoard { FlatSideCells } def

/FlatSideCells {  % redefine cell orientation for flat side
  /CellOrientation 0 def   
  /CellCorner [ % 6 cell corners, wrt center 0 0  %xcoord ycoord
    [HexRadius Root3Div2 mul neg  HexRadius 2 div     ]
    [HexRadius Root3Div2 mul neg  HexRadius 2 div neg ]
    [0                            HexRadius neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div ]
    [0                            HexRadius ]
    [HexRadius Root3Div2 2 div mul HexRadius 0.75 mul ]
    [HexRadius Root3Div2 2 div mul neg HexRadius 0.75 mul neg ]
  ] def
} def

/HexCenterPoint { % center of cell (i,j)
    2 dict begin /j exch def /i exch def
    CellOrientation 1 eq {
    OriginX i j add HexRadius mul 1.5 mul add %Ox + (i+j)*HR*1.5
    OriginY i j sub HexRadius mul Root3Div2 mul sub %Oy - (i-j)*HR*R3/2
    }{
    OriginX i 2 j mul add HexRadius mul Root3Div2 mul add  %Ox + (2i+j)*HR
    OriginY i 1 sub HexRadius mul 1.5 mul sub %Oy - i*HR*R3/2
    } ifelse
end } def
 
/HexLine { % a b c d
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint lineto
    stroke
} def

/HexCurve { % a b c d e f
    /f exch def
    /e exch def
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint e f HexCenterPoint HexRadius 2 mul arcto
    e f HexCenterPoint lineto
    stroke
} def

/HxgnCorner { 5 dict begin /corn exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    x CellCorner corn get 0 get add
    y CellCorner corn get 1 get add
end } def

/Go { 2 dict begin /corn exch def /mag exch def
   % rlineto in a cell orientation direction
   CellCorner corn get aload pop mag ScalePoint rlineto
end } def

/TurnGo { rotate 1.0 Left Go } def % call: degrees TurnGo
/MagTurnGo { rotate Left Go } def % call: mag degrees TurnGo

/HexagonPath { % call: i j HexagonPath
    newpath 
    UpRight HxgnCorner moveto 
    6 { 1.0 Left Go 60 rotate } repeat 
} def

/FillAndStroke { 2 dict begin /sh exch def /wdth exch def
    gsave sh setgray fill
    grestore 0 setgray wdth setlinewidth stroke
end } def

/ShadedHexagon { 3 dict begin /shade exch def /j exch def /i exch def
    i j HexagonPath
    0 shade FillAndStroke
end } def

/Hexagon { % stack: ... i j
    HexagonPath 
    HexLineWidth BoardShade FillAndStroke
} def

/SemiHexagonPath { % stack: ... top i j
    newpath 
    1 eq { Left HxgnCorner moveto 
        1.0 UpRight Go 1.0 Right Go 1.0 DownRight Go stroke }{
        Right HxgnCorner moveto 
        1.0 DownLeft Go 1.0 Left Go 1.0 UpLeft Go stroke
    } ifelse
} def

/HexBoardPerimeter {
    newpath
    1 DimY UpRight HxgnCorner moveto 1.0 Left Go                      
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 rotate %restore rotation
} def

%----------- Havannah coordinates ----------------------
%                   ..  ..  ..
%                 d1  c2  b3  a4
%                   c1  b2  a3
%                     b1  a2
%                       a1
/HavannahPosn { % convert to usual coordinate, so ... x y  =>  ... 1+DimX-x  y
    exch DimX 1 add exch sub exch 
} def

/HavannahBoardPerimeter {
    newpath
    1 DimX UpRight HxgnCorner moveto 1.0 Left Go                      
    6 {Base 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo } repeat
} def

/DrawHexBoard { 2 dict begin
    gsave
    HexBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexPLBoard { 6 dict begin %point-line board
    gsave
    BoardShade setgray newpath
    -1 DimY 1 add 0.5 mul HexCenterPoint moveto
    1 DimY HexCenterPoint lineto
    DimX 1 add 0.5 mul DimY 2 add HexCenterPoint lineto
    DimX DimY HexCenterPoint lineto
    DimX 2 add DimY 1 add 0.5 mul HexCenterPoint lineto
    DimX 1 HexCenterPoint lineto
    DimX 1 add 0.5 mul -1 HexCenterPoint lineto
    1 1 HexCenterPoint lineto
    closepath fill 0 setgray
    1 DimY HexCenterPoint moveto
    1 1 DimX { /i exch def 
        i 1 i DimY HexLine 
        DimY 1 add 0.5 mul -1 i 1 HexLine
        DimY 1 add 0.5 mul DimY 2 add i DimY HexLine } for
    1 1 DimY { /j exch def 
        1 j DimX j HexLine 
        -1 DimX 1 add 0.5 mul 1 j HexLine
        DimX 2 add DimX 1 add 0.5 mul DimX j HexLine } for
    /topx 1 def /topy 1 def /btmx 1 def /btmy 1 def
    DimX DimY add 3 sub {
      topx DimX lt {/topx 1 topx add def}{/topy 1 topy add def} ifelse 
      btmy DimY lt {/btmy 1 btmy add def}{/btmx 1 btmx add def} ifelse 
      topx topy btmx btmy HexLine
      } repeat
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j HexVertex
	} for } for
    grestore
end } def

/DrawHavannahBoard { 3 dict begin
    /Base DimX 1 add 2 idiv  def
    gsave
    HavannahBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 Base { /j exch def
	Base j 1 sub sub 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    1 1 Base 1 sub { /j exch def
	1 1 DimX j sub { /i exch def
	   i j Base add 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexBorder{ 6 dict begin /start exch def 
    /cells exch def /isBlack exch def /which exch def
    gsave
    which UpLeft eq {1 DimY 1 add start sub Up HxgnCorner moveto /d Left def /r 60 def} if
    which UpRight eq {start DimY Up HxgnCorner moveto /d Right def /r 300 def} if
    which DownLeft eq {DimX 1 add start sub 1 Down HxgnCorner moveto /d Left def /r 300 def} if
    which DownRight eq {DimX start Down HxgnCorner moveto /d Right def /r 60 def} if
    0.5 d Go 
    which UpRight eq which DownRight eq or {180 rotate} if
    r TurnGo 
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.5 360 r sub MagTurnGo 1.5 360 r sub 2 mul MagTurnGo
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.75 360 r sub MagTurnGo
    closepath isBlack 1 eq {gsave fill grestore} if stroke grestore
end } def

/NoDrawHexBoard {  % dummy, used in creating bounding box
} def

/HexBoardBorders { 1 dict begin
    /upperLeftBlack exch def
    PerimeterWidth setlinewidth 0 setgray
    UpLeft    upperLeftBlack       DimY 1 DrawHexBorder
    UpRight   1 upperLeftBlack sub DimX 1 DrawHexBorder
    DownRight upperLeftBlack       DimY 1 DrawHexBorder
    DownLeft  1 upperLeftBlack sub DimX 1 DrawHexBorder
end } def

/YBoardPerimeter {
    newpath 1 1 DownRight HxgnCorner moveto 180 rotate
    3 { DimX 1 sub { 300 TurnGo 60 TurnGo } repeat 
        60 TurnGo 60 TurnGo} 
    repeat % now restore initial rotation state
    180 rotate % closepath
} def

/DrawYBoard { 2 dict begin
    YBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimX {/j exch def
        1 1 DimX 1 add j sub {/i exch def
	    i j 1 SemiHexagonPath stroke
        } for } for
end } def

/FontSelect { % bold italic FontSelect
    2 dict begin /italic exch def /bold exch def
    bold {
	italic 
	{ /Times-BoldItalic findfont TextHeight scalefont setfont } 
	{ /Times-Bold findfont TextHeight scalefont setfont }
	ifelse} 
        {
	italic {/Times-Italic findfont TextHeight scalefont setfont} 
	{ /Times findfont TextHeight scalefont setfont }
	ifelse}
    ifelse
end } def
	    
/LabelString {   % call: i j (str) strlen LabelString
%  to use with board rotation, remove comments
    6 dict begin /strlen exch def /str exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint /y exch def /x exch def
    %BoardRotation rotate
    x y moveto 
    %360 BoardRotation sub rotate
    TextWidth strlen mul 0.5 mul neg TextHeight 0.33 mul neg rmoveto
    str show 
end } def

/AbsLabelString { 4 dict begin
    /strlen exch def /str exch def /y exch def /x exch def
    newpath
    x AbsCoordX TextWidth strlen mul 0.5 mul sub
    y AbsCoordY TextHeight 0.33 mul sub
    moveto
    str
    show
end } def

/LabelStringVerb { % i j (str) strlen shade bold italic LabelStringVerb
    7 dict begin /italic exch def /bold exch def /shade exch def
    /strlen exch def /str exch def /j exch def /i exch def
    bold italic FontSelect shade setgray
    i j str strlen LabelString
end } def

/HexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimX { /i exch def
	i 0          Chars i 1 sub get 1 LabelString
	i DimY 1 add Chars i 1 sub get 1 LabelString
    } for
    1 1 DimY { /j exch def
	0 j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
	DimX 1 add j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HavannahBoardCoordinates { 3 dict begin
    false true FontSelect CoordinatesShade setgray
    /Base DimX 1 add 2 idiv  def
    1 1 Base { /i exch def
	i 0 HavannahPosn Chars  i 1 sub get 1 LabelString
	0 i HavannahPosn Digits i 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
    1 1 Base 1 sub { /i exch def
	i Base add i HavannahPosn Chars  i Base add 1 sub get 1 LabelString
	i i Base add HavannahPosn Digits i Base add 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/AltHexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimY { /j exch def
	0 j Chars j 1 sub get 1 LabelString
        %DimX 1 add j Chars j 1 sub get 1 LabelString
    } for
    1 1 DimX { /i exch def
	i 0 Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
	%i DimY 1 add Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HexDot { 3 dict begin /size exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint size 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexWhiteMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexWhitePiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexBlackMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexBlackPiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    1 setgray 0 setlinewidth fill
end } def

/HexDoubleMarker { 6 dict begin
    /shaderight exch def /shadeleft exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    gsave
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    shadeleft setgray 0 setlinewidth fill
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    shaderight setgray 0 setlinewidth fill
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    grestore
end } def

/HexBlackWhiteMarker { 0.0 1.0 HexDoubleMarker } def

/HexWhiteBlackMarker { 1.0 0.0 HexDoubleMarker } def
        
/HexMarker { 2 dict begin /j exch def /i exch def
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setlinewidth fill
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke  
end } def

/HexBlackMarker { 2 dict begin /j exch def /i exch def
    0 setgray
    i j HexMarker
end } def

/HexWhiteMarker { 2 dict begin /j exch def /i exch def
    1 setgray
    i j HexMarker
end } def
    
/HexPiece { 3 dict begin /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/MagicStone { 4 dict begin 
    /size exch def /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 1.3 mul size mul 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/HexWhitePiece { 1.0 HexPiece } def

/HexBlackPiece { 0.0 HexPiece } def

/HexWhiteLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def
    i j HexWhitePiece
    i j str strlen 0.0 true true LabelStringVerb
end } def

/HexBlackLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def 
    i j HexBlackPiece
    i j str strlen 1.0 true true LabelStringVerb
end } def

/AbsCoordX { 1 dict begin /x exch def
    OriginX x Scale mul add
end } def

/AbsCoordY { 1 dict begin /y exch def
    OriginY y Scale mul add
end } def

/DrawBox { /maxy exch def /maxx exch def /miny exch def /minx exch def
    newpath
    minx miny moveto
    maxx minx sub 0 rlineto
    0 maxy miny sub rlineto
    minx maxx sub 0 rlineto
    0 miny maxy sub rlineto
    HexLineWidth setlinewidth
    0 setgray
    stroke
} def

/HexVertex { 2 dict begin /j exch def /i exch def
    i j GraphVertexSize HexDot
end } def

/HexLine { 4 dict begin /j2 exch def /i2 exch def /j1 exch def /i1 exch def
    GraphLineWidth setlinewidth
    0 setgray
    newpath
    i1 j1 HexCenterPoint moveto
    i2 j2 HexCenterPoint lineto
    stroke
end } def

%%---------------- Program -------------------


FlatTopBoard
DrawHexBoard
1 HexBoardBorders


%------------ Trailer --------------

showpage

%%EndDocument
 @endspecial 1900 w @beginspecial 0 @llx 0 @lly 51 @urx
38 @ury 1133 @rwi @setspecial
%%BeginDocument: fz/pix/3x3.eps
%!PS-Adobe-3.0
%%Creator: Jack van Rijswijck, thanks to Cameron Browne
%%BoundingBox: 0 0 51 38
%%Pages: 0
%%EndComments

/OriginX -6 def
/OriginY 27 def
%---------------- Variables -------------------

/DimX 3 def
/DimY 3 def
/Scale 1.2 def


% draw  Hex boards, any size ... but labels only up to 26x26
% based on code by Cameron Browne, revised by Jack vR, revised by RBH
%-------------- state initializations -------------------------
1 setlinejoin   % lines meet at a point  ==>    use round join
%---------------- constants -------------------
/Root3Div2  0.86602540378444 def
/Chars   {[(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)
           (n)(o)(p)(q)(r)(s)(t)(u)(v)(w)(x)(y)(z)]} def
/CharsUC {[(A)(B)(C)(D)(E)(F)(G)(H)(I)(J)(K)(L)(M)
           (N)(O)(P)(Q)(R)(S)(T)(U)(V)(W)(X)(Y)(Z)]} def
/Digits  {[(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)(12)(13)
           (14)(15)(16)(17)(18)(19)(20)(21)(22)(23)(24)(25)(26)]} def
/HexRadius      5 Scale mul def % hexagon center-to-corner distance 
/HexLineWidth 0.1 Scale mul def 
/GraphVertexSize 1.0 Scale mul def
/GraphLineWidth 0.5 Scale mul def
/CircleRadius 3.0 Scale mul def 
/CircleLineWidth 0.346 Scale mul def 
/PerimeterWidth 0.5 Scale mul def 
/TextHeight 4.5 def
/TextWidth TextHeight 0.45 mul def 
/BoardShade 0.8 def
/CoordinatesShade 0.5 def
/MarkerSize 1.2 def
/CellOrientation 1 def   % 1: flat bottom  0: pointed bottom
/CellCorner [ % 6 cell corners, wrt center 0 0, plus "up" and "down"
   [ HexRadius  neg       0                           ] 
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul neg ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul neg ]
   [ HexRadius            0                           ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul     ]
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul neg ]
] def
%----- name cell corner indices ... see below
/Left  0 def /DownLeft 1 def /DownRight 2 def 
/Right 3 def /UpRight  4 def /UpLeft    5 def 
/Up    6 def /Down     7 def
%-----------------------------------------------------
% cell orientations:  flat bottom    flat side
%-----------------------------------------------------
% flat bottom 
% board cell indices            cell corner/top/bottom indices
%             --
%           /    \
%        --   1,3  --                  5 -6- 4
%      /    \    /    \               /       \
%   --   1,2  --   2,3  --           0         3
% /    \    /    \    /    \          \       /
%   1,1  --   2,2  --   3,3            1 -7- 2
% \    /    \    /    \    /
%   --   2,1  --   3,2  --
%      \    /    \    /   
%        --   3,1  --     
%----------------------------------------------------
% flat side 
%    /  \  /  \  /  \                       5
%   | 11 || 12 || 13 ||                   /   6
%    \  /  \  /  \  /  \                 0     4
%     || 21 || 22 || 23 |                |     |
%       \  /  \  /  \  /  \              1     3
%        || 31 || 32 || 33 |              7   /
%-------------------------------------------2--------
%----------- procedures -------------
/ScalePoint { % stack: ... x y size ==> ...  x*size y*size
   3 dict begin /size exch def /y exch def /x exch def
   x size mul           y size mul
end } def

/FlatTopBoard { FlatSideCells } def

/FlatSideCells {  % redefine cell orientation for flat side
  /CellOrientation 0 def   
  /CellCorner [ % 6 cell corners, wrt center 0 0  %xcoord ycoord
    [HexRadius Root3Div2 mul neg  HexRadius 2 div     ]
    [HexRadius Root3Div2 mul neg  HexRadius 2 div neg ]
    [0                            HexRadius neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div ]
    [0                            HexRadius ]
    [HexRadius Root3Div2 2 div mul HexRadius 0.75 mul ]
    [HexRadius Root3Div2 2 div mul neg HexRadius 0.75 mul neg ]
  ] def
} def

/HexCenterPoint { % center of cell (i,j)
    2 dict begin /j exch def /i exch def
    CellOrientation 1 eq {
    OriginX i j add HexRadius mul 1.5 mul add %Ox + (i+j)*HR*1.5
    OriginY i j sub HexRadius mul Root3Div2 mul sub %Oy - (i-j)*HR*R3/2
    }{
    OriginX i 2 j mul add HexRadius mul Root3Div2 mul add  %Ox + (2i+j)*HR
    OriginY i 1 sub HexRadius mul 1.5 mul sub %Oy - i*HR*R3/2
    } ifelse
end } def
 
/HexLine { % a b c d
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint lineto
    stroke
} def

/HexCurve { % a b c d e f
    /f exch def
    /e exch def
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint e f HexCenterPoint HexRadius 2 mul arcto
    e f HexCenterPoint lineto
    stroke
} def

/HxgnCorner { 5 dict begin /corn exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    x CellCorner corn get 0 get add
    y CellCorner corn get 1 get add
end } def

/Go { 2 dict begin /corn exch def /mag exch def
   % rlineto in a cell orientation direction
   CellCorner corn get aload pop mag ScalePoint rlineto
end } def

/TurnGo { rotate 1.0 Left Go } def % call: degrees TurnGo
/MagTurnGo { rotate Left Go } def % call: mag degrees TurnGo

/HexagonPath { % call: i j HexagonPath
    newpath 
    UpRight HxgnCorner moveto 
    6 { 1.0 Left Go 60 rotate } repeat 
} def

/FillAndStroke { 2 dict begin /sh exch def /wdth exch def
    gsave sh setgray fill
    grestore 0 setgray wdth setlinewidth stroke
end } def

/ShadedHexagon { 3 dict begin /shade exch def /j exch def /i exch def
    i j HexagonPath
    0 shade FillAndStroke
end } def

/Hexagon { % stack: ... i j
    HexagonPath 
    HexLineWidth BoardShade FillAndStroke
} def

/SemiHexagonPath { % stack: ... top i j
    newpath 
    1 eq { Left HxgnCorner moveto 
        1.0 UpRight Go 1.0 Right Go 1.0 DownRight Go stroke }{
        Right HxgnCorner moveto 
        1.0 DownLeft Go 1.0 Left Go 1.0 UpLeft Go stroke
    } ifelse
} def

/HexBoardPerimeter {
    newpath
    1 DimY UpRight HxgnCorner moveto 1.0 Left Go                      
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 rotate %restore rotation
} def

%----------- Havannah coordinates ----------------------
%                   ..  ..  ..
%                 d1  c2  b3  a4
%                   c1  b2  a3
%                     b1  a2
%                       a1
/HavannahPosn { % convert to usual coordinate, so ... x y  =>  ... 1+DimX-x  y
    exch DimX 1 add exch sub exch 
} def

/HavannahBoardPerimeter {
    newpath
    1 DimX UpRight HxgnCorner moveto 1.0 Left Go                      
    6 {Base 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo } repeat
} def

/DrawHexBoard { 2 dict begin
    gsave
    HexBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexPLBoard { 6 dict begin %point-line board
    gsave
    BoardShade setgray newpath
    -1 DimY 1 add 0.5 mul HexCenterPoint moveto
    1 DimY HexCenterPoint lineto
    DimX 1 add 0.5 mul DimY 2 add HexCenterPoint lineto
    DimX DimY HexCenterPoint lineto
    DimX 2 add DimY 1 add 0.5 mul HexCenterPoint lineto
    DimX 1 HexCenterPoint lineto
    DimX 1 add 0.5 mul -1 HexCenterPoint lineto
    1 1 HexCenterPoint lineto
    closepath fill 0 setgray
    1 DimY HexCenterPoint moveto
    1 1 DimX { /i exch def 
        i 1 i DimY HexLine 
        DimY 1 add 0.5 mul -1 i 1 HexLine
        DimY 1 add 0.5 mul DimY 2 add i DimY HexLine } for
    1 1 DimY { /j exch def 
        1 j DimX j HexLine 
        -1 DimX 1 add 0.5 mul 1 j HexLine
        DimX 2 add DimX 1 add 0.5 mul DimX j HexLine } for
    /topx 1 def /topy 1 def /btmx 1 def /btmy 1 def
    DimX DimY add 3 sub {
      topx DimX lt {/topx 1 topx add def}{/topy 1 topy add def} ifelse 
      btmy DimY lt {/btmy 1 btmy add def}{/btmx 1 btmx add def} ifelse 
      topx topy btmx btmy HexLine
      } repeat
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j HexVertex
	} for } for
    grestore
end } def

/DrawHavannahBoard { 3 dict begin
    /Base DimX 1 add 2 idiv  def
    gsave
    HavannahBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 Base { /j exch def
	Base j 1 sub sub 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    1 1 Base 1 sub { /j exch def
	1 1 DimX j sub { /i exch def
	   i j Base add 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexBorder{ 6 dict begin /start exch def 
    /cells exch def /isBlack exch def /which exch def
    gsave
    which UpLeft eq {1 DimY 1 add start sub Up HxgnCorner moveto /d Left def /r 60 def} if
    which UpRight eq {start DimY Up HxgnCorner moveto /d Right def /r 300 def} if
    which DownLeft eq {DimX 1 add start sub 1 Down HxgnCorner moveto /d Left def /r 300 def} if
    which DownRight eq {DimX start Down HxgnCorner moveto /d Right def /r 60 def} if
    0.5 d Go 
    which UpRight eq which DownRight eq or {180 rotate} if
    r TurnGo 
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.5 360 r sub MagTurnGo 1.5 360 r sub 2 mul MagTurnGo
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.75 360 r sub MagTurnGo
    closepath isBlack 1 eq {gsave fill grestore} if stroke grestore
end } def

/NoDrawHexBoard {  % dummy, used in creating bounding box
} def

/HexBoardBorders { 1 dict begin
    /upperLeftBlack exch def
    PerimeterWidth setlinewidth 0 setgray
    UpLeft    upperLeftBlack       DimY 1 DrawHexBorder
    UpRight   1 upperLeftBlack sub DimX 1 DrawHexBorder
    DownRight upperLeftBlack       DimY 1 DrawHexBorder
    DownLeft  1 upperLeftBlack sub DimX 1 DrawHexBorder
end } def

/YBoardPerimeter {
    newpath 1 1 DownRight HxgnCorner moveto 180 rotate
    3 { DimX 1 sub { 300 TurnGo 60 TurnGo } repeat 
        60 TurnGo 60 TurnGo} 
    repeat % now restore initial rotation state
    180 rotate % closepath
} def

/DrawYBoard { 2 dict begin
    YBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimX {/j exch def
        1 1 DimX 1 add j sub {/i exch def
	    i j 1 SemiHexagonPath stroke
        } for } for
end } def

/FontSelect { % bold italic FontSelect
    2 dict begin /italic exch def /bold exch def
    bold {
	italic 
	{ /Times-BoldItalic findfont TextHeight scalefont setfont } 
	{ /Times-Bold findfont TextHeight scalefont setfont }
	ifelse} 
        {
	italic {/Times-Italic findfont TextHeight scalefont setfont} 
	{ /Times findfont TextHeight scalefont setfont }
	ifelse}
    ifelse
end } def
	    
/LabelString {   % call: i j (str) strlen LabelString
%  to use with board rotation, remove comments
    6 dict begin /strlen exch def /str exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint /y exch def /x exch def
    %BoardRotation rotate
    x y moveto 
    %360 BoardRotation sub rotate
    TextWidth strlen mul 0.5 mul neg TextHeight 0.33 mul neg rmoveto
    str show 
end } def

/AbsLabelString { 4 dict begin
    /strlen exch def /str exch def /y exch def /x exch def
    newpath
    x AbsCoordX TextWidth strlen mul 0.5 mul sub
    y AbsCoordY TextHeight 0.33 mul sub
    moveto
    str
    show
end } def

/LabelStringVerb { % i j (str) strlen shade bold italic LabelStringVerb
    7 dict begin /italic exch def /bold exch def /shade exch def
    /strlen exch def /str exch def /j exch def /i exch def
    bold italic FontSelect shade setgray
    i j str strlen LabelString
end } def

/HexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimX { /i exch def
	i 0          Chars i 1 sub get 1 LabelString
	i DimY 1 add Chars i 1 sub get 1 LabelString
    } for
    1 1 DimY { /j exch def
	0 j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
	DimX 1 add j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HavannahBoardCoordinates { 3 dict begin
    false true FontSelect CoordinatesShade setgray
    /Base DimX 1 add 2 idiv  def
    1 1 Base { /i exch def
	i 0 HavannahPosn Chars  i 1 sub get 1 LabelString
	0 i HavannahPosn Digits i 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
    1 1 Base 1 sub { /i exch def
	i Base add i HavannahPosn Chars  i Base add 1 sub get 1 LabelString
	i i Base add HavannahPosn Digits i Base add 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/AltHexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimY { /j exch def
	0 j Chars j 1 sub get 1 LabelString
        %DimX 1 add j Chars j 1 sub get 1 LabelString
    } for
    1 1 DimX { /i exch def
	i 0 Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
	%i DimY 1 add Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HexDot { 3 dict begin /size exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint size 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexWhiteMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexWhitePiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexBlackMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexBlackPiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    1 setgray 0 setlinewidth fill
end } def

/HexDoubleMarker { 6 dict begin
    /shaderight exch def /shadeleft exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    gsave
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    shadeleft setgray 0 setlinewidth fill
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    shaderight setgray 0 setlinewidth fill
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    grestore
end } def

/HexBlackWhiteMarker { 0.0 1.0 HexDoubleMarker } def

/HexWhiteBlackMarker { 1.0 0.0 HexDoubleMarker } def
        
/HexMarker { 2 dict begin /j exch def /i exch def
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setlinewidth fill
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke  
end } def

/HexBlackMarker { 2 dict begin /j exch def /i exch def
    0 setgray
    i j HexMarker
end } def

/HexWhiteMarker { 2 dict begin /j exch def /i exch def
    1 setgray
    i j HexMarker
end } def
    
/HexPiece { 3 dict begin /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/MagicStone { 4 dict begin 
    /size exch def /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 1.3 mul size mul 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/HexWhitePiece { 1.0 HexPiece } def

/HexBlackPiece { 0.0 HexPiece } def

/HexWhiteLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def
    i j HexWhitePiece
    i j str strlen 0.0 true true LabelStringVerb
end } def

/HexBlackLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def 
    i j HexBlackPiece
    i j str strlen 1.0 true true LabelStringVerb
end } def

/AbsCoordX { 1 dict begin /x exch def
    OriginX x Scale mul add
end } def

/AbsCoordY { 1 dict begin /y exch def
    OriginY y Scale mul add
end } def

/DrawBox { /maxy exch def /maxx exch def /miny exch def /minx exch def
    newpath
    minx miny moveto
    maxx minx sub 0 rlineto
    0 maxy miny sub rlineto
    minx maxx sub 0 rlineto
    0 miny maxy sub rlineto
    HexLineWidth setlinewidth
    0 setgray
    stroke
} def

/HexVertex { 2 dict begin /j exch def /i exch def
    i j GraphVertexSize HexDot
end } def

/HexLine { 4 dict begin /j2 exch def /i2 exch def /j1 exch def /i1 exch def
    GraphLineWidth setlinewidth
    0 setgray
    newpath
    i1 j1 HexCenterPoint moveto
    i2 j2 HexCenterPoint lineto
    stroke
end } def

%%---------------- Program -------------------


FlatTopBoard
DrawHexBoard
1 HexBoardBorders


%------------ Trailer --------------

showpage

%%EndDocument
 @endspecial 563 5390 a @beginspecial 0 @llx 0 @lly 51
@urx 38 @ury 1133 @rwi @setspecial
%%BeginDocument: fz/pix/3x3.eps
%!PS-Adobe-3.0
%%Creator: Jack van Rijswijck, thanks to Cameron Browne
%%BoundingBox: 0 0 51 38
%%Pages: 0
%%EndComments

/OriginX -6 def
/OriginY 27 def
%---------------- Variables -------------------

/DimX 3 def
/DimY 3 def
/Scale 1.2 def


% draw  Hex boards, any size ... but labels only up to 26x26
% based on code by Cameron Browne, revised by Jack vR, revised by RBH
%-------------- state initializations -------------------------
1 setlinejoin   % lines meet at a point  ==>    use round join
%---------------- constants -------------------
/Root3Div2  0.86602540378444 def
/Chars   {[(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)
           (n)(o)(p)(q)(r)(s)(t)(u)(v)(w)(x)(y)(z)]} def
/CharsUC {[(A)(B)(C)(D)(E)(F)(G)(H)(I)(J)(K)(L)(M)
           (N)(O)(P)(Q)(R)(S)(T)(U)(V)(W)(X)(Y)(Z)]} def
/Digits  {[(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)(12)(13)
           (14)(15)(16)(17)(18)(19)(20)(21)(22)(23)(24)(25)(26)]} def
/HexRadius      5 Scale mul def % hexagon center-to-corner distance 
/HexLineWidth 0.1 Scale mul def 
/GraphVertexSize 1.0 Scale mul def
/GraphLineWidth 0.5 Scale mul def
/CircleRadius 3.0 Scale mul def 
/CircleLineWidth 0.346 Scale mul def 
/PerimeterWidth 0.5 Scale mul def 
/TextHeight 4.5 def
/TextWidth TextHeight 0.45 mul def 
/BoardShade 0.8 def
/CoordinatesShade 0.5 def
/MarkerSize 1.2 def
/CellOrientation 1 def   % 1: flat bottom  0: pointed bottom
/CellCorner [ % 6 cell corners, wrt center 0 0, plus "up" and "down"
   [ HexRadius  neg       0                           ] 
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul neg ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul neg ]
   [ HexRadius            0                           ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul     ]
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul neg ]
] def
%----- name cell corner indices ... see below
/Left  0 def /DownLeft 1 def /DownRight 2 def 
/Right 3 def /UpRight  4 def /UpLeft    5 def 
/Up    6 def /Down     7 def
%-----------------------------------------------------
% cell orientations:  flat bottom    flat side
%-----------------------------------------------------
% flat bottom 
% board cell indices            cell corner/top/bottom indices
%             --
%           /    \
%        --   1,3  --                  5 -6- 4
%      /    \    /    \               /       \
%   --   1,2  --   2,3  --           0         3
% /    \    /    \    /    \          \       /
%   1,1  --   2,2  --   3,3            1 -7- 2
% \    /    \    /    \    /
%   --   2,1  --   3,2  --
%      \    /    \    /   
%        --   3,1  --     
%----------------------------------------------------
% flat side 
%    /  \  /  \  /  \                       5
%   | 11 || 12 || 13 ||                   /   6
%    \  /  \  /  \  /  \                 0     4
%     || 21 || 22 || 23 |                |     |
%       \  /  \  /  \  /  \              1     3
%        || 31 || 32 || 33 |              7   /
%-------------------------------------------2--------
%----------- procedures -------------
/ScalePoint { % stack: ... x y size ==> ...  x*size y*size
   3 dict begin /size exch def /y exch def /x exch def
   x size mul           y size mul
end } def

/FlatTopBoard { FlatSideCells } def

/FlatSideCells {  % redefine cell orientation for flat side
  /CellOrientation 0 def   
  /CellCorner [ % 6 cell corners, wrt center 0 0  %xcoord ycoord
    [HexRadius Root3Div2 mul neg  HexRadius 2 div     ]
    [HexRadius Root3Div2 mul neg  HexRadius 2 div neg ]
    [0                            HexRadius neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div ]
    [0                            HexRadius ]
    [HexRadius Root3Div2 2 div mul HexRadius 0.75 mul ]
    [HexRadius Root3Div2 2 div mul neg HexRadius 0.75 mul neg ]
  ] def
} def

/HexCenterPoint { % center of cell (i,j)
    2 dict begin /j exch def /i exch def
    CellOrientation 1 eq {
    OriginX i j add HexRadius mul 1.5 mul add %Ox + (i+j)*HR*1.5
    OriginY i j sub HexRadius mul Root3Div2 mul sub %Oy - (i-j)*HR*R3/2
    }{
    OriginX i 2 j mul add HexRadius mul Root3Div2 mul add  %Ox + (2i+j)*HR
    OriginY i 1 sub HexRadius mul 1.5 mul sub %Oy - i*HR*R3/2
    } ifelse
end } def
 
/HexLine { % a b c d
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint lineto
    stroke
} def

/HexCurve { % a b c d e f
    /f exch def
    /e exch def
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint e f HexCenterPoint HexRadius 2 mul arcto
    e f HexCenterPoint lineto
    stroke
} def

/HxgnCorner { 5 dict begin /corn exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    x CellCorner corn get 0 get add
    y CellCorner corn get 1 get add
end } def

/Go { 2 dict begin /corn exch def /mag exch def
   % rlineto in a cell orientation direction
   CellCorner corn get aload pop mag ScalePoint rlineto
end } def

/TurnGo { rotate 1.0 Left Go } def % call: degrees TurnGo
/MagTurnGo { rotate Left Go } def % call: mag degrees TurnGo

/HexagonPath { % call: i j HexagonPath
    newpath 
    UpRight HxgnCorner moveto 
    6 { 1.0 Left Go 60 rotate } repeat 
} def

/FillAndStroke { 2 dict begin /sh exch def /wdth exch def
    gsave sh setgray fill
    grestore 0 setgray wdth setlinewidth stroke
end } def

/ShadedHexagon { 3 dict begin /shade exch def /j exch def /i exch def
    i j HexagonPath
    0 shade FillAndStroke
end } def

/Hexagon { % stack: ... i j
    HexagonPath 
    HexLineWidth BoardShade FillAndStroke
} def

/SemiHexagonPath { % stack: ... top i j
    newpath 
    1 eq { Left HxgnCorner moveto 
        1.0 UpRight Go 1.0 Right Go 1.0 DownRight Go stroke }{
        Right HxgnCorner moveto 
        1.0 DownLeft Go 1.0 Left Go 1.0 UpLeft Go stroke
    } ifelse
} def

/HexBoardPerimeter {
    newpath
    1 DimY UpRight HxgnCorner moveto 1.0 Left Go                      
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 rotate %restore rotation
} def

%----------- Havannah coordinates ----------------------
%                   ..  ..  ..
%                 d1  c2  b3  a4
%                   c1  b2  a3
%                     b1  a2
%                       a1
/HavannahPosn { % convert to usual coordinate, so ... x y  =>  ... 1+DimX-x  y
    exch DimX 1 add exch sub exch 
} def

/HavannahBoardPerimeter {
    newpath
    1 DimX UpRight HxgnCorner moveto 1.0 Left Go                      
    6 {Base 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo } repeat
} def

/DrawHexBoard { 2 dict begin
    gsave
    HexBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexPLBoard { 6 dict begin %point-line board
    gsave
    BoardShade setgray newpath
    -1 DimY 1 add 0.5 mul HexCenterPoint moveto
    1 DimY HexCenterPoint lineto
    DimX 1 add 0.5 mul DimY 2 add HexCenterPoint lineto
    DimX DimY HexCenterPoint lineto
    DimX 2 add DimY 1 add 0.5 mul HexCenterPoint lineto
    DimX 1 HexCenterPoint lineto
    DimX 1 add 0.5 mul -1 HexCenterPoint lineto
    1 1 HexCenterPoint lineto
    closepath fill 0 setgray
    1 DimY HexCenterPoint moveto
    1 1 DimX { /i exch def 
        i 1 i DimY HexLine 
        DimY 1 add 0.5 mul -1 i 1 HexLine
        DimY 1 add 0.5 mul DimY 2 add i DimY HexLine } for
    1 1 DimY { /j exch def 
        1 j DimX j HexLine 
        -1 DimX 1 add 0.5 mul 1 j HexLine
        DimX 2 add DimX 1 add 0.5 mul DimX j HexLine } for
    /topx 1 def /topy 1 def /btmx 1 def /btmy 1 def
    DimX DimY add 3 sub {
      topx DimX lt {/topx 1 topx add def}{/topy 1 topy add def} ifelse 
      btmy DimY lt {/btmy 1 btmy add def}{/btmx 1 btmx add def} ifelse 
      topx topy btmx btmy HexLine
      } repeat
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j HexVertex
	} for } for
    grestore
end } def

/DrawHavannahBoard { 3 dict begin
    /Base DimX 1 add 2 idiv  def
    gsave
    HavannahBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 Base { /j exch def
	Base j 1 sub sub 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    1 1 Base 1 sub { /j exch def
	1 1 DimX j sub { /i exch def
	   i j Base add 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexBorder{ 6 dict begin /start exch def 
    /cells exch def /isBlack exch def /which exch def
    gsave
    which UpLeft eq {1 DimY 1 add start sub Up HxgnCorner moveto /d Left def /r 60 def} if
    which UpRight eq {start DimY Up HxgnCorner moveto /d Right def /r 300 def} if
    which DownLeft eq {DimX 1 add start sub 1 Down HxgnCorner moveto /d Left def /r 300 def} if
    which DownRight eq {DimX start Down HxgnCorner moveto /d Right def /r 60 def} if
    0.5 d Go 
    which UpRight eq which DownRight eq or {180 rotate} if
    r TurnGo 
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.5 360 r sub MagTurnGo 1.5 360 r sub 2 mul MagTurnGo
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.75 360 r sub MagTurnGo
    closepath isBlack 1 eq {gsave fill grestore} if stroke grestore
end } def

/NoDrawHexBoard {  % dummy, used in creating bounding box
} def

/HexBoardBorders { 1 dict begin
    /upperLeftBlack exch def
    PerimeterWidth setlinewidth 0 setgray
    UpLeft    upperLeftBlack       DimY 1 DrawHexBorder
    UpRight   1 upperLeftBlack sub DimX 1 DrawHexBorder
    DownRight upperLeftBlack       DimY 1 DrawHexBorder
    DownLeft  1 upperLeftBlack sub DimX 1 DrawHexBorder
end } def

/YBoardPerimeter {
    newpath 1 1 DownRight HxgnCorner moveto 180 rotate
    3 { DimX 1 sub { 300 TurnGo 60 TurnGo } repeat 
        60 TurnGo 60 TurnGo} 
    repeat % now restore initial rotation state
    180 rotate % closepath
} def

/DrawYBoard { 2 dict begin
    YBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimX {/j exch def
        1 1 DimX 1 add j sub {/i exch def
	    i j 1 SemiHexagonPath stroke
        } for } for
end } def

/FontSelect { % bold italic FontSelect
    2 dict begin /italic exch def /bold exch def
    bold {
	italic 
	{ /Times-BoldItalic findfont TextHeight scalefont setfont } 
	{ /Times-Bold findfont TextHeight scalefont setfont }
	ifelse} 
        {
	italic {/Times-Italic findfont TextHeight scalefont setfont} 
	{ /Times findfont TextHeight scalefont setfont }
	ifelse}
    ifelse
end } def
	    
/LabelString {   % call: i j (str) strlen LabelString
%  to use with board rotation, remove comments
    6 dict begin /strlen exch def /str exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint /y exch def /x exch def
    %BoardRotation rotate
    x y moveto 
    %360 BoardRotation sub rotate
    TextWidth strlen mul 0.5 mul neg TextHeight 0.33 mul neg rmoveto
    str show 
end } def

/AbsLabelString { 4 dict begin
    /strlen exch def /str exch def /y exch def /x exch def
    newpath
    x AbsCoordX TextWidth strlen mul 0.5 mul sub
    y AbsCoordY TextHeight 0.33 mul sub
    moveto
    str
    show
end } def

/LabelStringVerb { % i j (str) strlen shade bold italic LabelStringVerb
    7 dict begin /italic exch def /bold exch def /shade exch def
    /strlen exch def /str exch def /j exch def /i exch def
    bold italic FontSelect shade setgray
    i j str strlen LabelString
end } def

/HexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimX { /i exch def
	i 0          Chars i 1 sub get 1 LabelString
	i DimY 1 add Chars i 1 sub get 1 LabelString
    } for
    1 1 DimY { /j exch def
	0 j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
	DimX 1 add j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HavannahBoardCoordinates { 3 dict begin
    false true FontSelect CoordinatesShade setgray
    /Base DimX 1 add 2 idiv  def
    1 1 Base { /i exch def
	i 0 HavannahPosn Chars  i 1 sub get 1 LabelString
	0 i HavannahPosn Digits i 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
    1 1 Base 1 sub { /i exch def
	i Base add i HavannahPosn Chars  i Base add 1 sub get 1 LabelString
	i i Base add HavannahPosn Digits i Base add 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/AltHexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimY { /j exch def
	0 j Chars j 1 sub get 1 LabelString
        %DimX 1 add j Chars j 1 sub get 1 LabelString
    } for
    1 1 DimX { /i exch def
	i 0 Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
	%i DimY 1 add Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HexDot { 3 dict begin /size exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint size 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexWhiteMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexWhitePiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexBlackMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexBlackPiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    1 setgray 0 setlinewidth fill
end } def

/HexDoubleMarker { 6 dict begin
    /shaderight exch def /shadeleft exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    gsave
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    shadeleft setgray 0 setlinewidth fill
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    shaderight setgray 0 setlinewidth fill
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    grestore
end } def

/HexBlackWhiteMarker { 0.0 1.0 HexDoubleMarker } def

/HexWhiteBlackMarker { 1.0 0.0 HexDoubleMarker } def
        
/HexMarker { 2 dict begin /j exch def /i exch def
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setlinewidth fill
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke  
end } def

/HexBlackMarker { 2 dict begin /j exch def /i exch def
    0 setgray
    i j HexMarker
end } def

/HexWhiteMarker { 2 dict begin /j exch def /i exch def
    1 setgray
    i j HexMarker
end } def
    
/HexPiece { 3 dict begin /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/MagicStone { 4 dict begin 
    /size exch def /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 1.3 mul size mul 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/HexWhitePiece { 1.0 HexPiece } def

/HexBlackPiece { 0.0 HexPiece } def

/HexWhiteLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def
    i j HexWhitePiece
    i j str strlen 0.0 true true LabelStringVerb
end } def

/HexBlackLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def 
    i j HexBlackPiece
    i j str strlen 1.0 true true LabelStringVerb
end } def

/AbsCoordX { 1 dict begin /x exch def
    OriginX x Scale mul add
end } def

/AbsCoordY { 1 dict begin /y exch def
    OriginY y Scale mul add
end } def

/DrawBox { /maxy exch def /maxx exch def /miny exch def /minx exch def
    newpath
    minx miny moveto
    maxx minx sub 0 rlineto
    0 maxy miny sub rlineto
    minx maxx sub 0 rlineto
    0 miny maxy sub rlineto
    HexLineWidth setlinewidth
    0 setgray
    stroke
} def

/HexVertex { 2 dict begin /j exch def /i exch def
    i j GraphVertexSize HexDot
end } def

/HexLine { 4 dict begin /j2 exch def /i2 exch def /j1 exch def /i1 exch def
    GraphLineWidth setlinewidth
    0 setgray
    newpath
    i1 j1 HexCenterPoint moveto
    i2 j2 HexCenterPoint lineto
    stroke
end } def

%%---------------- Program -------------------


FlatTopBoard
DrawHexBoard
1 HexBoardBorders


%------------ Trailer --------------

showpage

%%EndDocument
 @endspecial 1900 w @beginspecial 0 @llx 0 @lly 51 @urx
38 @ury 1133 @rwi @setspecial
%%BeginDocument: fz/pix/3x3.eps
%!PS-Adobe-3.0
%%Creator: Jack van Rijswijck, thanks to Cameron Browne
%%BoundingBox: 0 0 51 38
%%Pages: 0
%%EndComments

/OriginX -6 def
/OriginY 27 def
%---------------- Variables -------------------

/DimX 3 def
/DimY 3 def
/Scale 1.2 def


% draw  Hex boards, any size ... but labels only up to 26x26
% based on code by Cameron Browne, revised by Jack vR, revised by RBH
%-------------- state initializations -------------------------
1 setlinejoin   % lines meet at a point  ==>    use round join
%---------------- constants -------------------
/Root3Div2  0.86602540378444 def
/Chars   {[(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)
           (n)(o)(p)(q)(r)(s)(t)(u)(v)(w)(x)(y)(z)]} def
/CharsUC {[(A)(B)(C)(D)(E)(F)(G)(H)(I)(J)(K)(L)(M)
           (N)(O)(P)(Q)(R)(S)(T)(U)(V)(W)(X)(Y)(Z)]} def
/Digits  {[(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)(12)(13)
           (14)(15)(16)(17)(18)(19)(20)(21)(22)(23)(24)(25)(26)]} def
/HexRadius      5 Scale mul def % hexagon center-to-corner distance 
/HexLineWidth 0.1 Scale mul def 
/GraphVertexSize 1.0 Scale mul def
/GraphLineWidth 0.5 Scale mul def
/CircleRadius 3.0 Scale mul def 
/CircleLineWidth 0.346 Scale mul def 
/PerimeterWidth 0.5 Scale mul def 
/TextHeight 4.5 def
/TextWidth TextHeight 0.45 mul def 
/BoardShade 0.8 def
/CoordinatesShade 0.5 def
/MarkerSize 1.2 def
/CellOrientation 1 def   % 1: flat bottom  0: pointed bottom
/CellCorner [ % 6 cell corners, wrt center 0 0, plus "up" and "down"
   [ HexRadius  neg       0                           ] 
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul neg ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul neg ]
   [ HexRadius            0                           ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul     ]
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul neg ]
] def
%----- name cell corner indices ... see below
/Left  0 def /DownLeft 1 def /DownRight 2 def 
/Right 3 def /UpRight  4 def /UpLeft    5 def 
/Up    6 def /Down     7 def
%-----------------------------------------------------
% cell orientations:  flat bottom    flat side
%-----------------------------------------------------
% flat bottom 
% board cell indices            cell corner/top/bottom indices
%             --
%           /    \
%        --   1,3  --                  5 -6- 4
%      /    \    /    \               /       \
%   --   1,2  --   2,3  --           0         3
% /    \    /    \    /    \          \       /
%   1,1  --   2,2  --   3,3            1 -7- 2
% \    /    \    /    \    /
%   --   2,1  --   3,2  --
%      \    /    \    /   
%        --   3,1  --     
%----------------------------------------------------
% flat side 
%    /  \  /  \  /  \                       5
%   | 11 || 12 || 13 ||                   /   6
%    \  /  \  /  \  /  \                 0     4
%     || 21 || 22 || 23 |                |     |
%       \  /  \  /  \  /  \              1     3
%        || 31 || 32 || 33 |              7   /
%-------------------------------------------2--------
%----------- procedures -------------
/ScalePoint { % stack: ... x y size ==> ...  x*size y*size
   3 dict begin /size exch def /y exch def /x exch def
   x size mul           y size mul
end } def

/FlatTopBoard { FlatSideCells } def

/FlatSideCells {  % redefine cell orientation for flat side
  /CellOrientation 0 def   
  /CellCorner [ % 6 cell corners, wrt center 0 0  %xcoord ycoord
    [HexRadius Root3Div2 mul neg  HexRadius 2 div     ]
    [HexRadius Root3Div2 mul neg  HexRadius 2 div neg ]
    [0                            HexRadius neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div ]
    [0                            HexRadius ]
    [HexRadius Root3Div2 2 div mul HexRadius 0.75 mul ]
    [HexRadius Root3Div2 2 div mul neg HexRadius 0.75 mul neg ]
  ] def
} def

/HexCenterPoint { % center of cell (i,j)
    2 dict begin /j exch def /i exch def
    CellOrientation 1 eq {
    OriginX i j add HexRadius mul 1.5 mul add %Ox + (i+j)*HR*1.5
    OriginY i j sub HexRadius mul Root3Div2 mul sub %Oy - (i-j)*HR*R3/2
    }{
    OriginX i 2 j mul add HexRadius mul Root3Div2 mul add  %Ox + (2i+j)*HR
    OriginY i 1 sub HexRadius mul 1.5 mul sub %Oy - i*HR*R3/2
    } ifelse
end } def
 
/HexLine { % a b c d
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint lineto
    stroke
} def

/HexCurve { % a b c d e f
    /f exch def
    /e exch def
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint e f HexCenterPoint HexRadius 2 mul arcto
    e f HexCenterPoint lineto
    stroke
} def

/HxgnCorner { 5 dict begin /corn exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    x CellCorner corn get 0 get add
    y CellCorner corn get 1 get add
end } def

/Go { 2 dict begin /corn exch def /mag exch def
   % rlineto in a cell orientation direction
   CellCorner corn get aload pop mag ScalePoint rlineto
end } def

/TurnGo { rotate 1.0 Left Go } def % call: degrees TurnGo
/MagTurnGo { rotate Left Go } def % call: mag degrees TurnGo

/HexagonPath { % call: i j HexagonPath
    newpath 
    UpRight HxgnCorner moveto 
    6 { 1.0 Left Go 60 rotate } repeat 
} def

/FillAndStroke { 2 dict begin /sh exch def /wdth exch def
    gsave sh setgray fill
    grestore 0 setgray wdth setlinewidth stroke
end } def

/ShadedHexagon { 3 dict begin /shade exch def /j exch def /i exch def
    i j HexagonPath
    0 shade FillAndStroke
end } def

/Hexagon { % stack: ... i j
    HexagonPath 
    HexLineWidth BoardShade FillAndStroke
} def

/SemiHexagonPath { % stack: ... top i j
    newpath 
    1 eq { Left HxgnCorner moveto 
        1.0 UpRight Go 1.0 Right Go 1.0 DownRight Go stroke }{
        Right HxgnCorner moveto 
        1.0 DownLeft Go 1.0 Left Go 1.0 UpLeft Go stroke
    } ifelse
} def

/HexBoardPerimeter {
    newpath
    1 DimY UpRight HxgnCorner moveto 1.0 Left Go                      
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 rotate %restore rotation
} def

%----------- Havannah coordinates ----------------------
%                   ..  ..  ..
%                 d1  c2  b3  a4
%                   c1  b2  a3
%                     b1  a2
%                       a1
/HavannahPosn { % convert to usual coordinate, so ... x y  =>  ... 1+DimX-x  y
    exch DimX 1 add exch sub exch 
} def

/HavannahBoardPerimeter {
    newpath
    1 DimX UpRight HxgnCorner moveto 1.0 Left Go                      
    6 {Base 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo } repeat
} def

/DrawHexBoard { 2 dict begin
    gsave
    HexBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexPLBoard { 6 dict begin %point-line board
    gsave
    BoardShade setgray newpath
    -1 DimY 1 add 0.5 mul HexCenterPoint moveto
    1 DimY HexCenterPoint lineto
    DimX 1 add 0.5 mul DimY 2 add HexCenterPoint lineto
    DimX DimY HexCenterPoint lineto
    DimX 2 add DimY 1 add 0.5 mul HexCenterPoint lineto
    DimX 1 HexCenterPoint lineto
    DimX 1 add 0.5 mul -1 HexCenterPoint lineto
    1 1 HexCenterPoint lineto
    closepath fill 0 setgray
    1 DimY HexCenterPoint moveto
    1 1 DimX { /i exch def 
        i 1 i DimY HexLine 
        DimY 1 add 0.5 mul -1 i 1 HexLine
        DimY 1 add 0.5 mul DimY 2 add i DimY HexLine } for
    1 1 DimY { /j exch def 
        1 j DimX j HexLine 
        -1 DimX 1 add 0.5 mul 1 j HexLine
        DimX 2 add DimX 1 add 0.5 mul DimX j HexLine } for
    /topx 1 def /topy 1 def /btmx 1 def /btmy 1 def
    DimX DimY add 3 sub {
      topx DimX lt {/topx 1 topx add def}{/topy 1 topy add def} ifelse 
      btmy DimY lt {/btmy 1 btmy add def}{/btmx 1 btmx add def} ifelse 
      topx topy btmx btmy HexLine
      } repeat
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j HexVertex
	} for } for
    grestore
end } def

/DrawHavannahBoard { 3 dict begin
    /Base DimX 1 add 2 idiv  def
    gsave
    HavannahBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 Base { /j exch def
	Base j 1 sub sub 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    1 1 Base 1 sub { /j exch def
	1 1 DimX j sub { /i exch def
	   i j Base add 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexBorder{ 6 dict begin /start exch def 
    /cells exch def /isBlack exch def /which exch def
    gsave
    which UpLeft eq {1 DimY 1 add start sub Up HxgnCorner moveto /d Left def /r 60 def} if
    which UpRight eq {start DimY Up HxgnCorner moveto /d Right def /r 300 def} if
    which DownLeft eq {DimX 1 add start sub 1 Down HxgnCorner moveto /d Left def /r 300 def} if
    which DownRight eq {DimX start Down HxgnCorner moveto /d Right def /r 60 def} if
    0.5 d Go 
    which UpRight eq which DownRight eq or {180 rotate} if
    r TurnGo 
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.5 360 r sub MagTurnGo 1.5 360 r sub 2 mul MagTurnGo
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.75 360 r sub MagTurnGo
    closepath isBlack 1 eq {gsave fill grestore} if stroke grestore
end } def

/NoDrawHexBoard {  % dummy, used in creating bounding box
} def

/HexBoardBorders { 1 dict begin
    /upperLeftBlack exch def
    PerimeterWidth setlinewidth 0 setgray
    UpLeft    upperLeftBlack       DimY 1 DrawHexBorder
    UpRight   1 upperLeftBlack sub DimX 1 DrawHexBorder
    DownRight upperLeftBlack       DimY 1 DrawHexBorder
    DownLeft  1 upperLeftBlack sub DimX 1 DrawHexBorder
end } def

/YBoardPerimeter {
    newpath 1 1 DownRight HxgnCorner moveto 180 rotate
    3 { DimX 1 sub { 300 TurnGo 60 TurnGo } repeat 
        60 TurnGo 60 TurnGo} 
    repeat % now restore initial rotation state
    180 rotate % closepath
} def

/DrawYBoard { 2 dict begin
    YBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimX {/j exch def
        1 1 DimX 1 add j sub {/i exch def
	    i j 1 SemiHexagonPath stroke
        } for } for
end } def

/FontSelect { % bold italic FontSelect
    2 dict begin /italic exch def /bold exch def
    bold {
	italic 
	{ /Times-BoldItalic findfont TextHeight scalefont setfont } 
	{ /Times-Bold findfont TextHeight scalefont setfont }
	ifelse} 
        {
	italic {/Times-Italic findfont TextHeight scalefont setfont} 
	{ /Times findfont TextHeight scalefont setfont }
	ifelse}
    ifelse
end } def
	    
/LabelString {   % call: i j (str) strlen LabelString
%  to use with board rotation, remove comments
    6 dict begin /strlen exch def /str exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint /y exch def /x exch def
    %BoardRotation rotate
    x y moveto 
    %360 BoardRotation sub rotate
    TextWidth strlen mul 0.5 mul neg TextHeight 0.33 mul neg rmoveto
    str show 
end } def

/AbsLabelString { 4 dict begin
    /strlen exch def /str exch def /y exch def /x exch def
    newpath
    x AbsCoordX TextWidth strlen mul 0.5 mul sub
    y AbsCoordY TextHeight 0.33 mul sub
    moveto
    str
    show
end } def

/LabelStringVerb { % i j (str) strlen shade bold italic LabelStringVerb
    7 dict begin /italic exch def /bold exch def /shade exch def
    /strlen exch def /str exch def /j exch def /i exch def
    bold italic FontSelect shade setgray
    i j str strlen LabelString
end } def

/HexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimX { /i exch def
	i 0          Chars i 1 sub get 1 LabelString
	i DimY 1 add Chars i 1 sub get 1 LabelString
    } for
    1 1 DimY { /j exch def
	0 j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
	DimX 1 add j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HavannahBoardCoordinates { 3 dict begin
    false true FontSelect CoordinatesShade setgray
    /Base DimX 1 add 2 idiv  def
    1 1 Base { /i exch def
	i 0 HavannahPosn Chars  i 1 sub get 1 LabelString
	0 i HavannahPosn Digits i 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
    1 1 Base 1 sub { /i exch def
	i Base add i HavannahPosn Chars  i Base add 1 sub get 1 LabelString
	i i Base add HavannahPosn Digits i Base add 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/AltHexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimY { /j exch def
	0 j Chars j 1 sub get 1 LabelString
        %DimX 1 add j Chars j 1 sub get 1 LabelString
    } for
    1 1 DimX { /i exch def
	i 0 Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
	%i DimY 1 add Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HexDot { 3 dict begin /size exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint size 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexWhiteMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexWhitePiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexBlackMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexBlackPiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    1 setgray 0 setlinewidth fill
end } def

/HexDoubleMarker { 6 dict begin
    /shaderight exch def /shadeleft exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    gsave
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    shadeleft setgray 0 setlinewidth fill
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    shaderight setgray 0 setlinewidth fill
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    grestore
end } def

/HexBlackWhiteMarker { 0.0 1.0 HexDoubleMarker } def

/HexWhiteBlackMarker { 1.0 0.0 HexDoubleMarker } def
        
/HexMarker { 2 dict begin /j exch def /i exch def
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setlinewidth fill
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke  
end } def

/HexBlackMarker { 2 dict begin /j exch def /i exch def
    0 setgray
    i j HexMarker
end } def

/HexWhiteMarker { 2 dict begin /j exch def /i exch def
    1 setgray
    i j HexMarker
end } def
    
/HexPiece { 3 dict begin /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/MagicStone { 4 dict begin 
    /size exch def /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 1.3 mul size mul 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/HexWhitePiece { 1.0 HexPiece } def

/HexBlackPiece { 0.0 HexPiece } def

/HexWhiteLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def
    i j HexWhitePiece
    i j str strlen 0.0 true true LabelStringVerb
end } def

/HexBlackLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def 
    i j HexBlackPiece
    i j str strlen 1.0 true true LabelStringVerb
end } def

/AbsCoordX { 1 dict begin /x exch def
    OriginX x Scale mul add
end } def

/AbsCoordY { 1 dict begin /y exch def
    OriginY y Scale mul add
end } def

/DrawBox { /maxy exch def /maxx exch def /miny exch def /minx exch def
    newpath
    minx miny moveto
    maxx minx sub 0 rlineto
    0 maxy miny sub rlineto
    minx maxx sub 0 rlineto
    0 miny maxy sub rlineto
    HexLineWidth setlinewidth
    0 setgray
    stroke
} def

/HexVertex { 2 dict begin /j exch def /i exch def
    i j GraphVertexSize HexDot
end } def

/HexLine { 4 dict begin /j2 exch def /i2 exch def /j1 exch def /i1 exch def
    GraphLineWidth setlinewidth
    0 setgray
    newpath
    i1 j1 HexCenterPoint moveto
    i2 j2 HexCenterPoint lineto
    stroke
end } def

%%---------------- Program -------------------


FlatTopBoard
DrawHexBoard
1 HexBoardBorders


%------------ Trailer --------------

showpage

%%EndDocument
 @endspecial 1900 w @beginspecial 0 @llx 0 @lly 51 @urx
38 @ury 1133 @rwi @setspecial
%%BeginDocument: fz/pix/3x3.eps
%!PS-Adobe-3.0
%%Creator: Jack van Rijswijck, thanks to Cameron Browne
%%BoundingBox: 0 0 51 38
%%Pages: 0
%%EndComments

/OriginX -6 def
/OriginY 27 def
%---------------- Variables -------------------

/DimX 3 def
/DimY 3 def
/Scale 1.2 def


% draw  Hex boards, any size ... but labels only up to 26x26
% based on code by Cameron Browne, revised by Jack vR, revised by RBH
%-------------- state initializations -------------------------
1 setlinejoin   % lines meet at a point  ==>    use round join
%---------------- constants -------------------
/Root3Div2  0.86602540378444 def
/Chars   {[(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)
           (n)(o)(p)(q)(r)(s)(t)(u)(v)(w)(x)(y)(z)]} def
/CharsUC {[(A)(B)(C)(D)(E)(F)(G)(H)(I)(J)(K)(L)(M)
           (N)(O)(P)(Q)(R)(S)(T)(U)(V)(W)(X)(Y)(Z)]} def
/Digits  {[(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)(12)(13)
           (14)(15)(16)(17)(18)(19)(20)(21)(22)(23)(24)(25)(26)]} def
/HexRadius      5 Scale mul def % hexagon center-to-corner distance 
/HexLineWidth 0.1 Scale mul def 
/GraphVertexSize 1.0 Scale mul def
/GraphLineWidth 0.5 Scale mul def
/CircleRadius 3.0 Scale mul def 
/CircleLineWidth 0.346 Scale mul def 
/PerimeterWidth 0.5 Scale mul def 
/TextHeight 4.5 def
/TextWidth TextHeight 0.45 mul def 
/BoardShade 0.8 def
/CoordinatesShade 0.5 def
/MarkerSize 1.2 def
/CellOrientation 1 def   % 1: flat bottom  0: pointed bottom
/CellCorner [ % 6 cell corners, wrt center 0 0, plus "up" and "down"
   [ HexRadius  neg       0                           ] 
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul neg ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul neg ]
   [ HexRadius            0                           ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul     ]
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul neg ]
] def
%----- name cell corner indices ... see below
/Left  0 def /DownLeft 1 def /DownRight 2 def 
/Right 3 def /UpRight  4 def /UpLeft    5 def 
/Up    6 def /Down     7 def
%-----------------------------------------------------
% cell orientations:  flat bottom    flat side
%-----------------------------------------------------
% flat bottom 
% board cell indices            cell corner/top/bottom indices
%             --
%           /    \
%        --   1,3  --                  5 -6- 4
%      /    \    /    \               /       \
%   --   1,2  --   2,3  --           0         3
% /    \    /    \    /    \          \       /
%   1,1  --   2,2  --   3,3            1 -7- 2
% \    /    \    /    \    /
%   --   2,1  --   3,2  --
%      \    /    \    /   
%        --   3,1  --     
%----------------------------------------------------
% flat side 
%    /  \  /  \  /  \                       5
%   | 11 || 12 || 13 ||                   /   6
%    \  /  \  /  \  /  \                 0     4
%     || 21 || 22 || 23 |                |     |
%       \  /  \  /  \  /  \              1     3
%        || 31 || 32 || 33 |              7   /
%-------------------------------------------2--------
%----------- procedures -------------
/ScalePoint { % stack: ... x y size ==> ...  x*size y*size
   3 dict begin /size exch def /y exch def /x exch def
   x size mul           y size mul
end } def

/FlatTopBoard { FlatSideCells } def

/FlatSideCells {  % redefine cell orientation for flat side
  /CellOrientation 0 def   
  /CellCorner [ % 6 cell corners, wrt center 0 0  %xcoord ycoord
    [HexRadius Root3Div2 mul neg  HexRadius 2 div     ]
    [HexRadius Root3Div2 mul neg  HexRadius 2 div neg ]
    [0                            HexRadius neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div ]
    [0                            HexRadius ]
    [HexRadius Root3Div2 2 div mul HexRadius 0.75 mul ]
    [HexRadius Root3Div2 2 div mul neg HexRadius 0.75 mul neg ]
  ] def
} def

/HexCenterPoint { % center of cell (i,j)
    2 dict begin /j exch def /i exch def
    CellOrientation 1 eq {
    OriginX i j add HexRadius mul 1.5 mul add %Ox + (i+j)*HR*1.5
    OriginY i j sub HexRadius mul Root3Div2 mul sub %Oy - (i-j)*HR*R3/2
    }{
    OriginX i 2 j mul add HexRadius mul Root3Div2 mul add  %Ox + (2i+j)*HR
    OriginY i 1 sub HexRadius mul 1.5 mul sub %Oy - i*HR*R3/2
    } ifelse
end } def
 
/HexLine { % a b c d
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint lineto
    stroke
} def

/HexCurve { % a b c d e f
    /f exch def
    /e exch def
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint e f HexCenterPoint HexRadius 2 mul arcto
    e f HexCenterPoint lineto
    stroke
} def

/HxgnCorner { 5 dict begin /corn exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    x CellCorner corn get 0 get add
    y CellCorner corn get 1 get add
end } def

/Go { 2 dict begin /corn exch def /mag exch def
   % rlineto in a cell orientation direction
   CellCorner corn get aload pop mag ScalePoint rlineto
end } def

/TurnGo { rotate 1.0 Left Go } def % call: degrees TurnGo
/MagTurnGo { rotate Left Go } def % call: mag degrees TurnGo

/HexagonPath { % call: i j HexagonPath
    newpath 
    UpRight HxgnCorner moveto 
    6 { 1.0 Left Go 60 rotate } repeat 
} def

/FillAndStroke { 2 dict begin /sh exch def /wdth exch def
    gsave sh setgray fill
    grestore 0 setgray wdth setlinewidth stroke
end } def

/ShadedHexagon { 3 dict begin /shade exch def /j exch def /i exch def
    i j HexagonPath
    0 shade FillAndStroke
end } def

/Hexagon { % stack: ... i j
    HexagonPath 
    HexLineWidth BoardShade FillAndStroke
} def

/SemiHexagonPath { % stack: ... top i j
    newpath 
    1 eq { Left HxgnCorner moveto 
        1.0 UpRight Go 1.0 Right Go 1.0 DownRight Go stroke }{
        Right HxgnCorner moveto 
        1.0 DownLeft Go 1.0 Left Go 1.0 UpLeft Go stroke
    } ifelse
} def

/HexBoardPerimeter {
    newpath
    1 DimY UpRight HxgnCorner moveto 1.0 Left Go                      
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 rotate %restore rotation
} def

%----------- Havannah coordinates ----------------------
%                   ..  ..  ..
%                 d1  c2  b3  a4
%                   c1  b2  a3
%                     b1  a2
%                       a1
/HavannahPosn { % convert to usual coordinate, so ... x y  =>  ... 1+DimX-x  y
    exch DimX 1 add exch sub exch 
} def

/HavannahBoardPerimeter {
    newpath
    1 DimX UpRight HxgnCorner moveto 1.0 Left Go                      
    6 {Base 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo } repeat
} def

/DrawHexBoard { 2 dict begin
    gsave
    HexBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexPLBoard { 6 dict begin %point-line board
    gsave
    BoardShade setgray newpath
    -1 DimY 1 add 0.5 mul HexCenterPoint moveto
    1 DimY HexCenterPoint lineto
    DimX 1 add 0.5 mul DimY 2 add HexCenterPoint lineto
    DimX DimY HexCenterPoint lineto
    DimX 2 add DimY 1 add 0.5 mul HexCenterPoint lineto
    DimX 1 HexCenterPoint lineto
    DimX 1 add 0.5 mul -1 HexCenterPoint lineto
    1 1 HexCenterPoint lineto
    closepath fill 0 setgray
    1 DimY HexCenterPoint moveto
    1 1 DimX { /i exch def 
        i 1 i DimY HexLine 
        DimY 1 add 0.5 mul -1 i 1 HexLine
        DimY 1 add 0.5 mul DimY 2 add i DimY HexLine } for
    1 1 DimY { /j exch def 
        1 j DimX j HexLine 
        -1 DimX 1 add 0.5 mul 1 j HexLine
        DimX 2 add DimX 1 add 0.5 mul DimX j HexLine } for
    /topx 1 def /topy 1 def /btmx 1 def /btmy 1 def
    DimX DimY add 3 sub {
      topx DimX lt {/topx 1 topx add def}{/topy 1 topy add def} ifelse 
      btmy DimY lt {/btmy 1 btmy add def}{/btmx 1 btmx add def} ifelse 
      topx topy btmx btmy HexLine
      } repeat
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j HexVertex
	} for } for
    grestore
end } def

/DrawHavannahBoard { 3 dict begin
    /Base DimX 1 add 2 idiv  def
    gsave
    HavannahBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 Base { /j exch def
	Base j 1 sub sub 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    1 1 Base 1 sub { /j exch def
	1 1 DimX j sub { /i exch def
	   i j Base add 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexBorder{ 6 dict begin /start exch def 
    /cells exch def /isBlack exch def /which exch def
    gsave
    which UpLeft eq {1 DimY 1 add start sub Up HxgnCorner moveto /d Left def /r 60 def} if
    which UpRight eq {start DimY Up HxgnCorner moveto /d Right def /r 300 def} if
    which DownLeft eq {DimX 1 add start sub 1 Down HxgnCorner moveto /d Left def /r 300 def} if
    which DownRight eq {DimX start Down HxgnCorner moveto /d Right def /r 60 def} if
    0.5 d Go 
    which UpRight eq which DownRight eq or {180 rotate} if
    r TurnGo 
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.5 360 r sub MagTurnGo 1.5 360 r sub 2 mul MagTurnGo
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.75 360 r sub MagTurnGo
    closepath isBlack 1 eq {gsave fill grestore} if stroke grestore
end } def

/NoDrawHexBoard {  % dummy, used in creating bounding box
} def

/HexBoardBorders { 1 dict begin
    /upperLeftBlack exch def
    PerimeterWidth setlinewidth 0 setgray
    UpLeft    upperLeftBlack       DimY 1 DrawHexBorder
    UpRight   1 upperLeftBlack sub DimX 1 DrawHexBorder
    DownRight upperLeftBlack       DimY 1 DrawHexBorder
    DownLeft  1 upperLeftBlack sub DimX 1 DrawHexBorder
end } def

/YBoardPerimeter {
    newpath 1 1 DownRight HxgnCorner moveto 180 rotate
    3 { DimX 1 sub { 300 TurnGo 60 TurnGo } repeat 
        60 TurnGo 60 TurnGo} 
    repeat % now restore initial rotation state
    180 rotate % closepath
} def

/DrawYBoard { 2 dict begin
    YBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimX {/j exch def
        1 1 DimX 1 add j sub {/i exch def
	    i j 1 SemiHexagonPath stroke
        } for } for
end } def

/FontSelect { % bold italic FontSelect
    2 dict begin /italic exch def /bold exch def
    bold {
	italic 
	{ /Times-BoldItalic findfont TextHeight scalefont setfont } 
	{ /Times-Bold findfont TextHeight scalefont setfont }
	ifelse} 
        {
	italic {/Times-Italic findfont TextHeight scalefont setfont} 
	{ /Times findfont TextHeight scalefont setfont }
	ifelse}
    ifelse
end } def
	    
/LabelString {   % call: i j (str) strlen LabelString
%  to use with board rotation, remove comments
    6 dict begin /strlen exch def /str exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint /y exch def /x exch def
    %BoardRotation rotate
    x y moveto 
    %360 BoardRotation sub rotate
    TextWidth strlen mul 0.5 mul neg TextHeight 0.33 mul neg rmoveto
    str show 
end } def

/AbsLabelString { 4 dict begin
    /strlen exch def /str exch def /y exch def /x exch def
    newpath
    x AbsCoordX TextWidth strlen mul 0.5 mul sub
    y AbsCoordY TextHeight 0.33 mul sub
    moveto
    str
    show
end } def

/LabelStringVerb { % i j (str) strlen shade bold italic LabelStringVerb
    7 dict begin /italic exch def /bold exch def /shade exch def
    /strlen exch def /str exch def /j exch def /i exch def
    bold italic FontSelect shade setgray
    i j str strlen LabelString
end } def

/HexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimX { /i exch def
	i 0          Chars i 1 sub get 1 LabelString
	i DimY 1 add Chars i 1 sub get 1 LabelString
    } for
    1 1 DimY { /j exch def
	0 j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
	DimX 1 add j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HavannahBoardCoordinates { 3 dict begin
    false true FontSelect CoordinatesShade setgray
    /Base DimX 1 add 2 idiv  def
    1 1 Base { /i exch def
	i 0 HavannahPosn Chars  i 1 sub get 1 LabelString
	0 i HavannahPosn Digits i 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
    1 1 Base 1 sub { /i exch def
	i Base add i HavannahPosn Chars  i Base add 1 sub get 1 LabelString
	i i Base add HavannahPosn Digits i Base add 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/AltHexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimY { /j exch def
	0 j Chars j 1 sub get 1 LabelString
        %DimX 1 add j Chars j 1 sub get 1 LabelString
    } for
    1 1 DimX { /i exch def
	i 0 Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
	%i DimY 1 add Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HexDot { 3 dict begin /size exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint size 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexWhiteMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexWhitePiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexBlackMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexBlackPiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    1 setgray 0 setlinewidth fill
end } def

/HexDoubleMarker { 6 dict begin
    /shaderight exch def /shadeleft exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    gsave
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    shadeleft setgray 0 setlinewidth fill
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    shaderight setgray 0 setlinewidth fill
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    grestore
end } def

/HexBlackWhiteMarker { 0.0 1.0 HexDoubleMarker } def

/HexWhiteBlackMarker { 1.0 0.0 HexDoubleMarker } def
        
/HexMarker { 2 dict begin /j exch def /i exch def
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setlinewidth fill
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke  
end } def

/HexBlackMarker { 2 dict begin /j exch def /i exch def
    0 setgray
    i j HexMarker
end } def

/HexWhiteMarker { 2 dict begin /j exch def /i exch def
    1 setgray
    i j HexMarker
end } def
    
/HexPiece { 3 dict begin /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/MagicStone { 4 dict begin 
    /size exch def /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 1.3 mul size mul 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/HexWhitePiece { 1.0 HexPiece } def

/HexBlackPiece { 0.0 HexPiece } def

/HexWhiteLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def
    i j HexWhitePiece
    i j str strlen 0.0 true true LabelStringVerb
end } def

/HexBlackLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def 
    i j HexBlackPiece
    i j str strlen 1.0 true true LabelStringVerb
end } def

/AbsCoordX { 1 dict begin /x exch def
    OriginX x Scale mul add
end } def

/AbsCoordY { 1 dict begin /y exch def
    OriginY y Scale mul add
end } def

/DrawBox { /maxy exch def /maxx exch def /miny exch def /minx exch def
    newpath
    minx miny moveto
    maxx minx sub 0 rlineto
    0 maxy miny sub rlineto
    minx maxx sub 0 rlineto
    0 miny maxy sub rlineto
    HexLineWidth setlinewidth
    0 setgray
    stroke
} def

/HexVertex { 2 dict begin /j exch def /i exch def
    i j GraphVertexSize HexDot
end } def

/HexLine { 4 dict begin /j2 exch def /i2 exch def /j1 exch def /i1 exch def
    GraphLineWidth setlinewidth
    0 setgray
    newpath
    i1 j1 HexCenterPoint moveto
    i2 j2 HexCenterPoint lineto
    stroke
end } def

%%---------------- Program -------------------


FlatTopBoard
DrawHexBoard
1 HexBoardBorders


%------------ Trailer --------------

showpage

%%EndDocument
 @endspecial 563 7408 a @beginspecial 0 @llx 0 @lly 51
@urx 38 @ury 1133 @rwi @setspecial
%%BeginDocument: fz/pix/3x3.eps
%!PS-Adobe-3.0
%%Creator: Jack van Rijswijck, thanks to Cameron Browne
%%BoundingBox: 0 0 51 38
%%Pages: 0
%%EndComments

/OriginX -6 def
/OriginY 27 def
%---------------- Variables -------------------

/DimX 3 def
/DimY 3 def
/Scale 1.2 def


% draw  Hex boards, any size ... but labels only up to 26x26
% based on code by Cameron Browne, revised by Jack vR, revised by RBH
%-------------- state initializations -------------------------
1 setlinejoin   % lines meet at a point  ==>    use round join
%---------------- constants -------------------
/Root3Div2  0.86602540378444 def
/Chars   {[(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)
           (n)(o)(p)(q)(r)(s)(t)(u)(v)(w)(x)(y)(z)]} def
/CharsUC {[(A)(B)(C)(D)(E)(F)(G)(H)(I)(J)(K)(L)(M)
           (N)(O)(P)(Q)(R)(S)(T)(U)(V)(W)(X)(Y)(Z)]} def
/Digits  {[(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)(12)(13)
           (14)(15)(16)(17)(18)(19)(20)(21)(22)(23)(24)(25)(26)]} def
/HexRadius      5 Scale mul def % hexagon center-to-corner distance 
/HexLineWidth 0.1 Scale mul def 
/GraphVertexSize 1.0 Scale mul def
/GraphLineWidth 0.5 Scale mul def
/CircleRadius 3.0 Scale mul def 
/CircleLineWidth 0.346 Scale mul def 
/PerimeterWidth 0.5 Scale mul def 
/TextHeight 4.5 def
/TextWidth TextHeight 0.45 mul def 
/BoardShade 0.8 def
/CoordinatesShade 0.5 def
/MarkerSize 1.2 def
/CellOrientation 1 def   % 1: flat bottom  0: pointed bottom
/CellCorner [ % 6 cell corners, wrt center 0 0, plus "up" and "down"
   [ HexRadius  neg       0                           ] 
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul neg ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul neg ]
   [ HexRadius            0                           ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul     ]
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul neg ]
] def
%----- name cell corner indices ... see below
/Left  0 def /DownLeft 1 def /DownRight 2 def 
/Right 3 def /UpRight  4 def /UpLeft    5 def 
/Up    6 def /Down     7 def
%-----------------------------------------------------
% cell orientations:  flat bottom    flat side
%-----------------------------------------------------
% flat bottom 
% board cell indices            cell corner/top/bottom indices
%             --
%           /    \
%        --   1,3  --                  5 -6- 4
%      /    \    /    \               /       \
%   --   1,2  --   2,3  --           0         3
% /    \    /    \    /    \          \       /
%   1,1  --   2,2  --   3,3            1 -7- 2
% \    /    \    /    \    /
%   --   2,1  --   3,2  --
%      \    /    \    /   
%        --   3,1  --     
%----------------------------------------------------
% flat side 
%    /  \  /  \  /  \                       5
%   | 11 || 12 || 13 ||                   /   6
%    \  /  \  /  \  /  \                 0     4
%     || 21 || 22 || 23 |                |     |
%       \  /  \  /  \  /  \              1     3
%        || 31 || 32 || 33 |              7   /
%-------------------------------------------2--------
%----------- procedures -------------
/ScalePoint { % stack: ... x y size ==> ...  x*size y*size
   3 dict begin /size exch def /y exch def /x exch def
   x size mul           y size mul
end } def

/FlatTopBoard { FlatSideCells } def

/FlatSideCells {  % redefine cell orientation for flat side
  /CellOrientation 0 def   
  /CellCorner [ % 6 cell corners, wrt center 0 0  %xcoord ycoord
    [HexRadius Root3Div2 mul neg  HexRadius 2 div     ]
    [HexRadius Root3Div2 mul neg  HexRadius 2 div neg ]
    [0                            HexRadius neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div ]
    [0                            HexRadius ]
    [HexRadius Root3Div2 2 div mul HexRadius 0.75 mul ]
    [HexRadius Root3Div2 2 div mul neg HexRadius 0.75 mul neg ]
  ] def
} def

/HexCenterPoint { % center of cell (i,j)
    2 dict begin /j exch def /i exch def
    CellOrientation 1 eq {
    OriginX i j add HexRadius mul 1.5 mul add %Ox + (i+j)*HR*1.5
    OriginY i j sub HexRadius mul Root3Div2 mul sub %Oy - (i-j)*HR*R3/2
    }{
    OriginX i 2 j mul add HexRadius mul Root3Div2 mul add  %Ox + (2i+j)*HR
    OriginY i 1 sub HexRadius mul 1.5 mul sub %Oy - i*HR*R3/2
    } ifelse
end } def
 
/HexLine { % a b c d
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint lineto
    stroke
} def

/HexCurve { % a b c d e f
    /f exch def
    /e exch def
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint e f HexCenterPoint HexRadius 2 mul arcto
    e f HexCenterPoint lineto
    stroke
} def

/HxgnCorner { 5 dict begin /corn exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    x CellCorner corn get 0 get add
    y CellCorner corn get 1 get add
end } def

/Go { 2 dict begin /corn exch def /mag exch def
   % rlineto in a cell orientation direction
   CellCorner corn get aload pop mag ScalePoint rlineto
end } def

/TurnGo { rotate 1.0 Left Go } def % call: degrees TurnGo
/MagTurnGo { rotate Left Go } def % call: mag degrees TurnGo

/HexagonPath { % call: i j HexagonPath
    newpath 
    UpRight HxgnCorner moveto 
    6 { 1.0 Left Go 60 rotate } repeat 
} def

/FillAndStroke { 2 dict begin /sh exch def /wdth exch def
    gsave sh setgray fill
    grestore 0 setgray wdth setlinewidth stroke
end } def

/ShadedHexagon { 3 dict begin /shade exch def /j exch def /i exch def
    i j HexagonPath
    0 shade FillAndStroke
end } def

/Hexagon { % stack: ... i j
    HexagonPath 
    HexLineWidth BoardShade FillAndStroke
} def

/SemiHexagonPath { % stack: ... top i j
    newpath 
    1 eq { Left HxgnCorner moveto 
        1.0 UpRight Go 1.0 Right Go 1.0 DownRight Go stroke }{
        Right HxgnCorner moveto 
        1.0 DownLeft Go 1.0 Left Go 1.0 UpLeft Go stroke
    } ifelse
} def

/HexBoardPerimeter {
    newpath
    1 DimY UpRight HxgnCorner moveto 1.0 Left Go                      
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 rotate %restore rotation
} def

%----------- Havannah coordinates ----------------------
%                   ..  ..  ..
%                 d1  c2  b3  a4
%                   c1  b2  a3
%                     b1  a2
%                       a1
/HavannahPosn { % convert to usual coordinate, so ... x y  =>  ... 1+DimX-x  y
    exch DimX 1 add exch sub exch 
} def

/HavannahBoardPerimeter {
    newpath
    1 DimX UpRight HxgnCorner moveto 1.0 Left Go                      
    6 {Base 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo } repeat
} def

/DrawHexBoard { 2 dict begin
    gsave
    HexBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexPLBoard { 6 dict begin %point-line board
    gsave
    BoardShade setgray newpath
    -1 DimY 1 add 0.5 mul HexCenterPoint moveto
    1 DimY HexCenterPoint lineto
    DimX 1 add 0.5 mul DimY 2 add HexCenterPoint lineto
    DimX DimY HexCenterPoint lineto
    DimX 2 add DimY 1 add 0.5 mul HexCenterPoint lineto
    DimX 1 HexCenterPoint lineto
    DimX 1 add 0.5 mul -1 HexCenterPoint lineto
    1 1 HexCenterPoint lineto
    closepath fill 0 setgray
    1 DimY HexCenterPoint moveto
    1 1 DimX { /i exch def 
        i 1 i DimY HexLine 
        DimY 1 add 0.5 mul -1 i 1 HexLine
        DimY 1 add 0.5 mul DimY 2 add i DimY HexLine } for
    1 1 DimY { /j exch def 
        1 j DimX j HexLine 
        -1 DimX 1 add 0.5 mul 1 j HexLine
        DimX 2 add DimX 1 add 0.5 mul DimX j HexLine } for
    /topx 1 def /topy 1 def /btmx 1 def /btmy 1 def
    DimX DimY add 3 sub {
      topx DimX lt {/topx 1 topx add def}{/topy 1 topy add def} ifelse 
      btmy DimY lt {/btmy 1 btmy add def}{/btmx 1 btmx add def} ifelse 
      topx topy btmx btmy HexLine
      } repeat
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j HexVertex
	} for } for
    grestore
end } def

/DrawHavannahBoard { 3 dict begin
    /Base DimX 1 add 2 idiv  def
    gsave
    HavannahBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 Base { /j exch def
	Base j 1 sub sub 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    1 1 Base 1 sub { /j exch def
	1 1 DimX j sub { /i exch def
	   i j Base add 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexBorder{ 6 dict begin /start exch def 
    /cells exch def /isBlack exch def /which exch def
    gsave
    which UpLeft eq {1 DimY 1 add start sub Up HxgnCorner moveto /d Left def /r 60 def} if
    which UpRight eq {start DimY Up HxgnCorner moveto /d Right def /r 300 def} if
    which DownLeft eq {DimX 1 add start sub 1 Down HxgnCorner moveto /d Left def /r 300 def} if
    which DownRight eq {DimX start Down HxgnCorner moveto /d Right def /r 60 def} if
    0.5 d Go 
    which UpRight eq which DownRight eq or {180 rotate} if
    r TurnGo 
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.5 360 r sub MagTurnGo 1.5 360 r sub 2 mul MagTurnGo
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.75 360 r sub MagTurnGo
    closepath isBlack 1 eq {gsave fill grestore} if stroke grestore
end } def

/NoDrawHexBoard {  % dummy, used in creating bounding box
} def

/HexBoardBorders { 1 dict begin
    /upperLeftBlack exch def
    PerimeterWidth setlinewidth 0 setgray
    UpLeft    upperLeftBlack       DimY 1 DrawHexBorder
    UpRight   1 upperLeftBlack sub DimX 1 DrawHexBorder
    DownRight upperLeftBlack       DimY 1 DrawHexBorder
    DownLeft  1 upperLeftBlack sub DimX 1 DrawHexBorder
end } def

/YBoardPerimeter {
    newpath 1 1 DownRight HxgnCorner moveto 180 rotate
    3 { DimX 1 sub { 300 TurnGo 60 TurnGo } repeat 
        60 TurnGo 60 TurnGo} 
    repeat % now restore initial rotation state
    180 rotate % closepath
} def

/DrawYBoard { 2 dict begin
    YBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimX {/j exch def
        1 1 DimX 1 add j sub {/i exch def
	    i j 1 SemiHexagonPath stroke
        } for } for
end } def

/FontSelect { % bold italic FontSelect
    2 dict begin /italic exch def /bold exch def
    bold {
	italic 
	{ /Times-BoldItalic findfont TextHeight scalefont setfont } 
	{ /Times-Bold findfont TextHeight scalefont setfont }
	ifelse} 
        {
	italic {/Times-Italic findfont TextHeight scalefont setfont} 
	{ /Times findfont TextHeight scalefont setfont }
	ifelse}
    ifelse
end } def
	    
/LabelString {   % call: i j (str) strlen LabelString
%  to use with board rotation, remove comments
    6 dict begin /strlen exch def /str exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint /y exch def /x exch def
    %BoardRotation rotate
    x y moveto 
    %360 BoardRotation sub rotate
    TextWidth strlen mul 0.5 mul neg TextHeight 0.33 mul neg rmoveto
    str show 
end } def

/AbsLabelString { 4 dict begin
    /strlen exch def /str exch def /y exch def /x exch def
    newpath
    x AbsCoordX TextWidth strlen mul 0.5 mul sub
    y AbsCoordY TextHeight 0.33 mul sub
    moveto
    str
    show
end } def

/LabelStringVerb { % i j (str) strlen shade bold italic LabelStringVerb
    7 dict begin /italic exch def /bold exch def /shade exch def
    /strlen exch def /str exch def /j exch def /i exch def
    bold italic FontSelect shade setgray
    i j str strlen LabelString
end } def

/HexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimX { /i exch def
	i 0          Chars i 1 sub get 1 LabelString
	i DimY 1 add Chars i 1 sub get 1 LabelString
    } for
    1 1 DimY { /j exch def
	0 j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
	DimX 1 add j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HavannahBoardCoordinates { 3 dict begin
    false true FontSelect CoordinatesShade setgray
    /Base DimX 1 add 2 idiv  def
    1 1 Base { /i exch def
	i 0 HavannahPosn Chars  i 1 sub get 1 LabelString
	0 i HavannahPosn Digits i 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
    1 1 Base 1 sub { /i exch def
	i Base add i HavannahPosn Chars  i Base add 1 sub get 1 LabelString
	i i Base add HavannahPosn Digits i Base add 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/AltHexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimY { /j exch def
	0 j Chars j 1 sub get 1 LabelString
        %DimX 1 add j Chars j 1 sub get 1 LabelString
    } for
    1 1 DimX { /i exch def
	i 0 Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
	%i DimY 1 add Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HexDot { 3 dict begin /size exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint size 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexWhiteMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexWhitePiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexBlackMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexBlackPiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    1 setgray 0 setlinewidth fill
end } def

/HexDoubleMarker { 6 dict begin
    /shaderight exch def /shadeleft exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    gsave
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    shadeleft setgray 0 setlinewidth fill
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    shaderight setgray 0 setlinewidth fill
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    grestore
end } def

/HexBlackWhiteMarker { 0.0 1.0 HexDoubleMarker } def

/HexWhiteBlackMarker { 1.0 0.0 HexDoubleMarker } def
        
/HexMarker { 2 dict begin /j exch def /i exch def
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setlinewidth fill
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke  
end } def

/HexBlackMarker { 2 dict begin /j exch def /i exch def
    0 setgray
    i j HexMarker
end } def

/HexWhiteMarker { 2 dict begin /j exch def /i exch def
    1 setgray
    i j HexMarker
end } def
    
/HexPiece { 3 dict begin /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/MagicStone { 4 dict begin 
    /size exch def /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 1.3 mul size mul 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/HexWhitePiece { 1.0 HexPiece } def

/HexBlackPiece { 0.0 HexPiece } def

/HexWhiteLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def
    i j HexWhitePiece
    i j str strlen 0.0 true true LabelStringVerb
end } def

/HexBlackLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def 
    i j HexBlackPiece
    i j str strlen 1.0 true true LabelStringVerb
end } def

/AbsCoordX { 1 dict begin /x exch def
    OriginX x Scale mul add
end } def

/AbsCoordY { 1 dict begin /y exch def
    OriginY y Scale mul add
end } def

/DrawBox { /maxy exch def /maxx exch def /miny exch def /minx exch def
    newpath
    minx miny moveto
    maxx minx sub 0 rlineto
    0 maxy miny sub rlineto
    minx maxx sub 0 rlineto
    0 miny maxy sub rlineto
    HexLineWidth setlinewidth
    0 setgray
    stroke
} def

/HexVertex { 2 dict begin /j exch def /i exch def
    i j GraphVertexSize HexDot
end } def

/HexLine { 4 dict begin /j2 exch def /i2 exch def /j1 exch def /i1 exch def
    GraphLineWidth setlinewidth
    0 setgray
    newpath
    i1 j1 HexCenterPoint moveto
    i2 j2 HexCenterPoint lineto
    stroke
end } def

%%---------------- Program -------------------


FlatTopBoard
DrawHexBoard
1 HexBoardBorders


%------------ Trailer --------------

showpage

%%EndDocument
 @endspecial 1900 w @beginspecial 0 @llx 0 @lly 51 @urx
38 @ury 1133 @rwi @setspecial
%%BeginDocument: fz/pix/3x3.eps
%!PS-Adobe-3.0
%%Creator: Jack van Rijswijck, thanks to Cameron Browne
%%BoundingBox: 0 0 51 38
%%Pages: 0
%%EndComments

/OriginX -6 def
/OriginY 27 def
%---------------- Variables -------------------

/DimX 3 def
/DimY 3 def
/Scale 1.2 def


% draw  Hex boards, any size ... but labels only up to 26x26
% based on code by Cameron Browne, revised by Jack vR, revised by RBH
%-------------- state initializations -------------------------
1 setlinejoin   % lines meet at a point  ==>    use round join
%---------------- constants -------------------
/Root3Div2  0.86602540378444 def
/Chars   {[(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)
           (n)(o)(p)(q)(r)(s)(t)(u)(v)(w)(x)(y)(z)]} def
/CharsUC {[(A)(B)(C)(D)(E)(F)(G)(H)(I)(J)(K)(L)(M)
           (N)(O)(P)(Q)(R)(S)(T)(U)(V)(W)(X)(Y)(Z)]} def
/Digits  {[(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)(12)(13)
           (14)(15)(16)(17)(18)(19)(20)(21)(22)(23)(24)(25)(26)]} def
/HexRadius      5 Scale mul def % hexagon center-to-corner distance 
/HexLineWidth 0.1 Scale mul def 
/GraphVertexSize 1.0 Scale mul def
/GraphLineWidth 0.5 Scale mul def
/CircleRadius 3.0 Scale mul def 
/CircleLineWidth 0.346 Scale mul def 
/PerimeterWidth 0.5 Scale mul def 
/TextHeight 4.5 def
/TextWidth TextHeight 0.45 mul def 
/BoardShade 0.8 def
/CoordinatesShade 0.5 def
/MarkerSize 1.2 def
/CellOrientation 1 def   % 1: flat bottom  0: pointed bottom
/CellCorner [ % 6 cell corners, wrt center 0 0, plus "up" and "down"
   [ HexRadius  neg       0                           ] 
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul neg ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul neg ]
   [ HexRadius            0                           ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul     ]
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul neg ]
] def
%----- name cell corner indices ... see below
/Left  0 def /DownLeft 1 def /DownRight 2 def 
/Right 3 def /UpRight  4 def /UpLeft    5 def 
/Up    6 def /Down     7 def
%-----------------------------------------------------
% cell orientations:  flat bottom    flat side
%-----------------------------------------------------
% flat bottom 
% board cell indices            cell corner/top/bottom indices
%             --
%           /    \
%        --   1,3  --                  5 -6- 4
%      /    \    /    \               /       \
%   --   1,2  --   2,3  --           0         3
% /    \    /    \    /    \          \       /
%   1,1  --   2,2  --   3,3            1 -7- 2
% \    /    \    /    \    /
%   --   2,1  --   3,2  --
%      \    /    \    /   
%        --   3,1  --     
%----------------------------------------------------
% flat side 
%    /  \  /  \  /  \                       5
%   | 11 || 12 || 13 ||                   /   6
%    \  /  \  /  \  /  \                 0     4
%     || 21 || 22 || 23 |                |     |
%       \  /  \  /  \  /  \              1     3
%        || 31 || 32 || 33 |              7   /
%-------------------------------------------2--------
%----------- procedures -------------
/ScalePoint { % stack: ... x y size ==> ...  x*size y*size
   3 dict begin /size exch def /y exch def /x exch def
   x size mul           y size mul
end } def

/FlatTopBoard { FlatSideCells } def

/FlatSideCells {  % redefine cell orientation for flat side
  /CellOrientation 0 def   
  /CellCorner [ % 6 cell corners, wrt center 0 0  %xcoord ycoord
    [HexRadius Root3Div2 mul neg  HexRadius 2 div     ]
    [HexRadius Root3Div2 mul neg  HexRadius 2 div neg ]
    [0                            HexRadius neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div ]
    [0                            HexRadius ]
    [HexRadius Root3Div2 2 div mul HexRadius 0.75 mul ]
    [HexRadius Root3Div2 2 div mul neg HexRadius 0.75 mul neg ]
  ] def
} def

/HexCenterPoint { % center of cell (i,j)
    2 dict begin /j exch def /i exch def
    CellOrientation 1 eq {
    OriginX i j add HexRadius mul 1.5 mul add %Ox + (i+j)*HR*1.5
    OriginY i j sub HexRadius mul Root3Div2 mul sub %Oy - (i-j)*HR*R3/2
    }{
    OriginX i 2 j mul add HexRadius mul Root3Div2 mul add  %Ox + (2i+j)*HR
    OriginY i 1 sub HexRadius mul 1.5 mul sub %Oy - i*HR*R3/2
    } ifelse
end } def
 
/HexLine { % a b c d
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint lineto
    stroke
} def

/HexCurve { % a b c d e f
    /f exch def
    /e exch def
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint e f HexCenterPoint HexRadius 2 mul arcto
    e f HexCenterPoint lineto
    stroke
} def

/HxgnCorner { 5 dict begin /corn exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    x CellCorner corn get 0 get add
    y CellCorner corn get 1 get add
end } def

/Go { 2 dict begin /corn exch def /mag exch def
   % rlineto in a cell orientation direction
   CellCorner corn get aload pop mag ScalePoint rlineto
end } def

/TurnGo { rotate 1.0 Left Go } def % call: degrees TurnGo
/MagTurnGo { rotate Left Go } def % call: mag degrees TurnGo

/HexagonPath { % call: i j HexagonPath
    newpath 
    UpRight HxgnCorner moveto 
    6 { 1.0 Left Go 60 rotate } repeat 
} def

/FillAndStroke { 2 dict begin /sh exch def /wdth exch def
    gsave sh setgray fill
    grestore 0 setgray wdth setlinewidth stroke
end } def

/ShadedHexagon { 3 dict begin /shade exch def /j exch def /i exch def
    i j HexagonPath
    0 shade FillAndStroke
end } def

/Hexagon { % stack: ... i j
    HexagonPath 
    HexLineWidth BoardShade FillAndStroke
} def

/SemiHexagonPath { % stack: ... top i j
    newpath 
    1 eq { Left HxgnCorner moveto 
        1.0 UpRight Go 1.0 Right Go 1.0 DownRight Go stroke }{
        Right HxgnCorner moveto 
        1.0 DownLeft Go 1.0 Left Go 1.0 UpLeft Go stroke
    } ifelse
} def

/HexBoardPerimeter {
    newpath
    1 DimY UpRight HxgnCorner moveto 1.0 Left Go                      
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 rotate %restore rotation
} def

%----------- Havannah coordinates ----------------------
%                   ..  ..  ..
%                 d1  c2  b3  a4
%                   c1  b2  a3
%                     b1  a2
%                       a1
/HavannahPosn { % convert to usual coordinate, so ... x y  =>  ... 1+DimX-x  y
    exch DimX 1 add exch sub exch 
} def

/HavannahBoardPerimeter {
    newpath
    1 DimX UpRight HxgnCorner moveto 1.0 Left Go                      
    6 {Base 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo } repeat
} def

/DrawHexBoard { 2 dict begin
    gsave
    HexBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexPLBoard { 6 dict begin %point-line board
    gsave
    BoardShade setgray newpath
    -1 DimY 1 add 0.5 mul HexCenterPoint moveto
    1 DimY HexCenterPoint lineto
    DimX 1 add 0.5 mul DimY 2 add HexCenterPoint lineto
    DimX DimY HexCenterPoint lineto
    DimX 2 add DimY 1 add 0.5 mul HexCenterPoint lineto
    DimX 1 HexCenterPoint lineto
    DimX 1 add 0.5 mul -1 HexCenterPoint lineto
    1 1 HexCenterPoint lineto
    closepath fill 0 setgray
    1 DimY HexCenterPoint moveto
    1 1 DimX { /i exch def 
        i 1 i DimY HexLine 
        DimY 1 add 0.5 mul -1 i 1 HexLine
        DimY 1 add 0.5 mul DimY 2 add i DimY HexLine } for
    1 1 DimY { /j exch def 
        1 j DimX j HexLine 
        -1 DimX 1 add 0.5 mul 1 j HexLine
        DimX 2 add DimX 1 add 0.5 mul DimX j HexLine } for
    /topx 1 def /topy 1 def /btmx 1 def /btmy 1 def
    DimX DimY add 3 sub {
      topx DimX lt {/topx 1 topx add def}{/topy 1 topy add def} ifelse 
      btmy DimY lt {/btmy 1 btmy add def}{/btmx 1 btmx add def} ifelse 
      topx topy btmx btmy HexLine
      } repeat
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j HexVertex
	} for } for
    grestore
end } def

/DrawHavannahBoard { 3 dict begin
    /Base DimX 1 add 2 idiv  def
    gsave
    HavannahBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 Base { /j exch def
	Base j 1 sub sub 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    1 1 Base 1 sub { /j exch def
	1 1 DimX j sub { /i exch def
	   i j Base add 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexBorder{ 6 dict begin /start exch def 
    /cells exch def /isBlack exch def /which exch def
    gsave
    which UpLeft eq {1 DimY 1 add start sub Up HxgnCorner moveto /d Left def /r 60 def} if
    which UpRight eq {start DimY Up HxgnCorner moveto /d Right def /r 300 def} if
    which DownLeft eq {DimX 1 add start sub 1 Down HxgnCorner moveto /d Left def /r 300 def} if
    which DownRight eq {DimX start Down HxgnCorner moveto /d Right def /r 60 def} if
    0.5 d Go 
    which UpRight eq which DownRight eq or {180 rotate} if
    r TurnGo 
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.5 360 r sub MagTurnGo 1.5 360 r sub 2 mul MagTurnGo
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.75 360 r sub MagTurnGo
    closepath isBlack 1 eq {gsave fill grestore} if stroke grestore
end } def

/NoDrawHexBoard {  % dummy, used in creating bounding box
} def

/HexBoardBorders { 1 dict begin
    /upperLeftBlack exch def
    PerimeterWidth setlinewidth 0 setgray
    UpLeft    upperLeftBlack       DimY 1 DrawHexBorder
    UpRight   1 upperLeftBlack sub DimX 1 DrawHexBorder
    DownRight upperLeftBlack       DimY 1 DrawHexBorder
    DownLeft  1 upperLeftBlack sub DimX 1 DrawHexBorder
end } def

/YBoardPerimeter {
    newpath 1 1 DownRight HxgnCorner moveto 180 rotate
    3 { DimX 1 sub { 300 TurnGo 60 TurnGo } repeat 
        60 TurnGo 60 TurnGo} 
    repeat % now restore initial rotation state
    180 rotate % closepath
} def

/DrawYBoard { 2 dict begin
    YBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimX {/j exch def
        1 1 DimX 1 add j sub {/i exch def
	    i j 1 SemiHexagonPath stroke
        } for } for
end } def

/FontSelect { % bold italic FontSelect
    2 dict begin /italic exch def /bold exch def
    bold {
	italic 
	{ /Times-BoldItalic findfont TextHeight scalefont setfont } 
	{ /Times-Bold findfont TextHeight scalefont setfont }
	ifelse} 
        {
	italic {/Times-Italic findfont TextHeight scalefont setfont} 
	{ /Times findfont TextHeight scalefont setfont }
	ifelse}
    ifelse
end } def
	    
/LabelString {   % call: i j (str) strlen LabelString
%  to use with board rotation, remove comments
    6 dict begin /strlen exch def /str exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint /y exch def /x exch def
    %BoardRotation rotate
    x y moveto 
    %360 BoardRotation sub rotate
    TextWidth strlen mul 0.5 mul neg TextHeight 0.33 mul neg rmoveto
    str show 
end } def

/AbsLabelString { 4 dict begin
    /strlen exch def /str exch def /y exch def /x exch def
    newpath
    x AbsCoordX TextWidth strlen mul 0.5 mul sub
    y AbsCoordY TextHeight 0.33 mul sub
    moveto
    str
    show
end } def

/LabelStringVerb { % i j (str) strlen shade bold italic LabelStringVerb
    7 dict begin /italic exch def /bold exch def /shade exch def
    /strlen exch def /str exch def /j exch def /i exch def
    bold italic FontSelect shade setgray
    i j str strlen LabelString
end } def

/HexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimX { /i exch def
	i 0          Chars i 1 sub get 1 LabelString
	i DimY 1 add Chars i 1 sub get 1 LabelString
    } for
    1 1 DimY { /j exch def
	0 j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
	DimX 1 add j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HavannahBoardCoordinates { 3 dict begin
    false true FontSelect CoordinatesShade setgray
    /Base DimX 1 add 2 idiv  def
    1 1 Base { /i exch def
	i 0 HavannahPosn Chars  i 1 sub get 1 LabelString
	0 i HavannahPosn Digits i 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
    1 1 Base 1 sub { /i exch def
	i Base add i HavannahPosn Chars  i Base add 1 sub get 1 LabelString
	i i Base add HavannahPosn Digits i Base add 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/AltHexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimY { /j exch def
	0 j Chars j 1 sub get 1 LabelString
        %DimX 1 add j Chars j 1 sub get 1 LabelString
    } for
    1 1 DimX { /i exch def
	i 0 Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
	%i DimY 1 add Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HexDot { 3 dict begin /size exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint size 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexWhiteMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexWhitePiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexBlackMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexBlackPiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    1 setgray 0 setlinewidth fill
end } def

/HexDoubleMarker { 6 dict begin
    /shaderight exch def /shadeleft exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    gsave
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    shadeleft setgray 0 setlinewidth fill
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    shaderight setgray 0 setlinewidth fill
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    grestore
end } def

/HexBlackWhiteMarker { 0.0 1.0 HexDoubleMarker } def

/HexWhiteBlackMarker { 1.0 0.0 HexDoubleMarker } def
        
/HexMarker { 2 dict begin /j exch def /i exch def
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setlinewidth fill
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke  
end } def

/HexBlackMarker { 2 dict begin /j exch def /i exch def
    0 setgray
    i j HexMarker
end } def

/HexWhiteMarker { 2 dict begin /j exch def /i exch def
    1 setgray
    i j HexMarker
end } def
    
/HexPiece { 3 dict begin /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/MagicStone { 4 dict begin 
    /size exch def /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 1.3 mul size mul 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/HexWhitePiece { 1.0 HexPiece } def

/HexBlackPiece { 0.0 HexPiece } def

/HexWhiteLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def
    i j HexWhitePiece
    i j str strlen 0.0 true true LabelStringVerb
end } def

/HexBlackLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def 
    i j HexBlackPiece
    i j str strlen 1.0 true true LabelStringVerb
end } def

/AbsCoordX { 1 dict begin /x exch def
    OriginX x Scale mul add
end } def

/AbsCoordY { 1 dict begin /y exch def
    OriginY y Scale mul add
end } def

/DrawBox { /maxy exch def /maxx exch def /miny exch def /minx exch def
    newpath
    minx miny moveto
    maxx minx sub 0 rlineto
    0 maxy miny sub rlineto
    minx maxx sub 0 rlineto
    0 miny maxy sub rlineto
    HexLineWidth setlinewidth
    0 setgray
    stroke
} def

/HexVertex { 2 dict begin /j exch def /i exch def
    i j GraphVertexSize HexDot
end } def

/HexLine { 4 dict begin /j2 exch def /i2 exch def /j1 exch def /i1 exch def
    GraphLineWidth setlinewidth
    0 setgray
    newpath
    i1 j1 HexCenterPoint moveto
    i2 j2 HexCenterPoint lineto
    stroke
end } def

%%---------------- Program -------------------


FlatTopBoard
DrawHexBoard
1 HexBoardBorders


%------------ Trailer --------------

showpage

%%EndDocument
 @endspecial 1900 w @beginspecial 0 @llx 0 @lly 51 @urx
38 @ury 1133 @rwi @setspecial
%%BeginDocument: fz/pix/3x3.eps
%!PS-Adobe-3.0
%%Creator: Jack van Rijswijck, thanks to Cameron Browne
%%BoundingBox: 0 0 51 38
%%Pages: 0
%%EndComments

/OriginX -6 def
/OriginY 27 def
%---------------- Variables -------------------

/DimX 3 def
/DimY 3 def
/Scale 1.2 def


% draw  Hex boards, any size ... but labels only up to 26x26
% based on code by Cameron Browne, revised by Jack vR, revised by RBH
%-------------- state initializations -------------------------
1 setlinejoin   % lines meet at a point  ==>    use round join
%---------------- constants -------------------
/Root3Div2  0.86602540378444 def
/Chars   {[(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)
           (n)(o)(p)(q)(r)(s)(t)(u)(v)(w)(x)(y)(z)]} def
/CharsUC {[(A)(B)(C)(D)(E)(F)(G)(H)(I)(J)(K)(L)(M)
           (N)(O)(P)(Q)(R)(S)(T)(U)(V)(W)(X)(Y)(Z)]} def
/Digits  {[(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)(12)(13)
           (14)(15)(16)(17)(18)(19)(20)(21)(22)(23)(24)(25)(26)]} def
/HexRadius      5 Scale mul def % hexagon center-to-corner distance 
/HexLineWidth 0.1 Scale mul def 
/GraphVertexSize 1.0 Scale mul def
/GraphLineWidth 0.5 Scale mul def
/CircleRadius 3.0 Scale mul def 
/CircleLineWidth 0.346 Scale mul def 
/PerimeterWidth 0.5 Scale mul def 
/TextHeight 4.5 def
/TextWidth TextHeight 0.45 mul def 
/BoardShade 0.8 def
/CoordinatesShade 0.5 def
/MarkerSize 1.2 def
/CellOrientation 1 def   % 1: flat bottom  0: pointed bottom
/CellCorner [ % 6 cell corners, wrt center 0 0, plus "up" and "down"
   [ HexRadius  neg       0                           ] 
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul neg ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul neg ]
   [ HexRadius            0                           ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul     ]
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul neg ]
] def
%----- name cell corner indices ... see below
/Left  0 def /DownLeft 1 def /DownRight 2 def 
/Right 3 def /UpRight  4 def /UpLeft    5 def 
/Up    6 def /Down     7 def
%-----------------------------------------------------
% cell orientations:  flat bottom    flat side
%-----------------------------------------------------
% flat bottom 
% board cell indices            cell corner/top/bottom indices
%             --
%           /    \
%        --   1,3  --                  5 -6- 4
%      /    \    /    \               /       \
%   --   1,2  --   2,3  --           0         3
% /    \    /    \    /    \          \       /
%   1,1  --   2,2  --   3,3            1 -7- 2
% \    /    \    /    \    /
%   --   2,1  --   3,2  --
%      \    /    \    /   
%        --   3,1  --     
%----------------------------------------------------
% flat side 
%    /  \  /  \  /  \                       5
%   | 11 || 12 || 13 ||                   /   6
%    \  /  \  /  \  /  \                 0     4
%     || 21 || 22 || 23 |                |     |
%       \  /  \  /  \  /  \              1     3
%        || 31 || 32 || 33 |              7   /
%-------------------------------------------2--------
%----------- procedures -------------
/ScalePoint { % stack: ... x y size ==> ...  x*size y*size
   3 dict begin /size exch def /y exch def /x exch def
   x size mul           y size mul
end } def

/FlatTopBoard { FlatSideCells } def

/FlatSideCells {  % redefine cell orientation for flat side
  /CellOrientation 0 def   
  /CellCorner [ % 6 cell corners, wrt center 0 0  %xcoord ycoord
    [HexRadius Root3Div2 mul neg  HexRadius 2 div     ]
    [HexRadius Root3Div2 mul neg  HexRadius 2 div neg ]
    [0                            HexRadius neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div ]
    [0                            HexRadius ]
    [HexRadius Root3Div2 2 div mul HexRadius 0.75 mul ]
    [HexRadius Root3Div2 2 div mul neg HexRadius 0.75 mul neg ]
  ] def
} def

/HexCenterPoint { % center of cell (i,j)
    2 dict begin /j exch def /i exch def
    CellOrientation 1 eq {
    OriginX i j add HexRadius mul 1.5 mul add %Ox + (i+j)*HR*1.5
    OriginY i j sub HexRadius mul Root3Div2 mul sub %Oy - (i-j)*HR*R3/2
    }{
    OriginX i 2 j mul add HexRadius mul Root3Div2 mul add  %Ox + (2i+j)*HR
    OriginY i 1 sub HexRadius mul 1.5 mul sub %Oy - i*HR*R3/2
    } ifelse
end } def
 
/HexLine { % a b c d
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint lineto
    stroke
} def

/HexCurve { % a b c d e f
    /f exch def
    /e exch def
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint e f HexCenterPoint HexRadius 2 mul arcto
    e f HexCenterPoint lineto
    stroke
} def

/HxgnCorner { 5 dict begin /corn exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    x CellCorner corn get 0 get add
    y CellCorner corn get 1 get add
end } def

/Go { 2 dict begin /corn exch def /mag exch def
   % rlineto in a cell orientation direction
   CellCorner corn get aload pop mag ScalePoint rlineto
end } def

/TurnGo { rotate 1.0 Left Go } def % call: degrees TurnGo
/MagTurnGo { rotate Left Go } def % call: mag degrees TurnGo

/HexagonPath { % call: i j HexagonPath
    newpath 
    UpRight HxgnCorner moveto 
    6 { 1.0 Left Go 60 rotate } repeat 
} def

/FillAndStroke { 2 dict begin /sh exch def /wdth exch def
    gsave sh setgray fill
    grestore 0 setgray wdth setlinewidth stroke
end } def

/ShadedHexagon { 3 dict begin /shade exch def /j exch def /i exch def
    i j HexagonPath
    0 shade FillAndStroke
end } def

/Hexagon { % stack: ... i j
    HexagonPath 
    HexLineWidth BoardShade FillAndStroke
} def

/SemiHexagonPath { % stack: ... top i j
    newpath 
    1 eq { Left HxgnCorner moveto 
        1.0 UpRight Go 1.0 Right Go 1.0 DownRight Go stroke }{
        Right HxgnCorner moveto 
        1.0 DownLeft Go 1.0 Left Go 1.0 UpLeft Go stroke
    } ifelse
} def

/HexBoardPerimeter {
    newpath
    1 DimY UpRight HxgnCorner moveto 1.0 Left Go                      
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 rotate %restore rotation
} def

%----------- Havannah coordinates ----------------------
%                   ..  ..  ..
%                 d1  c2  b3  a4
%                   c1  b2  a3
%                     b1  a2
%                       a1
/HavannahPosn { % convert to usual coordinate, so ... x y  =>  ... 1+DimX-x  y
    exch DimX 1 add exch sub exch 
} def

/HavannahBoardPerimeter {
    newpath
    1 DimX UpRight HxgnCorner moveto 1.0 Left Go                      
    6 {Base 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo } repeat
} def

/DrawHexBoard { 2 dict begin
    gsave
    HexBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexPLBoard { 6 dict begin %point-line board
    gsave
    BoardShade setgray newpath
    -1 DimY 1 add 0.5 mul HexCenterPoint moveto
    1 DimY HexCenterPoint lineto
    DimX 1 add 0.5 mul DimY 2 add HexCenterPoint lineto
    DimX DimY HexCenterPoint lineto
    DimX 2 add DimY 1 add 0.5 mul HexCenterPoint lineto
    DimX 1 HexCenterPoint lineto
    DimX 1 add 0.5 mul -1 HexCenterPoint lineto
    1 1 HexCenterPoint lineto
    closepath fill 0 setgray
    1 DimY HexCenterPoint moveto
    1 1 DimX { /i exch def 
        i 1 i DimY HexLine 
        DimY 1 add 0.5 mul -1 i 1 HexLine
        DimY 1 add 0.5 mul DimY 2 add i DimY HexLine } for
    1 1 DimY { /j exch def 
        1 j DimX j HexLine 
        -1 DimX 1 add 0.5 mul 1 j HexLine
        DimX 2 add DimX 1 add 0.5 mul DimX j HexLine } for
    /topx 1 def /topy 1 def /btmx 1 def /btmy 1 def
    DimX DimY add 3 sub {
      topx DimX lt {/topx 1 topx add def}{/topy 1 topy add def} ifelse 
      btmy DimY lt {/btmy 1 btmy add def}{/btmx 1 btmx add def} ifelse 
      topx topy btmx btmy HexLine
      } repeat
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j HexVertex
	} for } for
    grestore
end } def

/DrawHavannahBoard { 3 dict begin
    /Base DimX 1 add 2 idiv  def
    gsave
    HavannahBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 Base { /j exch def
	Base j 1 sub sub 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    1 1 Base 1 sub { /j exch def
	1 1 DimX j sub { /i exch def
	   i j Base add 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexBorder{ 6 dict begin /start exch def 
    /cells exch def /isBlack exch def /which exch def
    gsave
    which UpLeft eq {1 DimY 1 add start sub Up HxgnCorner moveto /d Left def /r 60 def} if
    which UpRight eq {start DimY Up HxgnCorner moveto /d Right def /r 300 def} if
    which DownLeft eq {DimX 1 add start sub 1 Down HxgnCorner moveto /d Left def /r 300 def} if
    which DownRight eq {DimX start Down HxgnCorner moveto /d Right def /r 60 def} if
    0.5 d Go 
    which UpRight eq which DownRight eq or {180 rotate} if
    r TurnGo 
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.5 360 r sub MagTurnGo 1.5 360 r sub 2 mul MagTurnGo
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.75 360 r sub MagTurnGo
    closepath isBlack 1 eq {gsave fill grestore} if stroke grestore
end } def

/NoDrawHexBoard {  % dummy, used in creating bounding box
} def

/HexBoardBorders { 1 dict begin
    /upperLeftBlack exch def
    PerimeterWidth setlinewidth 0 setgray
    UpLeft    upperLeftBlack       DimY 1 DrawHexBorder
    UpRight   1 upperLeftBlack sub DimX 1 DrawHexBorder
    DownRight upperLeftBlack       DimY 1 DrawHexBorder
    DownLeft  1 upperLeftBlack sub DimX 1 DrawHexBorder
end } def

/YBoardPerimeter {
    newpath 1 1 DownRight HxgnCorner moveto 180 rotate
    3 { DimX 1 sub { 300 TurnGo 60 TurnGo } repeat 
        60 TurnGo 60 TurnGo} 
    repeat % now restore initial rotation state
    180 rotate % closepath
} def

/DrawYBoard { 2 dict begin
    YBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimX {/j exch def
        1 1 DimX 1 add j sub {/i exch def
	    i j 1 SemiHexagonPath stroke
        } for } for
end } def

/FontSelect { % bold italic FontSelect
    2 dict begin /italic exch def /bold exch def
    bold {
	italic 
	{ /Times-BoldItalic findfont TextHeight scalefont setfont } 
	{ /Times-Bold findfont TextHeight scalefont setfont }
	ifelse} 
        {
	italic {/Times-Italic findfont TextHeight scalefont setfont} 
	{ /Times findfont TextHeight scalefont setfont }
	ifelse}
    ifelse
end } def
	    
/LabelString {   % call: i j (str) strlen LabelString
%  to use with board rotation, remove comments
    6 dict begin /strlen exch def /str exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint /y exch def /x exch def
    %BoardRotation rotate
    x y moveto 
    %360 BoardRotation sub rotate
    TextWidth strlen mul 0.5 mul neg TextHeight 0.33 mul neg rmoveto
    str show 
end } def

/AbsLabelString { 4 dict begin
    /strlen exch def /str exch def /y exch def /x exch def
    newpath
    x AbsCoordX TextWidth strlen mul 0.5 mul sub
    y AbsCoordY TextHeight 0.33 mul sub
    moveto
    str
    show
end } def

/LabelStringVerb { % i j (str) strlen shade bold italic LabelStringVerb
    7 dict begin /italic exch def /bold exch def /shade exch def
    /strlen exch def /str exch def /j exch def /i exch def
    bold italic FontSelect shade setgray
    i j str strlen LabelString
end } def

/HexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimX { /i exch def
	i 0          Chars i 1 sub get 1 LabelString
	i DimY 1 add Chars i 1 sub get 1 LabelString
    } for
    1 1 DimY { /j exch def
	0 j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
	DimX 1 add j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HavannahBoardCoordinates { 3 dict begin
    false true FontSelect CoordinatesShade setgray
    /Base DimX 1 add 2 idiv  def
    1 1 Base { /i exch def
	i 0 HavannahPosn Chars  i 1 sub get 1 LabelString
	0 i HavannahPosn Digits i 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
    1 1 Base 1 sub { /i exch def
	i Base add i HavannahPosn Chars  i Base add 1 sub get 1 LabelString
	i i Base add HavannahPosn Digits i Base add 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/AltHexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimY { /j exch def
	0 j Chars j 1 sub get 1 LabelString
        %DimX 1 add j Chars j 1 sub get 1 LabelString
    } for
    1 1 DimX { /i exch def
	i 0 Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
	%i DimY 1 add Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HexDot { 3 dict begin /size exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint size 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexWhiteMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexWhitePiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexBlackMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexBlackPiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    1 setgray 0 setlinewidth fill
end } def

/HexDoubleMarker { 6 dict begin
    /shaderight exch def /shadeleft exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    gsave
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    shadeleft setgray 0 setlinewidth fill
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    shaderight setgray 0 setlinewidth fill
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    grestore
end } def

/HexBlackWhiteMarker { 0.0 1.0 HexDoubleMarker } def

/HexWhiteBlackMarker { 1.0 0.0 HexDoubleMarker } def
        
/HexMarker { 2 dict begin /j exch def /i exch def
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setlinewidth fill
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke  
end } def

/HexBlackMarker { 2 dict begin /j exch def /i exch def
    0 setgray
    i j HexMarker
end } def

/HexWhiteMarker { 2 dict begin /j exch def /i exch def
    1 setgray
    i j HexMarker
end } def
    
/HexPiece { 3 dict begin /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/MagicStone { 4 dict begin 
    /size exch def /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 1.3 mul size mul 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/HexWhitePiece { 1.0 HexPiece } def

/HexBlackPiece { 0.0 HexPiece } def

/HexWhiteLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def
    i j HexWhitePiece
    i j str strlen 0.0 true true LabelStringVerb
end } def

/HexBlackLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def 
    i j HexBlackPiece
    i j str strlen 1.0 true true LabelStringVerb
end } def

/AbsCoordX { 1 dict begin /x exch def
    OriginX x Scale mul add
end } def

/AbsCoordY { 1 dict begin /y exch def
    OriginY y Scale mul add
end } def

/DrawBox { /maxy exch def /maxx exch def /miny exch def /minx exch def
    newpath
    minx miny moveto
    maxx minx sub 0 rlineto
    0 maxy miny sub rlineto
    minx maxx sub 0 rlineto
    0 miny maxy sub rlineto
    HexLineWidth setlinewidth
    0 setgray
    stroke
} def

/HexVertex { 2 dict begin /j exch def /i exch def
    i j GraphVertexSize HexDot
end } def

/HexLine { 4 dict begin /j2 exch def /i2 exch def /j1 exch def /i1 exch def
    GraphLineWidth setlinewidth
    0 setgray
    newpath
    i1 j1 HexCenterPoint moveto
    i2 j2 HexCenterPoint lineto
    stroke
end } def

%%---------------- Program -------------------


FlatTopBoard
DrawHexBoard
1 HexBoardBorders


%------------ Trailer --------------

showpage

%%EndDocument
 @endspecial 563 9426 a @beginspecial 0 @llx 0 @lly 51
@urx 38 @ury 1133 @rwi @setspecial
%%BeginDocument: fz/pix/3x3.eps
%!PS-Adobe-3.0
%%Creator: Jack van Rijswijck, thanks to Cameron Browne
%%BoundingBox: 0 0 51 38
%%Pages: 0
%%EndComments

/OriginX -6 def
/OriginY 27 def
%---------------- Variables -------------------

/DimX 3 def
/DimY 3 def
/Scale 1.2 def


% draw  Hex boards, any size ... but labels only up to 26x26
% based on code by Cameron Browne, revised by Jack vR, revised by RBH
%-------------- state initializations -------------------------
1 setlinejoin   % lines meet at a point  ==>    use round join
%---------------- constants -------------------
/Root3Div2  0.86602540378444 def
/Chars   {[(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)
           (n)(o)(p)(q)(r)(s)(t)(u)(v)(w)(x)(y)(z)]} def
/CharsUC {[(A)(B)(C)(D)(E)(F)(G)(H)(I)(J)(K)(L)(M)
           (N)(O)(P)(Q)(R)(S)(T)(U)(V)(W)(X)(Y)(Z)]} def
/Digits  {[(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)(12)(13)
           (14)(15)(16)(17)(18)(19)(20)(21)(22)(23)(24)(25)(26)]} def
/HexRadius      5 Scale mul def % hexagon center-to-corner distance 
/HexLineWidth 0.1 Scale mul def 
/GraphVertexSize 1.0 Scale mul def
/GraphLineWidth 0.5 Scale mul def
/CircleRadius 3.0 Scale mul def 
/CircleLineWidth 0.346 Scale mul def 
/PerimeterWidth 0.5 Scale mul def 
/TextHeight 4.5 def
/TextWidth TextHeight 0.45 mul def 
/BoardShade 0.8 def
/CoordinatesShade 0.5 def
/MarkerSize 1.2 def
/CellOrientation 1 def   % 1: flat bottom  0: pointed bottom
/CellCorner [ % 6 cell corners, wrt center 0 0, plus "up" and "down"
   [ HexRadius  neg       0                           ] 
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul neg ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul neg ]
   [ HexRadius            0                           ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul     ]
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul neg ]
] def
%----- name cell corner indices ... see below
/Left  0 def /DownLeft 1 def /DownRight 2 def 
/Right 3 def /UpRight  4 def /UpLeft    5 def 
/Up    6 def /Down     7 def
%-----------------------------------------------------
% cell orientations:  flat bottom    flat side
%-----------------------------------------------------
% flat bottom 
% board cell indices            cell corner/top/bottom indices
%             --
%           /    \
%        --   1,3  --                  5 -6- 4
%      /    \    /    \               /       \
%   --   1,2  --   2,3  --           0         3
% /    \    /    \    /    \          \       /
%   1,1  --   2,2  --   3,3            1 -7- 2
% \    /    \    /    \    /
%   --   2,1  --   3,2  --
%      \    /    \    /   
%        --   3,1  --     
%----------------------------------------------------
% flat side 
%    /  \  /  \  /  \                       5
%   | 11 || 12 || 13 ||                   /   6
%    \  /  \  /  \  /  \                 0     4
%     || 21 || 22 || 23 |                |     |
%       \  /  \  /  \  /  \              1     3
%        || 31 || 32 || 33 |              7   /
%-------------------------------------------2--------
%----------- procedures -------------
/ScalePoint { % stack: ... x y size ==> ...  x*size y*size
   3 dict begin /size exch def /y exch def /x exch def
   x size mul           y size mul
end } def

/FlatTopBoard { FlatSideCells } def

/FlatSideCells {  % redefine cell orientation for flat side
  /CellOrientation 0 def   
  /CellCorner [ % 6 cell corners, wrt center 0 0  %xcoord ycoord
    [HexRadius Root3Div2 mul neg  HexRadius 2 div     ]
    [HexRadius Root3Div2 mul neg  HexRadius 2 div neg ]
    [0                            HexRadius neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div ]
    [0                            HexRadius ]
    [HexRadius Root3Div2 2 div mul HexRadius 0.75 mul ]
    [HexRadius Root3Div2 2 div mul neg HexRadius 0.75 mul neg ]
  ] def
} def

/HexCenterPoint { % center of cell (i,j)
    2 dict begin /j exch def /i exch def
    CellOrientation 1 eq {
    OriginX i j add HexRadius mul 1.5 mul add %Ox + (i+j)*HR*1.5
    OriginY i j sub HexRadius mul Root3Div2 mul sub %Oy - (i-j)*HR*R3/2
    }{
    OriginX i 2 j mul add HexRadius mul Root3Div2 mul add  %Ox + (2i+j)*HR
    OriginY i 1 sub HexRadius mul 1.5 mul sub %Oy - i*HR*R3/2
    } ifelse
end } def
 
/HexLine { % a b c d
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint lineto
    stroke
} def

/HexCurve { % a b c d e f
    /f exch def
    /e exch def
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint e f HexCenterPoint HexRadius 2 mul arcto
    e f HexCenterPoint lineto
    stroke
} def

/HxgnCorner { 5 dict begin /corn exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    x CellCorner corn get 0 get add
    y CellCorner corn get 1 get add
end } def

/Go { 2 dict begin /corn exch def /mag exch def
   % rlineto in a cell orientation direction
   CellCorner corn get aload pop mag ScalePoint rlineto
end } def

/TurnGo { rotate 1.0 Left Go } def % call: degrees TurnGo
/MagTurnGo { rotate Left Go } def % call: mag degrees TurnGo

/HexagonPath { % call: i j HexagonPath
    newpath 
    UpRight HxgnCorner moveto 
    6 { 1.0 Left Go 60 rotate } repeat 
} def

/FillAndStroke { 2 dict begin /sh exch def /wdth exch def
    gsave sh setgray fill
    grestore 0 setgray wdth setlinewidth stroke
end } def

/ShadedHexagon { 3 dict begin /shade exch def /j exch def /i exch def
    i j HexagonPath
    0 shade FillAndStroke
end } def

/Hexagon { % stack: ... i j
    HexagonPath 
    HexLineWidth BoardShade FillAndStroke
} def

/SemiHexagonPath { % stack: ... top i j
    newpath 
    1 eq { Left HxgnCorner moveto 
        1.0 UpRight Go 1.0 Right Go 1.0 DownRight Go stroke }{
        Right HxgnCorner moveto 
        1.0 DownLeft Go 1.0 Left Go 1.0 UpLeft Go stroke
    } ifelse
} def

/HexBoardPerimeter {
    newpath
    1 DimY UpRight HxgnCorner moveto 1.0 Left Go                      
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 rotate %restore rotation
} def

%----------- Havannah coordinates ----------------------
%                   ..  ..  ..
%                 d1  c2  b3  a4
%                   c1  b2  a3
%                     b1  a2
%                       a1
/HavannahPosn { % convert to usual coordinate, so ... x y  =>  ... 1+DimX-x  y
    exch DimX 1 add exch sub exch 
} def

/HavannahBoardPerimeter {
    newpath
    1 DimX UpRight HxgnCorner moveto 1.0 Left Go                      
    6 {Base 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo } repeat
} def

/DrawHexBoard { 2 dict begin
    gsave
    HexBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexPLBoard { 6 dict begin %point-line board
    gsave
    BoardShade setgray newpath
    -1 DimY 1 add 0.5 mul HexCenterPoint moveto
    1 DimY HexCenterPoint lineto
    DimX 1 add 0.5 mul DimY 2 add HexCenterPoint lineto
    DimX DimY HexCenterPoint lineto
    DimX 2 add DimY 1 add 0.5 mul HexCenterPoint lineto
    DimX 1 HexCenterPoint lineto
    DimX 1 add 0.5 mul -1 HexCenterPoint lineto
    1 1 HexCenterPoint lineto
    closepath fill 0 setgray
    1 DimY HexCenterPoint moveto
    1 1 DimX { /i exch def 
        i 1 i DimY HexLine 
        DimY 1 add 0.5 mul -1 i 1 HexLine
        DimY 1 add 0.5 mul DimY 2 add i DimY HexLine } for
    1 1 DimY { /j exch def 
        1 j DimX j HexLine 
        -1 DimX 1 add 0.5 mul 1 j HexLine
        DimX 2 add DimX 1 add 0.5 mul DimX j HexLine } for
    /topx 1 def /topy 1 def /btmx 1 def /btmy 1 def
    DimX DimY add 3 sub {
      topx DimX lt {/topx 1 topx add def}{/topy 1 topy add def} ifelse 
      btmy DimY lt {/btmy 1 btmy add def}{/btmx 1 btmx add def} ifelse 
      topx topy btmx btmy HexLine
      } repeat
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j HexVertex
	} for } for
    grestore
end } def

/DrawHavannahBoard { 3 dict begin
    /Base DimX 1 add 2 idiv  def
    gsave
    HavannahBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 Base { /j exch def
	Base j 1 sub sub 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    1 1 Base 1 sub { /j exch def
	1 1 DimX j sub { /i exch def
	   i j Base add 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexBorder{ 6 dict begin /start exch def 
    /cells exch def /isBlack exch def /which exch def
    gsave
    which UpLeft eq {1 DimY 1 add start sub Up HxgnCorner moveto /d Left def /r 60 def} if
    which UpRight eq {start DimY Up HxgnCorner moveto /d Right def /r 300 def} if
    which DownLeft eq {DimX 1 add start sub 1 Down HxgnCorner moveto /d Left def /r 300 def} if
    which DownRight eq {DimX start Down HxgnCorner moveto /d Right def /r 60 def} if
    0.5 d Go 
    which UpRight eq which DownRight eq or {180 rotate} if
    r TurnGo 
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.5 360 r sub MagTurnGo 1.5 360 r sub 2 mul MagTurnGo
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.75 360 r sub MagTurnGo
    closepath isBlack 1 eq {gsave fill grestore} if stroke grestore
end } def

/NoDrawHexBoard {  % dummy, used in creating bounding box
} def

/HexBoardBorders { 1 dict begin
    /upperLeftBlack exch def
    PerimeterWidth setlinewidth 0 setgray
    UpLeft    upperLeftBlack       DimY 1 DrawHexBorder
    UpRight   1 upperLeftBlack sub DimX 1 DrawHexBorder
    DownRight upperLeftBlack       DimY 1 DrawHexBorder
    DownLeft  1 upperLeftBlack sub DimX 1 DrawHexBorder
end } def

/YBoardPerimeter {
    newpath 1 1 DownRight HxgnCorner moveto 180 rotate
    3 { DimX 1 sub { 300 TurnGo 60 TurnGo } repeat 
        60 TurnGo 60 TurnGo} 
    repeat % now restore initial rotation state
    180 rotate % closepath
} def

/DrawYBoard { 2 dict begin
    YBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimX {/j exch def
        1 1 DimX 1 add j sub {/i exch def
	    i j 1 SemiHexagonPath stroke
        } for } for
end } def

/FontSelect { % bold italic FontSelect
    2 dict begin /italic exch def /bold exch def
    bold {
	italic 
	{ /Times-BoldItalic findfont TextHeight scalefont setfont } 
	{ /Times-Bold findfont TextHeight scalefont setfont }
	ifelse} 
        {
	italic {/Times-Italic findfont TextHeight scalefont setfont} 
	{ /Times findfont TextHeight scalefont setfont }
	ifelse}
    ifelse
end } def
	    
/LabelString {   % call: i j (str) strlen LabelString
%  to use with board rotation, remove comments
    6 dict begin /strlen exch def /str exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint /y exch def /x exch def
    %BoardRotation rotate
    x y moveto 
    %360 BoardRotation sub rotate
    TextWidth strlen mul 0.5 mul neg TextHeight 0.33 mul neg rmoveto
    str show 
end } def

/AbsLabelString { 4 dict begin
    /strlen exch def /str exch def /y exch def /x exch def
    newpath
    x AbsCoordX TextWidth strlen mul 0.5 mul sub
    y AbsCoordY TextHeight 0.33 mul sub
    moveto
    str
    show
end } def

/LabelStringVerb { % i j (str) strlen shade bold italic LabelStringVerb
    7 dict begin /italic exch def /bold exch def /shade exch def
    /strlen exch def /str exch def /j exch def /i exch def
    bold italic FontSelect shade setgray
    i j str strlen LabelString
end } def

/HexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimX { /i exch def
	i 0          Chars i 1 sub get 1 LabelString
	i DimY 1 add Chars i 1 sub get 1 LabelString
    } for
    1 1 DimY { /j exch def
	0 j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
	DimX 1 add j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HavannahBoardCoordinates { 3 dict begin
    false true FontSelect CoordinatesShade setgray
    /Base DimX 1 add 2 idiv  def
    1 1 Base { /i exch def
	i 0 HavannahPosn Chars  i 1 sub get 1 LabelString
	0 i HavannahPosn Digits i 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
    1 1 Base 1 sub { /i exch def
	i Base add i HavannahPosn Chars  i Base add 1 sub get 1 LabelString
	i i Base add HavannahPosn Digits i Base add 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/AltHexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimY { /j exch def
	0 j Chars j 1 sub get 1 LabelString
        %DimX 1 add j Chars j 1 sub get 1 LabelString
    } for
    1 1 DimX { /i exch def
	i 0 Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
	%i DimY 1 add Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HexDot { 3 dict begin /size exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint size 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexWhiteMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexWhitePiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexBlackMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexBlackPiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    1 setgray 0 setlinewidth fill
end } def

/HexDoubleMarker { 6 dict begin
    /shaderight exch def /shadeleft exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    gsave
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    shadeleft setgray 0 setlinewidth fill
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    shaderight setgray 0 setlinewidth fill
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    grestore
end } def

/HexBlackWhiteMarker { 0.0 1.0 HexDoubleMarker } def

/HexWhiteBlackMarker { 1.0 0.0 HexDoubleMarker } def
        
/HexMarker { 2 dict begin /j exch def /i exch def
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setlinewidth fill
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke  
end } def

/HexBlackMarker { 2 dict begin /j exch def /i exch def
    0 setgray
    i j HexMarker
end } def

/HexWhiteMarker { 2 dict begin /j exch def /i exch def
    1 setgray
    i j HexMarker
end } def
    
/HexPiece { 3 dict begin /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/MagicStone { 4 dict begin 
    /size exch def /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 1.3 mul size mul 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/HexWhitePiece { 1.0 HexPiece } def

/HexBlackPiece { 0.0 HexPiece } def

/HexWhiteLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def
    i j HexWhitePiece
    i j str strlen 0.0 true true LabelStringVerb
end } def

/HexBlackLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def 
    i j HexBlackPiece
    i j str strlen 1.0 true true LabelStringVerb
end } def

/AbsCoordX { 1 dict begin /x exch def
    OriginX x Scale mul add
end } def

/AbsCoordY { 1 dict begin /y exch def
    OriginY y Scale mul add
end } def

/DrawBox { /maxy exch def /maxx exch def /miny exch def /minx exch def
    newpath
    minx miny moveto
    maxx minx sub 0 rlineto
    0 maxy miny sub rlineto
    minx maxx sub 0 rlineto
    0 miny maxy sub rlineto
    HexLineWidth setlinewidth
    0 setgray
    stroke
} def

/HexVertex { 2 dict begin /j exch def /i exch def
    i j GraphVertexSize HexDot
end } def

/HexLine { 4 dict begin /j2 exch def /i2 exch def /j1 exch def /i1 exch def
    GraphLineWidth setlinewidth
    0 setgray
    newpath
    i1 j1 HexCenterPoint moveto
    i2 j2 HexCenterPoint lineto
    stroke
end } def

%%---------------- Program -------------------


FlatTopBoard
DrawHexBoard
1 HexBoardBorders


%------------ Trailer --------------

showpage

%%EndDocument
 @endspecial 1900 w @beginspecial 0 @llx 0 @lly 51 @urx
38 @ury 1133 @rwi @setspecial
%%BeginDocument: fz/pix/3x3.eps
%!PS-Adobe-3.0
%%Creator: Jack van Rijswijck, thanks to Cameron Browne
%%BoundingBox: 0 0 51 38
%%Pages: 0
%%EndComments

/OriginX -6 def
/OriginY 27 def
%---------------- Variables -------------------

/DimX 3 def
/DimY 3 def
/Scale 1.2 def


% draw  Hex boards, any size ... but labels only up to 26x26
% based on code by Cameron Browne, revised by Jack vR, revised by RBH
%-------------- state initializations -------------------------
1 setlinejoin   % lines meet at a point  ==>    use round join
%---------------- constants -------------------
/Root3Div2  0.86602540378444 def
/Chars   {[(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)
           (n)(o)(p)(q)(r)(s)(t)(u)(v)(w)(x)(y)(z)]} def
/CharsUC {[(A)(B)(C)(D)(E)(F)(G)(H)(I)(J)(K)(L)(M)
           (N)(O)(P)(Q)(R)(S)(T)(U)(V)(W)(X)(Y)(Z)]} def
/Digits  {[(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)(12)(13)
           (14)(15)(16)(17)(18)(19)(20)(21)(22)(23)(24)(25)(26)]} def
/HexRadius      5 Scale mul def % hexagon center-to-corner distance 
/HexLineWidth 0.1 Scale mul def 
/GraphVertexSize 1.0 Scale mul def
/GraphLineWidth 0.5 Scale mul def
/CircleRadius 3.0 Scale mul def 
/CircleLineWidth 0.346 Scale mul def 
/PerimeterWidth 0.5 Scale mul def 
/TextHeight 4.5 def
/TextWidth TextHeight 0.45 mul def 
/BoardShade 0.8 def
/CoordinatesShade 0.5 def
/MarkerSize 1.2 def
/CellOrientation 1 def   % 1: flat bottom  0: pointed bottom
/CellCorner [ % 6 cell corners, wrt center 0 0, plus "up" and "down"
   [ HexRadius  neg       0                           ] 
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul neg ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul neg ]
   [ HexRadius            0                           ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul     ]
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul neg ]
] def
%----- name cell corner indices ... see below
/Left  0 def /DownLeft 1 def /DownRight 2 def 
/Right 3 def /UpRight  4 def /UpLeft    5 def 
/Up    6 def /Down     7 def
%-----------------------------------------------------
% cell orientations:  flat bottom    flat side
%-----------------------------------------------------
% flat bottom 
% board cell indices            cell corner/top/bottom indices
%             --
%           /    \
%        --   1,3  --                  5 -6- 4
%      /    \    /    \               /       \
%   --   1,2  --   2,3  --           0         3
% /    \    /    \    /    \          \       /
%   1,1  --   2,2  --   3,3            1 -7- 2
% \    /    \    /    \    /
%   --   2,1  --   3,2  --
%      \    /    \    /   
%        --   3,1  --     
%----------------------------------------------------
% flat side 
%    /  \  /  \  /  \                       5
%   | 11 || 12 || 13 ||                   /   6
%    \  /  \  /  \  /  \                 0     4
%     || 21 || 22 || 23 |                |     |
%       \  /  \  /  \  /  \              1     3
%        || 31 || 32 || 33 |              7   /
%-------------------------------------------2--------
%----------- procedures -------------
/ScalePoint { % stack: ... x y size ==> ...  x*size y*size
   3 dict begin /size exch def /y exch def /x exch def
   x size mul           y size mul
end } def

/FlatTopBoard { FlatSideCells } def

/FlatSideCells {  % redefine cell orientation for flat side
  /CellOrientation 0 def   
  /CellCorner [ % 6 cell corners, wrt center 0 0  %xcoord ycoord
    [HexRadius Root3Div2 mul neg  HexRadius 2 div     ]
    [HexRadius Root3Div2 mul neg  HexRadius 2 div neg ]
    [0                            HexRadius neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div ]
    [0                            HexRadius ]
    [HexRadius Root3Div2 2 div mul HexRadius 0.75 mul ]
    [HexRadius Root3Div2 2 div mul neg HexRadius 0.75 mul neg ]
  ] def
} def

/HexCenterPoint { % center of cell (i,j)
    2 dict begin /j exch def /i exch def
    CellOrientation 1 eq {
    OriginX i j add HexRadius mul 1.5 mul add %Ox + (i+j)*HR*1.5
    OriginY i j sub HexRadius mul Root3Div2 mul sub %Oy - (i-j)*HR*R3/2
    }{
    OriginX i 2 j mul add HexRadius mul Root3Div2 mul add  %Ox + (2i+j)*HR
    OriginY i 1 sub HexRadius mul 1.5 mul sub %Oy - i*HR*R3/2
    } ifelse
end } def
 
/HexLine { % a b c d
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint lineto
    stroke
} def

/HexCurve { % a b c d e f
    /f exch def
    /e exch def
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint e f HexCenterPoint HexRadius 2 mul arcto
    e f HexCenterPoint lineto
    stroke
} def

/HxgnCorner { 5 dict begin /corn exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    x CellCorner corn get 0 get add
    y CellCorner corn get 1 get add
end } def

/Go { 2 dict begin /corn exch def /mag exch def
   % rlineto in a cell orientation direction
   CellCorner corn get aload pop mag ScalePoint rlineto
end } def

/TurnGo { rotate 1.0 Left Go } def % call: degrees TurnGo
/MagTurnGo { rotate Left Go } def % call: mag degrees TurnGo

/HexagonPath { % call: i j HexagonPath
    newpath 
    UpRight HxgnCorner moveto 
    6 { 1.0 Left Go 60 rotate } repeat 
} def

/FillAndStroke { 2 dict begin /sh exch def /wdth exch def
    gsave sh setgray fill
    grestore 0 setgray wdth setlinewidth stroke
end } def

/ShadedHexagon { 3 dict begin /shade exch def /j exch def /i exch def
    i j HexagonPath
    0 shade FillAndStroke
end } def

/Hexagon { % stack: ... i j
    HexagonPath 
    HexLineWidth BoardShade FillAndStroke
} def

/SemiHexagonPath { % stack: ... top i j
    newpath 
    1 eq { Left HxgnCorner moveto 
        1.0 UpRight Go 1.0 Right Go 1.0 DownRight Go stroke }{
        Right HxgnCorner moveto 
        1.0 DownLeft Go 1.0 Left Go 1.0 UpLeft Go stroke
    } ifelse
} def

/HexBoardPerimeter {
    newpath
    1 DimY UpRight HxgnCorner moveto 1.0 Left Go                      
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 rotate %restore rotation
} def

%----------- Havannah coordinates ----------------------
%                   ..  ..  ..
%                 d1  c2  b3  a4
%                   c1  b2  a3
%                     b1  a2
%                       a1
/HavannahPosn { % convert to usual coordinate, so ... x y  =>  ... 1+DimX-x  y
    exch DimX 1 add exch sub exch 
} def

/HavannahBoardPerimeter {
    newpath
    1 DimX UpRight HxgnCorner moveto 1.0 Left Go                      
    6 {Base 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo } repeat
} def

/DrawHexBoard { 2 dict begin
    gsave
    HexBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexPLBoard { 6 dict begin %point-line board
    gsave
    BoardShade setgray newpath
    -1 DimY 1 add 0.5 mul HexCenterPoint moveto
    1 DimY HexCenterPoint lineto
    DimX 1 add 0.5 mul DimY 2 add HexCenterPoint lineto
    DimX DimY HexCenterPoint lineto
    DimX 2 add DimY 1 add 0.5 mul HexCenterPoint lineto
    DimX 1 HexCenterPoint lineto
    DimX 1 add 0.5 mul -1 HexCenterPoint lineto
    1 1 HexCenterPoint lineto
    closepath fill 0 setgray
    1 DimY HexCenterPoint moveto
    1 1 DimX { /i exch def 
        i 1 i DimY HexLine 
        DimY 1 add 0.5 mul -1 i 1 HexLine
        DimY 1 add 0.5 mul DimY 2 add i DimY HexLine } for
    1 1 DimY { /j exch def 
        1 j DimX j HexLine 
        -1 DimX 1 add 0.5 mul 1 j HexLine
        DimX 2 add DimX 1 add 0.5 mul DimX j HexLine } for
    /topx 1 def /topy 1 def /btmx 1 def /btmy 1 def
    DimX DimY add 3 sub {
      topx DimX lt {/topx 1 topx add def}{/topy 1 topy add def} ifelse 
      btmy DimY lt {/btmy 1 btmy add def}{/btmx 1 btmx add def} ifelse 
      topx topy btmx btmy HexLine
      } repeat
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j HexVertex
	} for } for
    grestore
end } def

/DrawHavannahBoard { 3 dict begin
    /Base DimX 1 add 2 idiv  def
    gsave
    HavannahBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 Base { /j exch def
	Base j 1 sub sub 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    1 1 Base 1 sub { /j exch def
	1 1 DimX j sub { /i exch def
	   i j Base add 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexBorder{ 6 dict begin /start exch def 
    /cells exch def /isBlack exch def /which exch def
    gsave
    which UpLeft eq {1 DimY 1 add start sub Up HxgnCorner moveto /d Left def /r 60 def} if
    which UpRight eq {start DimY Up HxgnCorner moveto /d Right def /r 300 def} if
    which DownLeft eq {DimX 1 add start sub 1 Down HxgnCorner moveto /d Left def /r 300 def} if
    which DownRight eq {DimX start Down HxgnCorner moveto /d Right def /r 60 def} if
    0.5 d Go 
    which UpRight eq which DownRight eq or {180 rotate} if
    r TurnGo 
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.5 360 r sub MagTurnGo 1.5 360 r sub 2 mul MagTurnGo
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.75 360 r sub MagTurnGo
    closepath isBlack 1 eq {gsave fill grestore} if stroke grestore
end } def

/NoDrawHexBoard {  % dummy, used in creating bounding box
} def

/HexBoardBorders { 1 dict begin
    /upperLeftBlack exch def
    PerimeterWidth setlinewidth 0 setgray
    UpLeft    upperLeftBlack       DimY 1 DrawHexBorder
    UpRight   1 upperLeftBlack sub DimX 1 DrawHexBorder
    DownRight upperLeftBlack       DimY 1 DrawHexBorder
    DownLeft  1 upperLeftBlack sub DimX 1 DrawHexBorder
end } def

/YBoardPerimeter {
    newpath 1 1 DownRight HxgnCorner moveto 180 rotate
    3 { DimX 1 sub { 300 TurnGo 60 TurnGo } repeat 
        60 TurnGo 60 TurnGo} 
    repeat % now restore initial rotation state
    180 rotate % closepath
} def

/DrawYBoard { 2 dict begin
    YBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimX {/j exch def
        1 1 DimX 1 add j sub {/i exch def
	    i j 1 SemiHexagonPath stroke
        } for } for
end } def

/FontSelect { % bold italic FontSelect
    2 dict begin /italic exch def /bold exch def
    bold {
	italic 
	{ /Times-BoldItalic findfont TextHeight scalefont setfont } 
	{ /Times-Bold findfont TextHeight scalefont setfont }
	ifelse} 
        {
	italic {/Times-Italic findfont TextHeight scalefont setfont} 
	{ /Times findfont TextHeight scalefont setfont }
	ifelse}
    ifelse
end } def
	    
/LabelString {   % call: i j (str) strlen LabelString
%  to use with board rotation, remove comments
    6 dict begin /strlen exch def /str exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint /y exch def /x exch def
    %BoardRotation rotate
    x y moveto 
    %360 BoardRotation sub rotate
    TextWidth strlen mul 0.5 mul neg TextHeight 0.33 mul neg rmoveto
    str show 
end } def

/AbsLabelString { 4 dict begin
    /strlen exch def /str exch def /y exch def /x exch def
    newpath
    x AbsCoordX TextWidth strlen mul 0.5 mul sub
    y AbsCoordY TextHeight 0.33 mul sub
    moveto
    str
    show
end } def

/LabelStringVerb { % i j (str) strlen shade bold italic LabelStringVerb
    7 dict begin /italic exch def /bold exch def /shade exch def
    /strlen exch def /str exch def /j exch def /i exch def
    bold italic FontSelect shade setgray
    i j str strlen LabelString
end } def

/HexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimX { /i exch def
	i 0          Chars i 1 sub get 1 LabelString
	i DimY 1 add Chars i 1 sub get 1 LabelString
    } for
    1 1 DimY { /j exch def
	0 j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
	DimX 1 add j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HavannahBoardCoordinates { 3 dict begin
    false true FontSelect CoordinatesShade setgray
    /Base DimX 1 add 2 idiv  def
    1 1 Base { /i exch def
	i 0 HavannahPosn Chars  i 1 sub get 1 LabelString
	0 i HavannahPosn Digits i 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
    1 1 Base 1 sub { /i exch def
	i Base add i HavannahPosn Chars  i Base add 1 sub get 1 LabelString
	i i Base add HavannahPosn Digits i Base add 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/AltHexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimY { /j exch def
	0 j Chars j 1 sub get 1 LabelString
        %DimX 1 add j Chars j 1 sub get 1 LabelString
    } for
    1 1 DimX { /i exch def
	i 0 Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
	%i DimY 1 add Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HexDot { 3 dict begin /size exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint size 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexWhiteMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexWhitePiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexBlackMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexBlackPiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    1 setgray 0 setlinewidth fill
end } def

/HexDoubleMarker { 6 dict begin
    /shaderight exch def /shadeleft exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    gsave
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    shadeleft setgray 0 setlinewidth fill
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    shaderight setgray 0 setlinewidth fill
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    grestore
end } def

/HexBlackWhiteMarker { 0.0 1.0 HexDoubleMarker } def

/HexWhiteBlackMarker { 1.0 0.0 HexDoubleMarker } def
        
/HexMarker { 2 dict begin /j exch def /i exch def
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setlinewidth fill
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke  
end } def

/HexBlackMarker { 2 dict begin /j exch def /i exch def
    0 setgray
    i j HexMarker
end } def

/HexWhiteMarker { 2 dict begin /j exch def /i exch def
    1 setgray
    i j HexMarker
end } def
    
/HexPiece { 3 dict begin /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/MagicStone { 4 dict begin 
    /size exch def /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 1.3 mul size mul 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/HexWhitePiece { 1.0 HexPiece } def

/HexBlackPiece { 0.0 HexPiece } def

/HexWhiteLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def
    i j HexWhitePiece
    i j str strlen 0.0 true true LabelStringVerb
end } def

/HexBlackLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def 
    i j HexBlackPiece
    i j str strlen 1.0 true true LabelStringVerb
end } def

/AbsCoordX { 1 dict begin /x exch def
    OriginX x Scale mul add
end } def

/AbsCoordY { 1 dict begin /y exch def
    OriginY y Scale mul add
end } def

/DrawBox { /maxy exch def /maxx exch def /miny exch def /minx exch def
    newpath
    minx miny moveto
    maxx minx sub 0 rlineto
    0 maxy miny sub rlineto
    minx maxx sub 0 rlineto
    0 miny maxy sub rlineto
    HexLineWidth setlinewidth
    0 setgray
    stroke
} def

/HexVertex { 2 dict begin /j exch def /i exch def
    i j GraphVertexSize HexDot
end } def

/HexLine { 4 dict begin /j2 exch def /i2 exch def /j1 exch def /i1 exch def
    GraphLineWidth setlinewidth
    0 setgray
    newpath
    i1 j1 HexCenterPoint moveto
    i2 j2 HexCenterPoint lineto
    stroke
end } def

%%---------------- Program -------------------


FlatTopBoard
DrawHexBoard
1 HexBoardBorders


%------------ Trailer --------------

showpage

%%EndDocument
 @endspecial 1900 w @beginspecial 0 @llx 0 @lly 51 @urx
38 @ury 1133 @rwi @setspecial
%%BeginDocument: fz/pix/3x3.eps
%!PS-Adobe-3.0
%%Creator: Jack van Rijswijck, thanks to Cameron Browne
%%BoundingBox: 0 0 51 38
%%Pages: 0
%%EndComments

/OriginX -6 def
/OriginY 27 def
%---------------- Variables -------------------

/DimX 3 def
/DimY 3 def
/Scale 1.2 def


% draw  Hex boards, any size ... but labels only up to 26x26
% based on code by Cameron Browne, revised by Jack vR, revised by RBH
%-------------- state initializations -------------------------
1 setlinejoin   % lines meet at a point  ==>    use round join
%---------------- constants -------------------
/Root3Div2  0.86602540378444 def
/Chars   {[(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)
           (n)(o)(p)(q)(r)(s)(t)(u)(v)(w)(x)(y)(z)]} def
/CharsUC {[(A)(B)(C)(D)(E)(F)(G)(H)(I)(J)(K)(L)(M)
           (N)(O)(P)(Q)(R)(S)(T)(U)(V)(W)(X)(Y)(Z)]} def
/Digits  {[(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)(12)(13)
           (14)(15)(16)(17)(18)(19)(20)(21)(22)(23)(24)(25)(26)]} def
/HexRadius      5 Scale mul def % hexagon center-to-corner distance 
/HexLineWidth 0.1 Scale mul def 
/GraphVertexSize 1.0 Scale mul def
/GraphLineWidth 0.5 Scale mul def
/CircleRadius 3.0 Scale mul def 
/CircleLineWidth 0.346 Scale mul def 
/PerimeterWidth 0.5 Scale mul def 
/TextHeight 4.5 def
/TextWidth TextHeight 0.45 mul def 
/BoardShade 0.8 def
/CoordinatesShade 0.5 def
/MarkerSize 1.2 def
/CellOrientation 1 def   % 1: flat bottom  0: pointed bottom
/CellCorner [ % 6 cell corners, wrt center 0 0, plus "up" and "down"
   [ HexRadius  neg       0                           ] 
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul neg ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul neg ]
   [ HexRadius            0                           ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul     ]
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul neg ]
] def
%----- name cell corner indices ... see below
/Left  0 def /DownLeft 1 def /DownRight 2 def 
/Right 3 def /UpRight  4 def /UpLeft    5 def 
/Up    6 def /Down     7 def
%-----------------------------------------------------
% cell orientations:  flat bottom    flat side
%-----------------------------------------------------
% flat bottom 
% board cell indices            cell corner/top/bottom indices
%             --
%           /    \
%        --   1,3  --                  5 -6- 4
%      /    \    /    \               /       \
%   --   1,2  --   2,3  --           0         3
% /    \    /    \    /    \          \       /
%   1,1  --   2,2  --   3,3            1 -7- 2
% \    /    \    /    \    /
%   --   2,1  --   3,2  --
%      \    /    \    /   
%        --   3,1  --     
%----------------------------------------------------
% flat side 
%    /  \  /  \  /  \                       5
%   | 11 || 12 || 13 ||                   /   6
%    \  /  \  /  \  /  \                 0     4
%     || 21 || 22 || 23 |                |     |
%       \  /  \  /  \  /  \              1     3
%        || 31 || 32 || 33 |              7   /
%-------------------------------------------2--------
%----------- procedures -------------
/ScalePoint { % stack: ... x y size ==> ...  x*size y*size
   3 dict begin /size exch def /y exch def /x exch def
   x size mul           y size mul
end } def

/FlatTopBoard { FlatSideCells } def

/FlatSideCells {  % redefine cell orientation for flat side
  /CellOrientation 0 def   
  /CellCorner [ % 6 cell corners, wrt center 0 0  %xcoord ycoord
    [HexRadius Root3Div2 mul neg  HexRadius 2 div     ]
    [HexRadius Root3Div2 mul neg  HexRadius 2 div neg ]
    [0                            HexRadius neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div ]
    [0                            HexRadius ]
    [HexRadius Root3Div2 2 div mul HexRadius 0.75 mul ]
    [HexRadius Root3Div2 2 div mul neg HexRadius 0.75 mul neg ]
  ] def
} def

/HexCenterPoint { % center of cell (i,j)
    2 dict begin /j exch def /i exch def
    CellOrientation 1 eq {
    OriginX i j add HexRadius mul 1.5 mul add %Ox + (i+j)*HR*1.5
    OriginY i j sub HexRadius mul Root3Div2 mul sub %Oy - (i-j)*HR*R3/2
    }{
    OriginX i 2 j mul add HexRadius mul Root3Div2 mul add  %Ox + (2i+j)*HR
    OriginY i 1 sub HexRadius mul 1.5 mul sub %Oy - i*HR*R3/2
    } ifelse
end } def
 
/HexLine { % a b c d
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint lineto
    stroke
} def

/HexCurve { % a b c d e f
    /f exch def
    /e exch def
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint e f HexCenterPoint HexRadius 2 mul arcto
    e f HexCenterPoint lineto
    stroke
} def

/HxgnCorner { 5 dict begin /corn exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    x CellCorner corn get 0 get add
    y CellCorner corn get 1 get add
end } def

/Go { 2 dict begin /corn exch def /mag exch def
   % rlineto in a cell orientation direction
   CellCorner corn get aload pop mag ScalePoint rlineto
end } def

/TurnGo { rotate 1.0 Left Go } def % call: degrees TurnGo
/MagTurnGo { rotate Left Go } def % call: mag degrees TurnGo

/HexagonPath { % call: i j HexagonPath
    newpath 
    UpRight HxgnCorner moveto 
    6 { 1.0 Left Go 60 rotate } repeat 
} def

/FillAndStroke { 2 dict begin /sh exch def /wdth exch def
    gsave sh setgray fill
    grestore 0 setgray wdth setlinewidth stroke
end } def

/ShadedHexagon { 3 dict begin /shade exch def /j exch def /i exch def
    i j HexagonPath
    0 shade FillAndStroke
end } def

/Hexagon { % stack: ... i j
    HexagonPath 
    HexLineWidth BoardShade FillAndStroke
} def

/SemiHexagonPath { % stack: ... top i j
    newpath 
    1 eq { Left HxgnCorner moveto 
        1.0 UpRight Go 1.0 Right Go 1.0 DownRight Go stroke }{
        Right HxgnCorner moveto 
        1.0 DownLeft Go 1.0 Left Go 1.0 UpLeft Go stroke
    } ifelse
} def

/HexBoardPerimeter {
    newpath
    1 DimY UpRight HxgnCorner moveto 1.0 Left Go                      
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 rotate %restore rotation
} def

%----------- Havannah coordinates ----------------------
%                   ..  ..  ..
%                 d1  c2  b3  a4
%                   c1  b2  a3
%                     b1  a2
%                       a1
/HavannahPosn { % convert to usual coordinate, so ... x y  =>  ... 1+DimX-x  y
    exch DimX 1 add exch sub exch 
} def

/HavannahBoardPerimeter {
    newpath
    1 DimX UpRight HxgnCorner moveto 1.0 Left Go                      
    6 {Base 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo } repeat
} def

/DrawHexBoard { 2 dict begin
    gsave
    HexBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexPLBoard { 6 dict begin %point-line board
    gsave
    BoardShade setgray newpath
    -1 DimY 1 add 0.5 mul HexCenterPoint moveto
    1 DimY HexCenterPoint lineto
    DimX 1 add 0.5 mul DimY 2 add HexCenterPoint lineto
    DimX DimY HexCenterPoint lineto
    DimX 2 add DimY 1 add 0.5 mul HexCenterPoint lineto
    DimX 1 HexCenterPoint lineto
    DimX 1 add 0.5 mul -1 HexCenterPoint lineto
    1 1 HexCenterPoint lineto
    closepath fill 0 setgray
    1 DimY HexCenterPoint moveto
    1 1 DimX { /i exch def 
        i 1 i DimY HexLine 
        DimY 1 add 0.5 mul -1 i 1 HexLine
        DimY 1 add 0.5 mul DimY 2 add i DimY HexLine } for
    1 1 DimY { /j exch def 
        1 j DimX j HexLine 
        -1 DimX 1 add 0.5 mul 1 j HexLine
        DimX 2 add DimX 1 add 0.5 mul DimX j HexLine } for
    /topx 1 def /topy 1 def /btmx 1 def /btmy 1 def
    DimX DimY add 3 sub {
      topx DimX lt {/topx 1 topx add def}{/topy 1 topy add def} ifelse 
      btmy DimY lt {/btmy 1 btmy add def}{/btmx 1 btmx add def} ifelse 
      topx topy btmx btmy HexLine
      } repeat
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j HexVertex
	} for } for
    grestore
end } def

/DrawHavannahBoard { 3 dict begin
    /Base DimX 1 add 2 idiv  def
    gsave
    HavannahBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 Base { /j exch def
	Base j 1 sub sub 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    1 1 Base 1 sub { /j exch def
	1 1 DimX j sub { /i exch def
	   i j Base add 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexBorder{ 6 dict begin /start exch def 
    /cells exch def /isBlack exch def /which exch def
    gsave
    which UpLeft eq {1 DimY 1 add start sub Up HxgnCorner moveto /d Left def /r 60 def} if
    which UpRight eq {start DimY Up HxgnCorner moveto /d Right def /r 300 def} if
    which DownLeft eq {DimX 1 add start sub 1 Down HxgnCorner moveto /d Left def /r 300 def} if
    which DownRight eq {DimX start Down HxgnCorner moveto /d Right def /r 60 def} if
    0.5 d Go 
    which UpRight eq which DownRight eq or {180 rotate} if
    r TurnGo 
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.5 360 r sub MagTurnGo 1.5 360 r sub 2 mul MagTurnGo
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.75 360 r sub MagTurnGo
    closepath isBlack 1 eq {gsave fill grestore} if stroke grestore
end } def

/NoDrawHexBoard {  % dummy, used in creating bounding box
} def

/HexBoardBorders { 1 dict begin
    /upperLeftBlack exch def
    PerimeterWidth setlinewidth 0 setgray
    UpLeft    upperLeftBlack       DimY 1 DrawHexBorder
    UpRight   1 upperLeftBlack sub DimX 1 DrawHexBorder
    DownRight upperLeftBlack       DimY 1 DrawHexBorder
    DownLeft  1 upperLeftBlack sub DimX 1 DrawHexBorder
end } def

/YBoardPerimeter {
    newpath 1 1 DownRight HxgnCorner moveto 180 rotate
    3 { DimX 1 sub { 300 TurnGo 60 TurnGo } repeat 
        60 TurnGo 60 TurnGo} 
    repeat % now restore initial rotation state
    180 rotate % closepath
} def

/DrawYBoard { 2 dict begin
    YBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimX {/j exch def
        1 1 DimX 1 add j sub {/i exch def
	    i j 1 SemiHexagonPath stroke
        } for } for
end } def

/FontSelect { % bold italic FontSelect
    2 dict begin /italic exch def /bold exch def
    bold {
	italic 
	{ /Times-BoldItalic findfont TextHeight scalefont setfont } 
	{ /Times-Bold findfont TextHeight scalefont setfont }
	ifelse} 
        {
	italic {/Times-Italic findfont TextHeight scalefont setfont} 
	{ /Times findfont TextHeight scalefont setfont }
	ifelse}
    ifelse
end } def
	    
/LabelString {   % call: i j (str) strlen LabelString
%  to use with board rotation, remove comments
    6 dict begin /strlen exch def /str exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint /y exch def /x exch def
    %BoardRotation rotate
    x y moveto 
    %360 BoardRotation sub rotate
    TextWidth strlen mul 0.5 mul neg TextHeight 0.33 mul neg rmoveto
    str show 
end } def

/AbsLabelString { 4 dict begin
    /strlen exch def /str exch def /y exch def /x exch def
    newpath
    x AbsCoordX TextWidth strlen mul 0.5 mul sub
    y AbsCoordY TextHeight 0.33 mul sub
    moveto
    str
    show
end } def

/LabelStringVerb { % i j (str) strlen shade bold italic LabelStringVerb
    7 dict begin /italic exch def /bold exch def /shade exch def
    /strlen exch def /str exch def /j exch def /i exch def
    bold italic FontSelect shade setgray
    i j str strlen LabelString
end } def

/HexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimX { /i exch def
	i 0          Chars i 1 sub get 1 LabelString
	i DimY 1 add Chars i 1 sub get 1 LabelString
    } for
    1 1 DimY { /j exch def
	0 j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
	DimX 1 add j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HavannahBoardCoordinates { 3 dict begin
    false true FontSelect CoordinatesShade setgray
    /Base DimX 1 add 2 idiv  def
    1 1 Base { /i exch def
	i 0 HavannahPosn Chars  i 1 sub get 1 LabelString
	0 i HavannahPosn Digits i 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
    1 1 Base 1 sub { /i exch def
	i Base add i HavannahPosn Chars  i Base add 1 sub get 1 LabelString
	i i Base add HavannahPosn Digits i Base add 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/AltHexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimY { /j exch def
	0 j Chars j 1 sub get 1 LabelString
        %DimX 1 add j Chars j 1 sub get 1 LabelString
    } for
    1 1 DimX { /i exch def
	i 0 Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
	%i DimY 1 add Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HexDot { 3 dict begin /size exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint size 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexWhiteMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexWhitePiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexBlackMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexBlackPiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    1 setgray 0 setlinewidth fill
end } def

/HexDoubleMarker { 6 dict begin
    /shaderight exch def /shadeleft exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    gsave
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    shadeleft setgray 0 setlinewidth fill
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    shaderight setgray 0 setlinewidth fill
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    grestore
end } def

/HexBlackWhiteMarker { 0.0 1.0 HexDoubleMarker } def

/HexWhiteBlackMarker { 1.0 0.0 HexDoubleMarker } def
        
/HexMarker { 2 dict begin /j exch def /i exch def
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setlinewidth fill
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke  
end } def

/HexBlackMarker { 2 dict begin /j exch def /i exch def
    0 setgray
    i j HexMarker
end } def

/HexWhiteMarker { 2 dict begin /j exch def /i exch def
    1 setgray
    i j HexMarker
end } def
    
/HexPiece { 3 dict begin /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/MagicStone { 4 dict begin 
    /size exch def /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 1.3 mul size mul 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/HexWhitePiece { 1.0 HexPiece } def

/HexBlackPiece { 0.0 HexPiece } def

/HexWhiteLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def
    i j HexWhitePiece
    i j str strlen 0.0 true true LabelStringVerb
end } def

/HexBlackLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def 
    i j HexBlackPiece
    i j str strlen 1.0 true true LabelStringVerb
end } def

/AbsCoordX { 1 dict begin /x exch def
    OriginX x Scale mul add
end } def

/AbsCoordY { 1 dict begin /y exch def
    OriginY y Scale mul add
end } def

/DrawBox { /maxy exch def /maxx exch def /miny exch def /minx exch def
    newpath
    minx miny moveto
    maxx minx sub 0 rlineto
    0 maxy miny sub rlineto
    minx maxx sub 0 rlineto
    0 miny maxy sub rlineto
    HexLineWidth setlinewidth
    0 setgray
    stroke
} def

/HexVertex { 2 dict begin /j exch def /i exch def
    i j GraphVertexSize HexDot
end } def

/HexLine { 4 dict begin /j2 exch def /i2 exch def /j1 exch def /i1 exch def
    GraphLineWidth setlinewidth
    0 setgray
    newpath
    i1 j1 HexCenterPoint moveto
    i2 j2 HexCenterPoint lineto
    stroke
end } def

%%---------------- Program -------------------


FlatTopBoard
DrawHexBoard
1 HexBoardBorders


%------------ Trailer --------------

showpage

%%EndDocument
 @endspecial Black Black eop end
%%Page: 14 14
TeXDict begin 14 13 bop Black 181 -165 a Fj(Iv)-5 b(erson)55
b(exam)h(2016)p 1555 -165 4439 6 v 4656 w Fi(14)p Black
Black Black 2103 347 a Fh(this)61 b(page)i(will)e(not)h(b)5
b(e)63 b(graded)563 1515 y @beginspecial 0 @llx 0 @lly
66 @urx 47 @ury 1133 @rwi @setspecial
%%BeginDocument: fz/pix/4x4.eps
%!PS-Adobe-3.0
%%Creator: Jack van Rijswijck, thanks to Cameron Browne
%%BoundingBox: 0 0 66 47
%%Pages: 0
%%EndComments

/OriginX -6 def
/OriginY 36 def
%---------------- Variables -------------------

/DimX 4 def
/DimY 4 def
/Scale 1.2 def


% draw  Hex boards, any size ... but labels only up to 26x26
% based on code by Cameron Browne, revised by Jack vR, revised by RBH
%-------------- state initializations -------------------------
1 setlinejoin   % lines meet at a point  ==>    use round join
%---------------- constants -------------------
/Root3Div2  0.86602540378444 def
/Chars   {[(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)
           (n)(o)(p)(q)(r)(s)(t)(u)(v)(w)(x)(y)(z)]} def
/CharsUC {[(A)(B)(C)(D)(E)(F)(G)(H)(I)(J)(K)(L)(M)
           (N)(O)(P)(Q)(R)(S)(T)(U)(V)(W)(X)(Y)(Z)]} def
/Digits  {[(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)(12)(13)
           (14)(15)(16)(17)(18)(19)(20)(21)(22)(23)(24)(25)(26)]} def
/HexRadius      5 Scale mul def % hexagon center-to-corner distance 
/HexLineWidth 0.1 Scale mul def 
/GraphVertexSize 1.0 Scale mul def
/GraphLineWidth 0.5 Scale mul def
/CircleRadius 3.0 Scale mul def 
/CircleLineWidth 0.346 Scale mul def 
/PerimeterWidth 0.5 Scale mul def 
/TextHeight 4.5 def
/TextWidth TextHeight 0.45 mul def 
/BoardShade 0.8 def
/CoordinatesShade 0.5 def
/MarkerSize 1.2 def
/CellOrientation 1 def   % 1: flat bottom  0: pointed bottom
/CellCorner [ % 6 cell corners, wrt center 0 0, plus "up" and "down"
   [ HexRadius  neg       0                           ] 
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul neg ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul neg ]
   [ HexRadius            0                           ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul     ]
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul neg ]
] def
%----- name cell corner indices ... see below
/Left  0 def /DownLeft 1 def /DownRight 2 def 
/Right 3 def /UpRight  4 def /UpLeft    5 def 
/Up    6 def /Down     7 def
%-----------------------------------------------------
% cell orientations:  flat bottom    flat side
%-----------------------------------------------------
% flat bottom 
% board cell indices            cell corner/top/bottom indices
%             --
%           /    \
%        --   1,3  --                  5 -6- 4
%      /    \    /    \               /       \
%   --   1,2  --   2,3  --           0         3
% /    \    /    \    /    \          \       /
%   1,1  --   2,2  --   3,3            1 -7- 2
% \    /    \    /    \    /
%   --   2,1  --   3,2  --
%      \    /    \    /   
%        --   3,1  --     
%----------------------------------------------------
% flat side 
%    /  \  /  \  /  \                       5
%   | 11 || 12 || 13 ||                   /   6
%    \  /  \  /  \  /  \                 0     4
%     || 21 || 22 || 23 |                |     |
%       \  /  \  /  \  /  \              1     3
%        || 31 || 32 || 33 |              7   /
%-------------------------------------------2--------
%----------- procedures -------------
/ScalePoint { % stack: ... x y size ==> ...  x*size y*size
   3 dict begin /size exch def /y exch def /x exch def
   x size mul           y size mul
end } def

/FlatTopBoard { FlatSideCells } def

/FlatSideCells {  % redefine cell orientation for flat side
  /CellOrientation 0 def   
  /CellCorner [ % 6 cell corners, wrt center 0 0  %xcoord ycoord
    [HexRadius Root3Div2 mul neg  HexRadius 2 div     ]
    [HexRadius Root3Div2 mul neg  HexRadius 2 div neg ]
    [0                            HexRadius neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div ]
    [0                            HexRadius ]
    [HexRadius Root3Div2 2 div mul HexRadius 0.75 mul ]
    [HexRadius Root3Div2 2 div mul neg HexRadius 0.75 mul neg ]
  ] def
} def

/HexCenterPoint { % center of cell (i,j)
    2 dict begin /j exch def /i exch def
    CellOrientation 1 eq {
    OriginX i j add HexRadius mul 1.5 mul add %Ox + (i+j)*HR*1.5
    OriginY i j sub HexRadius mul Root3Div2 mul sub %Oy - (i-j)*HR*R3/2
    }{
    OriginX i 2 j mul add HexRadius mul Root3Div2 mul add  %Ox + (2i+j)*HR
    OriginY i 1 sub HexRadius mul 1.5 mul sub %Oy - i*HR*R3/2
    } ifelse
end } def
 
/HexLine { % a b c d
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint lineto
    stroke
} def

/HexCurve { % a b c d e f
    /f exch def
    /e exch def
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint e f HexCenterPoint HexRadius 2 mul arcto
    e f HexCenterPoint lineto
    stroke
} def

/HxgnCorner { 5 dict begin /corn exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    x CellCorner corn get 0 get add
    y CellCorner corn get 1 get add
end } def

/Go { 2 dict begin /corn exch def /mag exch def
   % rlineto in a cell orientation direction
   CellCorner corn get aload pop mag ScalePoint rlineto
end } def

/TurnGo { rotate 1.0 Left Go } def % call: degrees TurnGo
/MagTurnGo { rotate Left Go } def % call: mag degrees TurnGo

/HexagonPath { % call: i j HexagonPath
    newpath 
    UpRight HxgnCorner moveto 
    6 { 1.0 Left Go 60 rotate } repeat 
} def

/FillAndStroke { 2 dict begin /sh exch def /wdth exch def
    gsave sh setgray fill
    grestore 0 setgray wdth setlinewidth stroke
end } def

/ShadedHexagon { 3 dict begin /shade exch def /j exch def /i exch def
    i j HexagonPath
    0 shade FillAndStroke
end } def

/Hexagon { % stack: ... i j
    HexagonPath 
    HexLineWidth BoardShade FillAndStroke
} def

/SemiHexagonPath { % stack: ... top i j
    newpath 
    1 eq { Left HxgnCorner moveto 
        1.0 UpRight Go 1.0 Right Go 1.0 DownRight Go stroke }{
        Right HxgnCorner moveto 
        1.0 DownLeft Go 1.0 Left Go 1.0 UpLeft Go stroke
    } ifelse
} def

/HexBoardPerimeter {
    newpath
    1 DimY UpRight HxgnCorner moveto 1.0 Left Go                      
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 rotate %restore rotation
} def

%----------- Havannah coordinates ----------------------
%                   ..  ..  ..
%                 d1  c2  b3  a4
%                   c1  b2  a3
%                     b1  a2
%                       a1
/HavannahPosn { % convert to usual coordinate, so ... x y  =>  ... 1+DimX-x  y
    exch DimX 1 add exch sub exch 
} def

/HavannahBoardPerimeter {
    newpath
    1 DimX UpRight HxgnCorner moveto 1.0 Left Go                      
    6 {Base 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo } repeat
} def

/DrawHexBoard { 2 dict begin
    gsave
    HexBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexPLBoard { 6 dict begin %point-line board
    gsave
    BoardShade setgray newpath
    -1 DimY 1 add 0.5 mul HexCenterPoint moveto
    1 DimY HexCenterPoint lineto
    DimX 1 add 0.5 mul DimY 2 add HexCenterPoint lineto
    DimX DimY HexCenterPoint lineto
    DimX 2 add DimY 1 add 0.5 mul HexCenterPoint lineto
    DimX 1 HexCenterPoint lineto
    DimX 1 add 0.5 mul -1 HexCenterPoint lineto
    1 1 HexCenterPoint lineto
    closepath fill 0 setgray
    1 DimY HexCenterPoint moveto
    1 1 DimX { /i exch def 
        i 1 i DimY HexLine 
        DimY 1 add 0.5 mul -1 i 1 HexLine
        DimY 1 add 0.5 mul DimY 2 add i DimY HexLine } for
    1 1 DimY { /j exch def 
        1 j DimX j HexLine 
        -1 DimX 1 add 0.5 mul 1 j HexLine
        DimX 2 add DimX 1 add 0.5 mul DimX j HexLine } for
    /topx 1 def /topy 1 def /btmx 1 def /btmy 1 def
    DimX DimY add 3 sub {
      topx DimX lt {/topx 1 topx add def}{/topy 1 topy add def} ifelse 
      btmy DimY lt {/btmy 1 btmy add def}{/btmx 1 btmx add def} ifelse 
      topx topy btmx btmy HexLine
      } repeat
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j HexVertex
	} for } for
    grestore
end } def

/DrawHavannahBoard { 3 dict begin
    /Base DimX 1 add 2 idiv  def
    gsave
    HavannahBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 Base { /j exch def
	Base j 1 sub sub 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    1 1 Base 1 sub { /j exch def
	1 1 DimX j sub { /i exch def
	   i j Base add 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexBorder{ 6 dict begin /start exch def 
    /cells exch def /isBlack exch def /which exch def
    gsave
    which UpLeft eq {1 DimY 1 add start sub Up HxgnCorner moveto /d Left def /r 60 def} if
    which UpRight eq {start DimY Up HxgnCorner moveto /d Right def /r 300 def} if
    which DownLeft eq {DimX 1 add start sub 1 Down HxgnCorner moveto /d Left def /r 300 def} if
    which DownRight eq {DimX start Down HxgnCorner moveto /d Right def /r 60 def} if
    0.5 d Go 
    which UpRight eq which DownRight eq or {180 rotate} if
    r TurnGo 
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.5 360 r sub MagTurnGo 1.5 360 r sub 2 mul MagTurnGo
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.75 360 r sub MagTurnGo
    closepath isBlack 1 eq {gsave fill grestore} if stroke grestore
end } def

/NoDrawHexBoard {  % dummy, used in creating bounding box
} def

/HexBoardBorders { 1 dict begin
    /upperLeftBlack exch def
    PerimeterWidth setlinewidth 0 setgray
    UpLeft    upperLeftBlack       DimY 1 DrawHexBorder
    UpRight   1 upperLeftBlack sub DimX 1 DrawHexBorder
    DownRight upperLeftBlack       DimY 1 DrawHexBorder
    DownLeft  1 upperLeftBlack sub DimX 1 DrawHexBorder
end } def

/YBoardPerimeter {
    newpath 1 1 DownRight HxgnCorner moveto 180 rotate
    3 { DimX 1 sub { 300 TurnGo 60 TurnGo } repeat 
        60 TurnGo 60 TurnGo} 
    repeat % now restore initial rotation state
    180 rotate % closepath
} def

/DrawYBoard { 2 dict begin
    YBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimX {/j exch def
        1 1 DimX 1 add j sub {/i exch def
	    i j 1 SemiHexagonPath stroke
        } for } for
end } def

/FontSelect { % bold italic FontSelect
    2 dict begin /italic exch def /bold exch def
    bold {
	italic 
	{ /Times-BoldItalic findfont TextHeight scalefont setfont } 
	{ /Times-Bold findfont TextHeight scalefont setfont }
	ifelse} 
        {
	italic {/Times-Italic findfont TextHeight scalefont setfont} 
	{ /Times findfont TextHeight scalefont setfont }
	ifelse}
    ifelse
end } def
	    
/LabelString {   % call: i j (str) strlen LabelString
%  to use with board rotation, remove comments
    6 dict begin /strlen exch def /str exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint /y exch def /x exch def
    %BoardRotation rotate
    x y moveto 
    %360 BoardRotation sub rotate
    TextWidth strlen mul 0.5 mul neg TextHeight 0.33 mul neg rmoveto
    str show 
end } def

/AbsLabelString { 4 dict begin
    /strlen exch def /str exch def /y exch def /x exch def
    newpath
    x AbsCoordX TextWidth strlen mul 0.5 mul sub
    y AbsCoordY TextHeight 0.33 mul sub
    moveto
    str
    show
end } def

/LabelStringVerb { % i j (str) strlen shade bold italic LabelStringVerb
    7 dict begin /italic exch def /bold exch def /shade exch def
    /strlen exch def /str exch def /j exch def /i exch def
    bold italic FontSelect shade setgray
    i j str strlen LabelString
end } def

/HexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimX { /i exch def
	i 0          Chars i 1 sub get 1 LabelString
	i DimY 1 add Chars i 1 sub get 1 LabelString
    } for
    1 1 DimY { /j exch def
	0 j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
	DimX 1 add j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HavannahBoardCoordinates { 3 dict begin
    false true FontSelect CoordinatesShade setgray
    /Base DimX 1 add 2 idiv  def
    1 1 Base { /i exch def
	i 0 HavannahPosn Chars  i 1 sub get 1 LabelString
	0 i HavannahPosn Digits i 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
    1 1 Base 1 sub { /i exch def
	i Base add i HavannahPosn Chars  i Base add 1 sub get 1 LabelString
	i i Base add HavannahPosn Digits i Base add 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/AltHexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimY { /j exch def
	0 j Chars j 1 sub get 1 LabelString
        %DimX 1 add j Chars j 1 sub get 1 LabelString
    } for
    1 1 DimX { /i exch def
	i 0 Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
	%i DimY 1 add Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HexDot { 3 dict begin /size exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint size 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexWhiteMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexWhitePiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexBlackMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexBlackPiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    1 setgray 0 setlinewidth fill
end } def

/HexDoubleMarker { 6 dict begin
    /shaderight exch def /shadeleft exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    gsave
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    shadeleft setgray 0 setlinewidth fill
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    shaderight setgray 0 setlinewidth fill
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    grestore
end } def

/HexBlackWhiteMarker { 0.0 1.0 HexDoubleMarker } def

/HexWhiteBlackMarker { 1.0 0.0 HexDoubleMarker } def
        
/HexMarker { 2 dict begin /j exch def /i exch def
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setlinewidth fill
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke  
end } def

/HexBlackMarker { 2 dict begin /j exch def /i exch def
    0 setgray
    i j HexMarker
end } def

/HexWhiteMarker { 2 dict begin /j exch def /i exch def
    1 setgray
    i j HexMarker
end } def
    
/HexPiece { 3 dict begin /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/MagicStone { 4 dict begin 
    /size exch def /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 1.3 mul size mul 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/HexWhitePiece { 1.0 HexPiece } def

/HexBlackPiece { 0.0 HexPiece } def

/HexWhiteLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def
    i j HexWhitePiece
    i j str strlen 0.0 true true LabelStringVerb
end } def

/HexBlackLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def 
    i j HexBlackPiece
    i j str strlen 1.0 true true LabelStringVerb
end } def

/AbsCoordX { 1 dict begin /x exch def
    OriginX x Scale mul add
end } def

/AbsCoordY { 1 dict begin /y exch def
    OriginY y Scale mul add
end } def

/DrawBox { /maxy exch def /maxx exch def /miny exch def /minx exch def
    newpath
    minx miny moveto
    maxx minx sub 0 rlineto
    0 maxy miny sub rlineto
    minx maxx sub 0 rlineto
    0 miny maxy sub rlineto
    HexLineWidth setlinewidth
    0 setgray
    stroke
} def

/HexVertex { 2 dict begin /j exch def /i exch def
    i j GraphVertexSize HexDot
end } def

/HexLine { 4 dict begin /j2 exch def /i2 exch def /j1 exch def /i1 exch def
    GraphLineWidth setlinewidth
    0 setgray
    newpath
    i1 j1 HexCenterPoint moveto
    i2 j2 HexCenterPoint lineto
    stroke
end } def

%%---------------- Program -------------------


FlatTopBoard
DrawHexBoard
1 HexBoardBorders


%------------ Trailer --------------

showpage

%%EndDocument
 @endspecial 1900 w @beginspecial 0 @llx 0 @lly 66 @urx
47 @ury 1133 @rwi @setspecial
%%BeginDocument: fz/pix/4x4.eps
%!PS-Adobe-3.0
%%Creator: Jack van Rijswijck, thanks to Cameron Browne
%%BoundingBox: 0 0 66 47
%%Pages: 0
%%EndComments

/OriginX -6 def
/OriginY 36 def
%---------------- Variables -------------------

/DimX 4 def
/DimY 4 def
/Scale 1.2 def


% draw  Hex boards, any size ... but labels only up to 26x26
% based on code by Cameron Browne, revised by Jack vR, revised by RBH
%-------------- state initializations -------------------------
1 setlinejoin   % lines meet at a point  ==>    use round join
%---------------- constants -------------------
/Root3Div2  0.86602540378444 def
/Chars   {[(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)
           (n)(o)(p)(q)(r)(s)(t)(u)(v)(w)(x)(y)(z)]} def
/CharsUC {[(A)(B)(C)(D)(E)(F)(G)(H)(I)(J)(K)(L)(M)
           (N)(O)(P)(Q)(R)(S)(T)(U)(V)(W)(X)(Y)(Z)]} def
/Digits  {[(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)(12)(13)
           (14)(15)(16)(17)(18)(19)(20)(21)(22)(23)(24)(25)(26)]} def
/HexRadius      5 Scale mul def % hexagon center-to-corner distance 
/HexLineWidth 0.1 Scale mul def 
/GraphVertexSize 1.0 Scale mul def
/GraphLineWidth 0.5 Scale mul def
/CircleRadius 3.0 Scale mul def 
/CircleLineWidth 0.346 Scale mul def 
/PerimeterWidth 0.5 Scale mul def 
/TextHeight 4.5 def
/TextWidth TextHeight 0.45 mul def 
/BoardShade 0.8 def
/CoordinatesShade 0.5 def
/MarkerSize 1.2 def
/CellOrientation 1 def   % 1: flat bottom  0: pointed bottom
/CellCorner [ % 6 cell corners, wrt center 0 0, plus "up" and "down"
   [ HexRadius  neg       0                           ] 
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul neg ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul neg ]
   [ HexRadius            0                           ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul     ]
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul neg ]
] def
%----- name cell corner indices ... see below
/Left  0 def /DownLeft 1 def /DownRight 2 def 
/Right 3 def /UpRight  4 def /UpLeft    5 def 
/Up    6 def /Down     7 def
%-----------------------------------------------------
% cell orientations:  flat bottom    flat side
%-----------------------------------------------------
% flat bottom 
% board cell indices            cell corner/top/bottom indices
%             --
%           /    \
%        --   1,3  --                  5 -6- 4
%      /    \    /    \               /       \
%   --   1,2  --   2,3  --           0         3
% /    \    /    \    /    \          \       /
%   1,1  --   2,2  --   3,3            1 -7- 2
% \    /    \    /    \    /
%   --   2,1  --   3,2  --
%      \    /    \    /   
%        --   3,1  --     
%----------------------------------------------------
% flat side 
%    /  \  /  \  /  \                       5
%   | 11 || 12 || 13 ||                   /   6
%    \  /  \  /  \  /  \                 0     4
%     || 21 || 22 || 23 |                |     |
%       \  /  \  /  \  /  \              1     3
%        || 31 || 32 || 33 |              7   /
%-------------------------------------------2--------
%----------- procedures -------------
/ScalePoint { % stack: ... x y size ==> ...  x*size y*size
   3 dict begin /size exch def /y exch def /x exch def
   x size mul           y size mul
end } def

/FlatTopBoard { FlatSideCells } def

/FlatSideCells {  % redefine cell orientation for flat side
  /CellOrientation 0 def   
  /CellCorner [ % 6 cell corners, wrt center 0 0  %xcoord ycoord
    [HexRadius Root3Div2 mul neg  HexRadius 2 div     ]
    [HexRadius Root3Div2 mul neg  HexRadius 2 div neg ]
    [0                            HexRadius neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div ]
    [0                            HexRadius ]
    [HexRadius Root3Div2 2 div mul HexRadius 0.75 mul ]
    [HexRadius Root3Div2 2 div mul neg HexRadius 0.75 mul neg ]
  ] def
} def

/HexCenterPoint { % center of cell (i,j)
    2 dict begin /j exch def /i exch def
    CellOrientation 1 eq {
    OriginX i j add HexRadius mul 1.5 mul add %Ox + (i+j)*HR*1.5
    OriginY i j sub HexRadius mul Root3Div2 mul sub %Oy - (i-j)*HR*R3/2
    }{
    OriginX i 2 j mul add HexRadius mul Root3Div2 mul add  %Ox + (2i+j)*HR
    OriginY i 1 sub HexRadius mul 1.5 mul sub %Oy - i*HR*R3/2
    } ifelse
end } def
 
/HexLine { % a b c d
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint lineto
    stroke
} def

/HexCurve { % a b c d e f
    /f exch def
    /e exch def
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint e f HexCenterPoint HexRadius 2 mul arcto
    e f HexCenterPoint lineto
    stroke
} def

/HxgnCorner { 5 dict begin /corn exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    x CellCorner corn get 0 get add
    y CellCorner corn get 1 get add
end } def

/Go { 2 dict begin /corn exch def /mag exch def
   % rlineto in a cell orientation direction
   CellCorner corn get aload pop mag ScalePoint rlineto
end } def

/TurnGo { rotate 1.0 Left Go } def % call: degrees TurnGo
/MagTurnGo { rotate Left Go } def % call: mag degrees TurnGo

/HexagonPath { % call: i j HexagonPath
    newpath 
    UpRight HxgnCorner moveto 
    6 { 1.0 Left Go 60 rotate } repeat 
} def

/FillAndStroke { 2 dict begin /sh exch def /wdth exch def
    gsave sh setgray fill
    grestore 0 setgray wdth setlinewidth stroke
end } def

/ShadedHexagon { 3 dict begin /shade exch def /j exch def /i exch def
    i j HexagonPath
    0 shade FillAndStroke
end } def

/Hexagon { % stack: ... i j
    HexagonPath 
    HexLineWidth BoardShade FillAndStroke
} def

/SemiHexagonPath { % stack: ... top i j
    newpath 
    1 eq { Left HxgnCorner moveto 
        1.0 UpRight Go 1.0 Right Go 1.0 DownRight Go stroke }{
        Right HxgnCorner moveto 
        1.0 DownLeft Go 1.0 Left Go 1.0 UpLeft Go stroke
    } ifelse
} def

/HexBoardPerimeter {
    newpath
    1 DimY UpRight HxgnCorner moveto 1.0 Left Go                      
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 rotate %restore rotation
} def

%----------- Havannah coordinates ----------------------
%                   ..  ..  ..
%                 d1  c2  b3  a4
%                   c1  b2  a3
%                     b1  a2
%                       a1
/HavannahPosn { % convert to usual coordinate, so ... x y  =>  ... 1+DimX-x  y
    exch DimX 1 add exch sub exch 
} def

/HavannahBoardPerimeter {
    newpath
    1 DimX UpRight HxgnCorner moveto 1.0 Left Go                      
    6 {Base 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo } repeat
} def

/DrawHexBoard { 2 dict begin
    gsave
    HexBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexPLBoard { 6 dict begin %point-line board
    gsave
    BoardShade setgray newpath
    -1 DimY 1 add 0.5 mul HexCenterPoint moveto
    1 DimY HexCenterPoint lineto
    DimX 1 add 0.5 mul DimY 2 add HexCenterPoint lineto
    DimX DimY HexCenterPoint lineto
    DimX 2 add DimY 1 add 0.5 mul HexCenterPoint lineto
    DimX 1 HexCenterPoint lineto
    DimX 1 add 0.5 mul -1 HexCenterPoint lineto
    1 1 HexCenterPoint lineto
    closepath fill 0 setgray
    1 DimY HexCenterPoint moveto
    1 1 DimX { /i exch def 
        i 1 i DimY HexLine 
        DimY 1 add 0.5 mul -1 i 1 HexLine
        DimY 1 add 0.5 mul DimY 2 add i DimY HexLine } for
    1 1 DimY { /j exch def 
        1 j DimX j HexLine 
        -1 DimX 1 add 0.5 mul 1 j HexLine
        DimX 2 add DimX 1 add 0.5 mul DimX j HexLine } for
    /topx 1 def /topy 1 def /btmx 1 def /btmy 1 def
    DimX DimY add 3 sub {
      topx DimX lt {/topx 1 topx add def}{/topy 1 topy add def} ifelse 
      btmy DimY lt {/btmy 1 btmy add def}{/btmx 1 btmx add def} ifelse 
      topx topy btmx btmy HexLine
      } repeat
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j HexVertex
	} for } for
    grestore
end } def

/DrawHavannahBoard { 3 dict begin
    /Base DimX 1 add 2 idiv  def
    gsave
    HavannahBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 Base { /j exch def
	Base j 1 sub sub 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    1 1 Base 1 sub { /j exch def
	1 1 DimX j sub { /i exch def
	   i j Base add 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexBorder{ 6 dict begin /start exch def 
    /cells exch def /isBlack exch def /which exch def
    gsave
    which UpLeft eq {1 DimY 1 add start sub Up HxgnCorner moveto /d Left def /r 60 def} if
    which UpRight eq {start DimY Up HxgnCorner moveto /d Right def /r 300 def} if
    which DownLeft eq {DimX 1 add start sub 1 Down HxgnCorner moveto /d Left def /r 300 def} if
    which DownRight eq {DimX start Down HxgnCorner moveto /d Right def /r 60 def} if
    0.5 d Go 
    which UpRight eq which DownRight eq or {180 rotate} if
    r TurnGo 
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.5 360 r sub MagTurnGo 1.5 360 r sub 2 mul MagTurnGo
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.75 360 r sub MagTurnGo
    closepath isBlack 1 eq {gsave fill grestore} if stroke grestore
end } def

/NoDrawHexBoard {  % dummy, used in creating bounding box
} def

/HexBoardBorders { 1 dict begin
    /upperLeftBlack exch def
    PerimeterWidth setlinewidth 0 setgray
    UpLeft    upperLeftBlack       DimY 1 DrawHexBorder
    UpRight   1 upperLeftBlack sub DimX 1 DrawHexBorder
    DownRight upperLeftBlack       DimY 1 DrawHexBorder
    DownLeft  1 upperLeftBlack sub DimX 1 DrawHexBorder
end } def

/YBoardPerimeter {
    newpath 1 1 DownRight HxgnCorner moveto 180 rotate
    3 { DimX 1 sub { 300 TurnGo 60 TurnGo } repeat 
        60 TurnGo 60 TurnGo} 
    repeat % now restore initial rotation state
    180 rotate % closepath
} def

/DrawYBoard { 2 dict begin
    YBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimX {/j exch def
        1 1 DimX 1 add j sub {/i exch def
	    i j 1 SemiHexagonPath stroke
        } for } for
end } def

/FontSelect { % bold italic FontSelect
    2 dict begin /italic exch def /bold exch def
    bold {
	italic 
	{ /Times-BoldItalic findfont TextHeight scalefont setfont } 
	{ /Times-Bold findfont TextHeight scalefont setfont }
	ifelse} 
        {
	italic {/Times-Italic findfont TextHeight scalefont setfont} 
	{ /Times findfont TextHeight scalefont setfont }
	ifelse}
    ifelse
end } def
	    
/LabelString {   % call: i j (str) strlen LabelString
%  to use with board rotation, remove comments
    6 dict begin /strlen exch def /str exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint /y exch def /x exch def
    %BoardRotation rotate
    x y moveto 
    %360 BoardRotation sub rotate
    TextWidth strlen mul 0.5 mul neg TextHeight 0.33 mul neg rmoveto
    str show 
end } def

/AbsLabelString { 4 dict begin
    /strlen exch def /str exch def /y exch def /x exch def
    newpath
    x AbsCoordX TextWidth strlen mul 0.5 mul sub
    y AbsCoordY TextHeight 0.33 mul sub
    moveto
    str
    show
end } def

/LabelStringVerb { % i j (str) strlen shade bold italic LabelStringVerb
    7 dict begin /italic exch def /bold exch def /shade exch def
    /strlen exch def /str exch def /j exch def /i exch def
    bold italic FontSelect shade setgray
    i j str strlen LabelString
end } def

/HexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimX { /i exch def
	i 0          Chars i 1 sub get 1 LabelString
	i DimY 1 add Chars i 1 sub get 1 LabelString
    } for
    1 1 DimY { /j exch def
	0 j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
	DimX 1 add j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HavannahBoardCoordinates { 3 dict begin
    false true FontSelect CoordinatesShade setgray
    /Base DimX 1 add 2 idiv  def
    1 1 Base { /i exch def
	i 0 HavannahPosn Chars  i 1 sub get 1 LabelString
	0 i HavannahPosn Digits i 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
    1 1 Base 1 sub { /i exch def
	i Base add i HavannahPosn Chars  i Base add 1 sub get 1 LabelString
	i i Base add HavannahPosn Digits i Base add 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/AltHexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimY { /j exch def
	0 j Chars j 1 sub get 1 LabelString
        %DimX 1 add j Chars j 1 sub get 1 LabelString
    } for
    1 1 DimX { /i exch def
	i 0 Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
	%i DimY 1 add Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HexDot { 3 dict begin /size exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint size 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexWhiteMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexWhitePiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexBlackMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexBlackPiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    1 setgray 0 setlinewidth fill
end } def

/HexDoubleMarker { 6 dict begin
    /shaderight exch def /shadeleft exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    gsave
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    shadeleft setgray 0 setlinewidth fill
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    shaderight setgray 0 setlinewidth fill
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    grestore
end } def

/HexBlackWhiteMarker { 0.0 1.0 HexDoubleMarker } def

/HexWhiteBlackMarker { 1.0 0.0 HexDoubleMarker } def
        
/HexMarker { 2 dict begin /j exch def /i exch def
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setlinewidth fill
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke  
end } def

/HexBlackMarker { 2 dict begin /j exch def /i exch def
    0 setgray
    i j HexMarker
end } def

/HexWhiteMarker { 2 dict begin /j exch def /i exch def
    1 setgray
    i j HexMarker
end } def
    
/HexPiece { 3 dict begin /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/MagicStone { 4 dict begin 
    /size exch def /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 1.3 mul size mul 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/HexWhitePiece { 1.0 HexPiece } def

/HexBlackPiece { 0.0 HexPiece } def

/HexWhiteLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def
    i j HexWhitePiece
    i j str strlen 0.0 true true LabelStringVerb
end } def

/HexBlackLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def 
    i j HexBlackPiece
    i j str strlen 1.0 true true LabelStringVerb
end } def

/AbsCoordX { 1 dict begin /x exch def
    OriginX x Scale mul add
end } def

/AbsCoordY { 1 dict begin /y exch def
    OriginY y Scale mul add
end } def

/DrawBox { /maxy exch def /maxx exch def /miny exch def /minx exch def
    newpath
    minx miny moveto
    maxx minx sub 0 rlineto
    0 maxy miny sub rlineto
    minx maxx sub 0 rlineto
    0 miny maxy sub rlineto
    HexLineWidth setlinewidth
    0 setgray
    stroke
} def

/HexVertex { 2 dict begin /j exch def /i exch def
    i j GraphVertexSize HexDot
end } def

/HexLine { 4 dict begin /j2 exch def /i2 exch def /j1 exch def /i1 exch def
    GraphLineWidth setlinewidth
    0 setgray
    newpath
    i1 j1 HexCenterPoint moveto
    i2 j2 HexCenterPoint lineto
    stroke
end } def

%%---------------- Program -------------------


FlatTopBoard
DrawHexBoard
1 HexBoardBorders


%------------ Trailer --------------

showpage

%%EndDocument
 @endspecial 1900 w @beginspecial 0 @llx 0 @lly 66 @urx
47 @ury 1133 @rwi @setspecial
%%BeginDocument: fz/pix/4x4.eps
%!PS-Adobe-3.0
%%Creator: Jack van Rijswijck, thanks to Cameron Browne
%%BoundingBox: 0 0 66 47
%%Pages: 0
%%EndComments

/OriginX -6 def
/OriginY 36 def
%---------------- Variables -------------------

/DimX 4 def
/DimY 4 def
/Scale 1.2 def


% draw  Hex boards, any size ... but labels only up to 26x26
% based on code by Cameron Browne, revised by Jack vR, revised by RBH
%-------------- state initializations -------------------------
1 setlinejoin   % lines meet at a point  ==>    use round join
%---------------- constants -------------------
/Root3Div2  0.86602540378444 def
/Chars   {[(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)
           (n)(o)(p)(q)(r)(s)(t)(u)(v)(w)(x)(y)(z)]} def
/CharsUC {[(A)(B)(C)(D)(E)(F)(G)(H)(I)(J)(K)(L)(M)
           (N)(O)(P)(Q)(R)(S)(T)(U)(V)(W)(X)(Y)(Z)]} def
/Digits  {[(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)(12)(13)
           (14)(15)(16)(17)(18)(19)(20)(21)(22)(23)(24)(25)(26)]} def
/HexRadius      5 Scale mul def % hexagon center-to-corner distance 
/HexLineWidth 0.1 Scale mul def 
/GraphVertexSize 1.0 Scale mul def
/GraphLineWidth 0.5 Scale mul def
/CircleRadius 3.0 Scale mul def 
/CircleLineWidth 0.346 Scale mul def 
/PerimeterWidth 0.5 Scale mul def 
/TextHeight 4.5 def
/TextWidth TextHeight 0.45 mul def 
/BoardShade 0.8 def
/CoordinatesShade 0.5 def
/MarkerSize 1.2 def
/CellOrientation 1 def   % 1: flat bottom  0: pointed bottom
/CellCorner [ % 6 cell corners, wrt center 0 0, plus "up" and "down"
   [ HexRadius  neg       0                           ] 
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul neg ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul neg ]
   [ HexRadius            0                           ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul     ]
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul neg ]
] def
%----- name cell corner indices ... see below
/Left  0 def /DownLeft 1 def /DownRight 2 def 
/Right 3 def /UpRight  4 def /UpLeft    5 def 
/Up    6 def /Down     7 def
%-----------------------------------------------------
% cell orientations:  flat bottom    flat side
%-----------------------------------------------------
% flat bottom 
% board cell indices            cell corner/top/bottom indices
%             --
%           /    \
%        --   1,3  --                  5 -6- 4
%      /    \    /    \               /       \
%   --   1,2  --   2,3  --           0         3
% /    \    /    \    /    \          \       /
%   1,1  --   2,2  --   3,3            1 -7- 2
% \    /    \    /    \    /
%   --   2,1  --   3,2  --
%      \    /    \    /   
%        --   3,1  --     
%----------------------------------------------------
% flat side 
%    /  \  /  \  /  \                       5
%   | 11 || 12 || 13 ||                   /   6
%    \  /  \  /  \  /  \                 0     4
%     || 21 || 22 || 23 |                |     |
%       \  /  \  /  \  /  \              1     3
%        || 31 || 32 || 33 |              7   /
%-------------------------------------------2--------
%----------- procedures -------------
/ScalePoint { % stack: ... x y size ==> ...  x*size y*size
   3 dict begin /size exch def /y exch def /x exch def
   x size mul           y size mul
end } def

/FlatTopBoard { FlatSideCells } def

/FlatSideCells {  % redefine cell orientation for flat side
  /CellOrientation 0 def   
  /CellCorner [ % 6 cell corners, wrt center 0 0  %xcoord ycoord
    [HexRadius Root3Div2 mul neg  HexRadius 2 div     ]
    [HexRadius Root3Div2 mul neg  HexRadius 2 div neg ]
    [0                            HexRadius neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div ]
    [0                            HexRadius ]
    [HexRadius Root3Div2 2 div mul HexRadius 0.75 mul ]
    [HexRadius Root3Div2 2 div mul neg HexRadius 0.75 mul neg ]
  ] def
} def

/HexCenterPoint { % center of cell (i,j)
    2 dict begin /j exch def /i exch def
    CellOrientation 1 eq {
    OriginX i j add HexRadius mul 1.5 mul add %Ox + (i+j)*HR*1.5
    OriginY i j sub HexRadius mul Root3Div2 mul sub %Oy - (i-j)*HR*R3/2
    }{
    OriginX i 2 j mul add HexRadius mul Root3Div2 mul add  %Ox + (2i+j)*HR
    OriginY i 1 sub HexRadius mul 1.5 mul sub %Oy - i*HR*R3/2
    } ifelse
end } def
 
/HexLine { % a b c d
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint lineto
    stroke
} def

/HexCurve { % a b c d e f
    /f exch def
    /e exch def
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint e f HexCenterPoint HexRadius 2 mul arcto
    e f HexCenterPoint lineto
    stroke
} def

/HxgnCorner { 5 dict begin /corn exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    x CellCorner corn get 0 get add
    y CellCorner corn get 1 get add
end } def

/Go { 2 dict begin /corn exch def /mag exch def
   % rlineto in a cell orientation direction
   CellCorner corn get aload pop mag ScalePoint rlineto
end } def

/TurnGo { rotate 1.0 Left Go } def % call: degrees TurnGo
/MagTurnGo { rotate Left Go } def % call: mag degrees TurnGo

/HexagonPath { % call: i j HexagonPath
    newpath 
    UpRight HxgnCorner moveto 
    6 { 1.0 Left Go 60 rotate } repeat 
} def

/FillAndStroke { 2 dict begin /sh exch def /wdth exch def
    gsave sh setgray fill
    grestore 0 setgray wdth setlinewidth stroke
end } def

/ShadedHexagon { 3 dict begin /shade exch def /j exch def /i exch def
    i j HexagonPath
    0 shade FillAndStroke
end } def

/Hexagon { % stack: ... i j
    HexagonPath 
    HexLineWidth BoardShade FillAndStroke
} def

/SemiHexagonPath { % stack: ... top i j
    newpath 
    1 eq { Left HxgnCorner moveto 
        1.0 UpRight Go 1.0 Right Go 1.0 DownRight Go stroke }{
        Right HxgnCorner moveto 
        1.0 DownLeft Go 1.0 Left Go 1.0 UpLeft Go stroke
    } ifelse
} def

/HexBoardPerimeter {
    newpath
    1 DimY UpRight HxgnCorner moveto 1.0 Left Go                      
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 rotate %restore rotation
} def

%----------- Havannah coordinates ----------------------
%                   ..  ..  ..
%                 d1  c2  b3  a4
%                   c1  b2  a3
%                     b1  a2
%                       a1
/HavannahPosn { % convert to usual coordinate, so ... x y  =>  ... 1+DimX-x  y
    exch DimX 1 add exch sub exch 
} def

/HavannahBoardPerimeter {
    newpath
    1 DimX UpRight HxgnCorner moveto 1.0 Left Go                      
    6 {Base 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo } repeat
} def

/DrawHexBoard { 2 dict begin
    gsave
    HexBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexPLBoard { 6 dict begin %point-line board
    gsave
    BoardShade setgray newpath
    -1 DimY 1 add 0.5 mul HexCenterPoint moveto
    1 DimY HexCenterPoint lineto
    DimX 1 add 0.5 mul DimY 2 add HexCenterPoint lineto
    DimX DimY HexCenterPoint lineto
    DimX 2 add DimY 1 add 0.5 mul HexCenterPoint lineto
    DimX 1 HexCenterPoint lineto
    DimX 1 add 0.5 mul -1 HexCenterPoint lineto
    1 1 HexCenterPoint lineto
    closepath fill 0 setgray
    1 DimY HexCenterPoint moveto
    1 1 DimX { /i exch def 
        i 1 i DimY HexLine 
        DimY 1 add 0.5 mul -1 i 1 HexLine
        DimY 1 add 0.5 mul DimY 2 add i DimY HexLine } for
    1 1 DimY { /j exch def 
        1 j DimX j HexLine 
        -1 DimX 1 add 0.5 mul 1 j HexLine
        DimX 2 add DimX 1 add 0.5 mul DimX j HexLine } for
    /topx 1 def /topy 1 def /btmx 1 def /btmy 1 def
    DimX DimY add 3 sub {
      topx DimX lt {/topx 1 topx add def}{/topy 1 topy add def} ifelse 
      btmy DimY lt {/btmy 1 btmy add def}{/btmx 1 btmx add def} ifelse 
      topx topy btmx btmy HexLine
      } repeat
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j HexVertex
	} for } for
    grestore
end } def

/DrawHavannahBoard { 3 dict begin
    /Base DimX 1 add 2 idiv  def
    gsave
    HavannahBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 Base { /j exch def
	Base j 1 sub sub 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    1 1 Base 1 sub { /j exch def
	1 1 DimX j sub { /i exch def
	   i j Base add 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexBorder{ 6 dict begin /start exch def 
    /cells exch def /isBlack exch def /which exch def
    gsave
    which UpLeft eq {1 DimY 1 add start sub Up HxgnCorner moveto /d Left def /r 60 def} if
    which UpRight eq {start DimY Up HxgnCorner moveto /d Right def /r 300 def} if
    which DownLeft eq {DimX 1 add start sub 1 Down HxgnCorner moveto /d Left def /r 300 def} if
    which DownRight eq {DimX start Down HxgnCorner moveto /d Right def /r 60 def} if
    0.5 d Go 
    which UpRight eq which DownRight eq or {180 rotate} if
    r TurnGo 
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.5 360 r sub MagTurnGo 1.5 360 r sub 2 mul MagTurnGo
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.75 360 r sub MagTurnGo
    closepath isBlack 1 eq {gsave fill grestore} if stroke grestore
end } def

/NoDrawHexBoard {  % dummy, used in creating bounding box
} def

/HexBoardBorders { 1 dict begin
    /upperLeftBlack exch def
    PerimeterWidth setlinewidth 0 setgray
    UpLeft    upperLeftBlack       DimY 1 DrawHexBorder
    UpRight   1 upperLeftBlack sub DimX 1 DrawHexBorder
    DownRight upperLeftBlack       DimY 1 DrawHexBorder
    DownLeft  1 upperLeftBlack sub DimX 1 DrawHexBorder
end } def

/YBoardPerimeter {
    newpath 1 1 DownRight HxgnCorner moveto 180 rotate
    3 { DimX 1 sub { 300 TurnGo 60 TurnGo } repeat 
        60 TurnGo 60 TurnGo} 
    repeat % now restore initial rotation state
    180 rotate % closepath
} def

/DrawYBoard { 2 dict begin
    YBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimX {/j exch def
        1 1 DimX 1 add j sub {/i exch def
	    i j 1 SemiHexagonPath stroke
        } for } for
end } def

/FontSelect { % bold italic FontSelect
    2 dict begin /italic exch def /bold exch def
    bold {
	italic 
	{ /Times-BoldItalic findfont TextHeight scalefont setfont } 
	{ /Times-Bold findfont TextHeight scalefont setfont }
	ifelse} 
        {
	italic {/Times-Italic findfont TextHeight scalefont setfont} 
	{ /Times findfont TextHeight scalefont setfont }
	ifelse}
    ifelse
end } def
	    
/LabelString {   % call: i j (str) strlen LabelString
%  to use with board rotation, remove comments
    6 dict begin /strlen exch def /str exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint /y exch def /x exch def
    %BoardRotation rotate
    x y moveto 
    %360 BoardRotation sub rotate
    TextWidth strlen mul 0.5 mul neg TextHeight 0.33 mul neg rmoveto
    str show 
end } def

/AbsLabelString { 4 dict begin
    /strlen exch def /str exch def /y exch def /x exch def
    newpath
    x AbsCoordX TextWidth strlen mul 0.5 mul sub
    y AbsCoordY TextHeight 0.33 mul sub
    moveto
    str
    show
end } def

/LabelStringVerb { % i j (str) strlen shade bold italic LabelStringVerb
    7 dict begin /italic exch def /bold exch def /shade exch def
    /strlen exch def /str exch def /j exch def /i exch def
    bold italic FontSelect shade setgray
    i j str strlen LabelString
end } def

/HexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimX { /i exch def
	i 0          Chars i 1 sub get 1 LabelString
	i DimY 1 add Chars i 1 sub get 1 LabelString
    } for
    1 1 DimY { /j exch def
	0 j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
	DimX 1 add j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HavannahBoardCoordinates { 3 dict begin
    false true FontSelect CoordinatesShade setgray
    /Base DimX 1 add 2 idiv  def
    1 1 Base { /i exch def
	i 0 HavannahPosn Chars  i 1 sub get 1 LabelString
	0 i HavannahPosn Digits i 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
    1 1 Base 1 sub { /i exch def
	i Base add i HavannahPosn Chars  i Base add 1 sub get 1 LabelString
	i i Base add HavannahPosn Digits i Base add 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/AltHexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimY { /j exch def
	0 j Chars j 1 sub get 1 LabelString
        %DimX 1 add j Chars j 1 sub get 1 LabelString
    } for
    1 1 DimX { /i exch def
	i 0 Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
	%i DimY 1 add Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HexDot { 3 dict begin /size exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint size 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexWhiteMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexWhitePiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexBlackMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexBlackPiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    1 setgray 0 setlinewidth fill
end } def

/HexDoubleMarker { 6 dict begin
    /shaderight exch def /shadeleft exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    gsave
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    shadeleft setgray 0 setlinewidth fill
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    shaderight setgray 0 setlinewidth fill
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    grestore
end } def

/HexBlackWhiteMarker { 0.0 1.0 HexDoubleMarker } def

/HexWhiteBlackMarker { 1.0 0.0 HexDoubleMarker } def
        
/HexMarker { 2 dict begin /j exch def /i exch def
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setlinewidth fill
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke  
end } def

/HexBlackMarker { 2 dict begin /j exch def /i exch def
    0 setgray
    i j HexMarker
end } def

/HexWhiteMarker { 2 dict begin /j exch def /i exch def
    1 setgray
    i j HexMarker
end } def
    
/HexPiece { 3 dict begin /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/MagicStone { 4 dict begin 
    /size exch def /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 1.3 mul size mul 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/HexWhitePiece { 1.0 HexPiece } def

/HexBlackPiece { 0.0 HexPiece } def

/HexWhiteLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def
    i j HexWhitePiece
    i j str strlen 0.0 true true LabelStringVerb
end } def

/HexBlackLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def 
    i j HexBlackPiece
    i j str strlen 1.0 true true LabelStringVerb
end } def

/AbsCoordX { 1 dict begin /x exch def
    OriginX x Scale mul add
end } def

/AbsCoordY { 1 dict begin /y exch def
    OriginY y Scale mul add
end } def

/DrawBox { /maxy exch def /maxx exch def /miny exch def /minx exch def
    newpath
    minx miny moveto
    maxx minx sub 0 rlineto
    0 maxy miny sub rlineto
    minx maxx sub 0 rlineto
    0 miny maxy sub rlineto
    HexLineWidth setlinewidth
    0 setgray
    stroke
} def

/HexVertex { 2 dict begin /j exch def /i exch def
    i j GraphVertexSize HexDot
end } def

/HexLine { 4 dict begin /j2 exch def /i2 exch def /j1 exch def /i1 exch def
    GraphLineWidth setlinewidth
    0 setgray
    newpath
    i1 j1 HexCenterPoint moveto
    i2 j2 HexCenterPoint lineto
    stroke
end } def

%%---------------- Program -------------------


FlatTopBoard
DrawHexBoard
1 HexBoardBorders


%------------ Trailer --------------

showpage

%%EndDocument
 @endspecial 563 3097 a @beginspecial 0 @llx 0 @lly 66
@urx 47 @ury 1133 @rwi @setspecial
%%BeginDocument: fz/pix/4x4.eps
%!PS-Adobe-3.0
%%Creator: Jack van Rijswijck, thanks to Cameron Browne
%%BoundingBox: 0 0 66 47
%%Pages: 0
%%EndComments

/OriginX -6 def
/OriginY 36 def
%---------------- Variables -------------------

/DimX 4 def
/DimY 4 def
/Scale 1.2 def


% draw  Hex boards, any size ... but labels only up to 26x26
% based on code by Cameron Browne, revised by Jack vR, revised by RBH
%-------------- state initializations -------------------------
1 setlinejoin   % lines meet at a point  ==>    use round join
%---------------- constants -------------------
/Root3Div2  0.86602540378444 def
/Chars   {[(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)
           (n)(o)(p)(q)(r)(s)(t)(u)(v)(w)(x)(y)(z)]} def
/CharsUC {[(A)(B)(C)(D)(E)(F)(G)(H)(I)(J)(K)(L)(M)
           (N)(O)(P)(Q)(R)(S)(T)(U)(V)(W)(X)(Y)(Z)]} def
/Digits  {[(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)(12)(13)
           (14)(15)(16)(17)(18)(19)(20)(21)(22)(23)(24)(25)(26)]} def
/HexRadius      5 Scale mul def % hexagon center-to-corner distance 
/HexLineWidth 0.1 Scale mul def 
/GraphVertexSize 1.0 Scale mul def
/GraphLineWidth 0.5 Scale mul def
/CircleRadius 3.0 Scale mul def 
/CircleLineWidth 0.346 Scale mul def 
/PerimeterWidth 0.5 Scale mul def 
/TextHeight 4.5 def
/TextWidth TextHeight 0.45 mul def 
/BoardShade 0.8 def
/CoordinatesShade 0.5 def
/MarkerSize 1.2 def
/CellOrientation 1 def   % 1: flat bottom  0: pointed bottom
/CellCorner [ % 6 cell corners, wrt center 0 0, plus "up" and "down"
   [ HexRadius  neg       0                           ] 
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul neg ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul neg ]
   [ HexRadius            0                           ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul     ]
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul neg ]
] def
%----- name cell corner indices ... see below
/Left  0 def /DownLeft 1 def /DownRight 2 def 
/Right 3 def /UpRight  4 def /UpLeft    5 def 
/Up    6 def /Down     7 def
%-----------------------------------------------------
% cell orientations:  flat bottom    flat side
%-----------------------------------------------------
% flat bottom 
% board cell indices            cell corner/top/bottom indices
%             --
%           /    \
%        --   1,3  --                  5 -6- 4
%      /    \    /    \               /       \
%   --   1,2  --   2,3  --           0         3
% /    \    /    \    /    \          \       /
%   1,1  --   2,2  --   3,3            1 -7- 2
% \    /    \    /    \    /
%   --   2,1  --   3,2  --
%      \    /    \    /   
%        --   3,1  --     
%----------------------------------------------------
% flat side 
%    /  \  /  \  /  \                       5
%   | 11 || 12 || 13 ||                   /   6
%    \  /  \  /  \  /  \                 0     4
%     || 21 || 22 || 23 |                |     |
%       \  /  \  /  \  /  \              1     3
%        || 31 || 32 || 33 |              7   /
%-------------------------------------------2--------
%----------- procedures -------------
/ScalePoint { % stack: ... x y size ==> ...  x*size y*size
   3 dict begin /size exch def /y exch def /x exch def
   x size mul           y size mul
end } def

/FlatTopBoard { FlatSideCells } def

/FlatSideCells {  % redefine cell orientation for flat side
  /CellOrientation 0 def   
  /CellCorner [ % 6 cell corners, wrt center 0 0  %xcoord ycoord
    [HexRadius Root3Div2 mul neg  HexRadius 2 div     ]
    [HexRadius Root3Div2 mul neg  HexRadius 2 div neg ]
    [0                            HexRadius neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div ]
    [0                            HexRadius ]
    [HexRadius Root3Div2 2 div mul HexRadius 0.75 mul ]
    [HexRadius Root3Div2 2 div mul neg HexRadius 0.75 mul neg ]
  ] def
} def

/HexCenterPoint { % center of cell (i,j)
    2 dict begin /j exch def /i exch def
    CellOrientation 1 eq {
    OriginX i j add HexRadius mul 1.5 mul add %Ox + (i+j)*HR*1.5
    OriginY i j sub HexRadius mul Root3Div2 mul sub %Oy - (i-j)*HR*R3/2
    }{
    OriginX i 2 j mul add HexRadius mul Root3Div2 mul add  %Ox + (2i+j)*HR
    OriginY i 1 sub HexRadius mul 1.5 mul sub %Oy - i*HR*R3/2
    } ifelse
end } def
 
/HexLine { % a b c d
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint lineto
    stroke
} def

/HexCurve { % a b c d e f
    /f exch def
    /e exch def
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint e f HexCenterPoint HexRadius 2 mul arcto
    e f HexCenterPoint lineto
    stroke
} def

/HxgnCorner { 5 dict begin /corn exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    x CellCorner corn get 0 get add
    y CellCorner corn get 1 get add
end } def

/Go { 2 dict begin /corn exch def /mag exch def
   % rlineto in a cell orientation direction
   CellCorner corn get aload pop mag ScalePoint rlineto
end } def

/TurnGo { rotate 1.0 Left Go } def % call: degrees TurnGo
/MagTurnGo { rotate Left Go } def % call: mag degrees TurnGo

/HexagonPath { % call: i j HexagonPath
    newpath 
    UpRight HxgnCorner moveto 
    6 { 1.0 Left Go 60 rotate } repeat 
} def

/FillAndStroke { 2 dict begin /sh exch def /wdth exch def
    gsave sh setgray fill
    grestore 0 setgray wdth setlinewidth stroke
end } def

/ShadedHexagon { 3 dict begin /shade exch def /j exch def /i exch def
    i j HexagonPath
    0 shade FillAndStroke
end } def

/Hexagon { % stack: ... i j
    HexagonPath 
    HexLineWidth BoardShade FillAndStroke
} def

/SemiHexagonPath { % stack: ... top i j
    newpath 
    1 eq { Left HxgnCorner moveto 
        1.0 UpRight Go 1.0 Right Go 1.0 DownRight Go stroke }{
        Right HxgnCorner moveto 
        1.0 DownLeft Go 1.0 Left Go 1.0 UpLeft Go stroke
    } ifelse
} def

/HexBoardPerimeter {
    newpath
    1 DimY UpRight HxgnCorner moveto 1.0 Left Go                      
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 rotate %restore rotation
} def

%----------- Havannah coordinates ----------------------
%                   ..  ..  ..
%                 d1  c2  b3  a4
%                   c1  b2  a3
%                     b1  a2
%                       a1
/HavannahPosn { % convert to usual coordinate, so ... x y  =>  ... 1+DimX-x  y
    exch DimX 1 add exch sub exch 
} def

/HavannahBoardPerimeter {
    newpath
    1 DimX UpRight HxgnCorner moveto 1.0 Left Go                      
    6 {Base 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo } repeat
} def

/DrawHexBoard { 2 dict begin
    gsave
    HexBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexPLBoard { 6 dict begin %point-line board
    gsave
    BoardShade setgray newpath
    -1 DimY 1 add 0.5 mul HexCenterPoint moveto
    1 DimY HexCenterPoint lineto
    DimX 1 add 0.5 mul DimY 2 add HexCenterPoint lineto
    DimX DimY HexCenterPoint lineto
    DimX 2 add DimY 1 add 0.5 mul HexCenterPoint lineto
    DimX 1 HexCenterPoint lineto
    DimX 1 add 0.5 mul -1 HexCenterPoint lineto
    1 1 HexCenterPoint lineto
    closepath fill 0 setgray
    1 DimY HexCenterPoint moveto
    1 1 DimX { /i exch def 
        i 1 i DimY HexLine 
        DimY 1 add 0.5 mul -1 i 1 HexLine
        DimY 1 add 0.5 mul DimY 2 add i DimY HexLine } for
    1 1 DimY { /j exch def 
        1 j DimX j HexLine 
        -1 DimX 1 add 0.5 mul 1 j HexLine
        DimX 2 add DimX 1 add 0.5 mul DimX j HexLine } for
    /topx 1 def /topy 1 def /btmx 1 def /btmy 1 def
    DimX DimY add 3 sub {
      topx DimX lt {/topx 1 topx add def}{/topy 1 topy add def} ifelse 
      btmy DimY lt {/btmy 1 btmy add def}{/btmx 1 btmx add def} ifelse 
      topx topy btmx btmy HexLine
      } repeat
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j HexVertex
	} for } for
    grestore
end } def

/DrawHavannahBoard { 3 dict begin
    /Base DimX 1 add 2 idiv  def
    gsave
    HavannahBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 Base { /j exch def
	Base j 1 sub sub 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    1 1 Base 1 sub { /j exch def
	1 1 DimX j sub { /i exch def
	   i j Base add 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexBorder{ 6 dict begin /start exch def 
    /cells exch def /isBlack exch def /which exch def
    gsave
    which UpLeft eq {1 DimY 1 add start sub Up HxgnCorner moveto /d Left def /r 60 def} if
    which UpRight eq {start DimY Up HxgnCorner moveto /d Right def /r 300 def} if
    which DownLeft eq {DimX 1 add start sub 1 Down HxgnCorner moveto /d Left def /r 300 def} if
    which DownRight eq {DimX start Down HxgnCorner moveto /d Right def /r 60 def} if
    0.5 d Go 
    which UpRight eq which DownRight eq or {180 rotate} if
    r TurnGo 
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.5 360 r sub MagTurnGo 1.5 360 r sub 2 mul MagTurnGo
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.75 360 r sub MagTurnGo
    closepath isBlack 1 eq {gsave fill grestore} if stroke grestore
end } def

/NoDrawHexBoard {  % dummy, used in creating bounding box
} def

/HexBoardBorders { 1 dict begin
    /upperLeftBlack exch def
    PerimeterWidth setlinewidth 0 setgray
    UpLeft    upperLeftBlack       DimY 1 DrawHexBorder
    UpRight   1 upperLeftBlack sub DimX 1 DrawHexBorder
    DownRight upperLeftBlack       DimY 1 DrawHexBorder
    DownLeft  1 upperLeftBlack sub DimX 1 DrawHexBorder
end } def

/YBoardPerimeter {
    newpath 1 1 DownRight HxgnCorner moveto 180 rotate
    3 { DimX 1 sub { 300 TurnGo 60 TurnGo } repeat 
        60 TurnGo 60 TurnGo} 
    repeat % now restore initial rotation state
    180 rotate % closepath
} def

/DrawYBoard { 2 dict begin
    YBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimX {/j exch def
        1 1 DimX 1 add j sub {/i exch def
	    i j 1 SemiHexagonPath stroke
        } for } for
end } def

/FontSelect { % bold italic FontSelect
    2 dict begin /italic exch def /bold exch def
    bold {
	italic 
	{ /Times-BoldItalic findfont TextHeight scalefont setfont } 
	{ /Times-Bold findfont TextHeight scalefont setfont }
	ifelse} 
        {
	italic {/Times-Italic findfont TextHeight scalefont setfont} 
	{ /Times findfont TextHeight scalefont setfont }
	ifelse}
    ifelse
end } def
	    
/LabelString {   % call: i j (str) strlen LabelString
%  to use with board rotation, remove comments
    6 dict begin /strlen exch def /str exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint /y exch def /x exch def
    %BoardRotation rotate
    x y moveto 
    %360 BoardRotation sub rotate
    TextWidth strlen mul 0.5 mul neg TextHeight 0.33 mul neg rmoveto
    str show 
end } def

/AbsLabelString { 4 dict begin
    /strlen exch def /str exch def /y exch def /x exch def
    newpath
    x AbsCoordX TextWidth strlen mul 0.5 mul sub
    y AbsCoordY TextHeight 0.33 mul sub
    moveto
    str
    show
end } def

/LabelStringVerb { % i j (str) strlen shade bold italic LabelStringVerb
    7 dict begin /italic exch def /bold exch def /shade exch def
    /strlen exch def /str exch def /j exch def /i exch def
    bold italic FontSelect shade setgray
    i j str strlen LabelString
end } def

/HexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimX { /i exch def
	i 0          Chars i 1 sub get 1 LabelString
	i DimY 1 add Chars i 1 sub get 1 LabelString
    } for
    1 1 DimY { /j exch def
	0 j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
	DimX 1 add j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HavannahBoardCoordinates { 3 dict begin
    false true FontSelect CoordinatesShade setgray
    /Base DimX 1 add 2 idiv  def
    1 1 Base { /i exch def
	i 0 HavannahPosn Chars  i 1 sub get 1 LabelString
	0 i HavannahPosn Digits i 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
    1 1 Base 1 sub { /i exch def
	i Base add i HavannahPosn Chars  i Base add 1 sub get 1 LabelString
	i i Base add HavannahPosn Digits i Base add 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/AltHexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimY { /j exch def
	0 j Chars j 1 sub get 1 LabelString
        %DimX 1 add j Chars j 1 sub get 1 LabelString
    } for
    1 1 DimX { /i exch def
	i 0 Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
	%i DimY 1 add Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HexDot { 3 dict begin /size exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint size 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexWhiteMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexWhitePiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexBlackMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexBlackPiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    1 setgray 0 setlinewidth fill
end } def

/HexDoubleMarker { 6 dict begin
    /shaderight exch def /shadeleft exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    gsave
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    shadeleft setgray 0 setlinewidth fill
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    shaderight setgray 0 setlinewidth fill
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    grestore
end } def

/HexBlackWhiteMarker { 0.0 1.0 HexDoubleMarker } def

/HexWhiteBlackMarker { 1.0 0.0 HexDoubleMarker } def
        
/HexMarker { 2 dict begin /j exch def /i exch def
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setlinewidth fill
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke  
end } def

/HexBlackMarker { 2 dict begin /j exch def /i exch def
    0 setgray
    i j HexMarker
end } def

/HexWhiteMarker { 2 dict begin /j exch def /i exch def
    1 setgray
    i j HexMarker
end } def
    
/HexPiece { 3 dict begin /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/MagicStone { 4 dict begin 
    /size exch def /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 1.3 mul size mul 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/HexWhitePiece { 1.0 HexPiece } def

/HexBlackPiece { 0.0 HexPiece } def

/HexWhiteLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def
    i j HexWhitePiece
    i j str strlen 0.0 true true LabelStringVerb
end } def

/HexBlackLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def 
    i j HexBlackPiece
    i j str strlen 1.0 true true LabelStringVerb
end } def

/AbsCoordX { 1 dict begin /x exch def
    OriginX x Scale mul add
end } def

/AbsCoordY { 1 dict begin /y exch def
    OriginY y Scale mul add
end } def

/DrawBox { /maxy exch def /maxx exch def /miny exch def /minx exch def
    newpath
    minx miny moveto
    maxx minx sub 0 rlineto
    0 maxy miny sub rlineto
    minx maxx sub 0 rlineto
    0 miny maxy sub rlineto
    HexLineWidth setlinewidth
    0 setgray
    stroke
} def

/HexVertex { 2 dict begin /j exch def /i exch def
    i j GraphVertexSize HexDot
end } def

/HexLine { 4 dict begin /j2 exch def /i2 exch def /j1 exch def /i1 exch def
    GraphLineWidth setlinewidth
    0 setgray
    newpath
    i1 j1 HexCenterPoint moveto
    i2 j2 HexCenterPoint lineto
    stroke
end } def

%%---------------- Program -------------------


FlatTopBoard
DrawHexBoard
1 HexBoardBorders


%------------ Trailer --------------

showpage

%%EndDocument
 @endspecial 1900 w @beginspecial 0 @llx 0 @lly 66 @urx
47 @ury 1133 @rwi @setspecial
%%BeginDocument: fz/pix/4x4.eps
%!PS-Adobe-3.0
%%Creator: Jack van Rijswijck, thanks to Cameron Browne
%%BoundingBox: 0 0 66 47
%%Pages: 0
%%EndComments

/OriginX -6 def
/OriginY 36 def
%---------------- Variables -------------------

/DimX 4 def
/DimY 4 def
/Scale 1.2 def


% draw  Hex boards, any size ... but labels only up to 26x26
% based on code by Cameron Browne, revised by Jack vR, revised by RBH
%-------------- state initializations -------------------------
1 setlinejoin   % lines meet at a point  ==>    use round join
%---------------- constants -------------------
/Root3Div2  0.86602540378444 def
/Chars   {[(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)
           (n)(o)(p)(q)(r)(s)(t)(u)(v)(w)(x)(y)(z)]} def
/CharsUC {[(A)(B)(C)(D)(E)(F)(G)(H)(I)(J)(K)(L)(M)
           (N)(O)(P)(Q)(R)(S)(T)(U)(V)(W)(X)(Y)(Z)]} def
/Digits  {[(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)(12)(13)
           (14)(15)(16)(17)(18)(19)(20)(21)(22)(23)(24)(25)(26)]} def
/HexRadius      5 Scale mul def % hexagon center-to-corner distance 
/HexLineWidth 0.1 Scale mul def 
/GraphVertexSize 1.0 Scale mul def
/GraphLineWidth 0.5 Scale mul def
/CircleRadius 3.0 Scale mul def 
/CircleLineWidth 0.346 Scale mul def 
/PerimeterWidth 0.5 Scale mul def 
/TextHeight 4.5 def
/TextWidth TextHeight 0.45 mul def 
/BoardShade 0.8 def
/CoordinatesShade 0.5 def
/MarkerSize 1.2 def
/CellOrientation 1 def   % 1: flat bottom  0: pointed bottom
/CellCorner [ % 6 cell corners, wrt center 0 0, plus "up" and "down"
   [ HexRadius  neg       0                           ] 
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul neg ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul neg ]
   [ HexRadius            0                           ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul     ]
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul neg ]
] def
%----- name cell corner indices ... see below
/Left  0 def /DownLeft 1 def /DownRight 2 def 
/Right 3 def /UpRight  4 def /UpLeft    5 def 
/Up    6 def /Down     7 def
%-----------------------------------------------------
% cell orientations:  flat bottom    flat side
%-----------------------------------------------------
% flat bottom 
% board cell indices            cell corner/top/bottom indices
%             --
%           /    \
%        --   1,3  --                  5 -6- 4
%      /    \    /    \               /       \
%   --   1,2  --   2,3  --           0         3
% /    \    /    \    /    \          \       /
%   1,1  --   2,2  --   3,3            1 -7- 2
% \    /    \    /    \    /
%   --   2,1  --   3,2  --
%      \    /    \    /   
%        --   3,1  --     
%----------------------------------------------------
% flat side 
%    /  \  /  \  /  \                       5
%   | 11 || 12 || 13 ||                   /   6
%    \  /  \  /  \  /  \                 0     4
%     || 21 || 22 || 23 |                |     |
%       \  /  \  /  \  /  \              1     3
%        || 31 || 32 || 33 |              7   /
%-------------------------------------------2--------
%----------- procedures -------------
/ScalePoint { % stack: ... x y size ==> ...  x*size y*size
   3 dict begin /size exch def /y exch def /x exch def
   x size mul           y size mul
end } def

/FlatTopBoard { FlatSideCells } def

/FlatSideCells {  % redefine cell orientation for flat side
  /CellOrientation 0 def   
  /CellCorner [ % 6 cell corners, wrt center 0 0  %xcoord ycoord
    [HexRadius Root3Div2 mul neg  HexRadius 2 div     ]
    [HexRadius Root3Div2 mul neg  HexRadius 2 div neg ]
    [0                            HexRadius neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div ]
    [0                            HexRadius ]
    [HexRadius Root3Div2 2 div mul HexRadius 0.75 mul ]
    [HexRadius Root3Div2 2 div mul neg HexRadius 0.75 mul neg ]
  ] def
} def

/HexCenterPoint { % center of cell (i,j)
    2 dict begin /j exch def /i exch def
    CellOrientation 1 eq {
    OriginX i j add HexRadius mul 1.5 mul add %Ox + (i+j)*HR*1.5
    OriginY i j sub HexRadius mul Root3Div2 mul sub %Oy - (i-j)*HR*R3/2
    }{
    OriginX i 2 j mul add HexRadius mul Root3Div2 mul add  %Ox + (2i+j)*HR
    OriginY i 1 sub HexRadius mul 1.5 mul sub %Oy - i*HR*R3/2
    } ifelse
end } def
 
/HexLine { % a b c d
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint lineto
    stroke
} def

/HexCurve { % a b c d e f
    /f exch def
    /e exch def
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint e f HexCenterPoint HexRadius 2 mul arcto
    e f HexCenterPoint lineto
    stroke
} def

/HxgnCorner { 5 dict begin /corn exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    x CellCorner corn get 0 get add
    y CellCorner corn get 1 get add
end } def

/Go { 2 dict begin /corn exch def /mag exch def
   % rlineto in a cell orientation direction
   CellCorner corn get aload pop mag ScalePoint rlineto
end } def

/TurnGo { rotate 1.0 Left Go } def % call: degrees TurnGo
/MagTurnGo { rotate Left Go } def % call: mag degrees TurnGo

/HexagonPath { % call: i j HexagonPath
    newpath 
    UpRight HxgnCorner moveto 
    6 { 1.0 Left Go 60 rotate } repeat 
} def

/FillAndStroke { 2 dict begin /sh exch def /wdth exch def
    gsave sh setgray fill
    grestore 0 setgray wdth setlinewidth stroke
end } def

/ShadedHexagon { 3 dict begin /shade exch def /j exch def /i exch def
    i j HexagonPath
    0 shade FillAndStroke
end } def

/Hexagon { % stack: ... i j
    HexagonPath 
    HexLineWidth BoardShade FillAndStroke
} def

/SemiHexagonPath { % stack: ... top i j
    newpath 
    1 eq { Left HxgnCorner moveto 
        1.0 UpRight Go 1.0 Right Go 1.0 DownRight Go stroke }{
        Right HxgnCorner moveto 
        1.0 DownLeft Go 1.0 Left Go 1.0 UpLeft Go stroke
    } ifelse
} def

/HexBoardPerimeter {
    newpath
    1 DimY UpRight HxgnCorner moveto 1.0 Left Go                      
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 rotate %restore rotation
} def

%----------- Havannah coordinates ----------------------
%                   ..  ..  ..
%                 d1  c2  b3  a4
%                   c1  b2  a3
%                     b1  a2
%                       a1
/HavannahPosn { % convert to usual coordinate, so ... x y  =>  ... 1+DimX-x  y
    exch DimX 1 add exch sub exch 
} def

/HavannahBoardPerimeter {
    newpath
    1 DimX UpRight HxgnCorner moveto 1.0 Left Go                      
    6 {Base 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo } repeat
} def

/DrawHexBoard { 2 dict begin
    gsave
    HexBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexPLBoard { 6 dict begin %point-line board
    gsave
    BoardShade setgray newpath
    -1 DimY 1 add 0.5 mul HexCenterPoint moveto
    1 DimY HexCenterPoint lineto
    DimX 1 add 0.5 mul DimY 2 add HexCenterPoint lineto
    DimX DimY HexCenterPoint lineto
    DimX 2 add DimY 1 add 0.5 mul HexCenterPoint lineto
    DimX 1 HexCenterPoint lineto
    DimX 1 add 0.5 mul -1 HexCenterPoint lineto
    1 1 HexCenterPoint lineto
    closepath fill 0 setgray
    1 DimY HexCenterPoint moveto
    1 1 DimX { /i exch def 
        i 1 i DimY HexLine 
        DimY 1 add 0.5 mul -1 i 1 HexLine
        DimY 1 add 0.5 mul DimY 2 add i DimY HexLine } for
    1 1 DimY { /j exch def 
        1 j DimX j HexLine 
        -1 DimX 1 add 0.5 mul 1 j HexLine
        DimX 2 add DimX 1 add 0.5 mul DimX j HexLine } for
    /topx 1 def /topy 1 def /btmx 1 def /btmy 1 def
    DimX DimY add 3 sub {
      topx DimX lt {/topx 1 topx add def}{/topy 1 topy add def} ifelse 
      btmy DimY lt {/btmy 1 btmy add def}{/btmx 1 btmx add def} ifelse 
      topx topy btmx btmy HexLine
      } repeat
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j HexVertex
	} for } for
    grestore
end } def

/DrawHavannahBoard { 3 dict begin
    /Base DimX 1 add 2 idiv  def
    gsave
    HavannahBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 Base { /j exch def
	Base j 1 sub sub 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    1 1 Base 1 sub { /j exch def
	1 1 DimX j sub { /i exch def
	   i j Base add 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexBorder{ 6 dict begin /start exch def 
    /cells exch def /isBlack exch def /which exch def
    gsave
    which UpLeft eq {1 DimY 1 add start sub Up HxgnCorner moveto /d Left def /r 60 def} if
    which UpRight eq {start DimY Up HxgnCorner moveto /d Right def /r 300 def} if
    which DownLeft eq {DimX 1 add start sub 1 Down HxgnCorner moveto /d Left def /r 300 def} if
    which DownRight eq {DimX start Down HxgnCorner moveto /d Right def /r 60 def} if
    0.5 d Go 
    which UpRight eq which DownRight eq or {180 rotate} if
    r TurnGo 
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.5 360 r sub MagTurnGo 1.5 360 r sub 2 mul MagTurnGo
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.75 360 r sub MagTurnGo
    closepath isBlack 1 eq {gsave fill grestore} if stroke grestore
end } def

/NoDrawHexBoard {  % dummy, used in creating bounding box
} def

/HexBoardBorders { 1 dict begin
    /upperLeftBlack exch def
    PerimeterWidth setlinewidth 0 setgray
    UpLeft    upperLeftBlack       DimY 1 DrawHexBorder
    UpRight   1 upperLeftBlack sub DimX 1 DrawHexBorder
    DownRight upperLeftBlack       DimY 1 DrawHexBorder
    DownLeft  1 upperLeftBlack sub DimX 1 DrawHexBorder
end } def

/YBoardPerimeter {
    newpath 1 1 DownRight HxgnCorner moveto 180 rotate
    3 { DimX 1 sub { 300 TurnGo 60 TurnGo } repeat 
        60 TurnGo 60 TurnGo} 
    repeat % now restore initial rotation state
    180 rotate % closepath
} def

/DrawYBoard { 2 dict begin
    YBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimX {/j exch def
        1 1 DimX 1 add j sub {/i exch def
	    i j 1 SemiHexagonPath stroke
        } for } for
end } def

/FontSelect { % bold italic FontSelect
    2 dict begin /italic exch def /bold exch def
    bold {
	italic 
	{ /Times-BoldItalic findfont TextHeight scalefont setfont } 
	{ /Times-Bold findfont TextHeight scalefont setfont }
	ifelse} 
        {
	italic {/Times-Italic findfont TextHeight scalefont setfont} 
	{ /Times findfont TextHeight scalefont setfont }
	ifelse}
    ifelse
end } def
	    
/LabelString {   % call: i j (str) strlen LabelString
%  to use with board rotation, remove comments
    6 dict begin /strlen exch def /str exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint /y exch def /x exch def
    %BoardRotation rotate
    x y moveto 
    %360 BoardRotation sub rotate
    TextWidth strlen mul 0.5 mul neg TextHeight 0.33 mul neg rmoveto
    str show 
end } def

/AbsLabelString { 4 dict begin
    /strlen exch def /str exch def /y exch def /x exch def
    newpath
    x AbsCoordX TextWidth strlen mul 0.5 mul sub
    y AbsCoordY TextHeight 0.33 mul sub
    moveto
    str
    show
end } def

/LabelStringVerb { % i j (str) strlen shade bold italic LabelStringVerb
    7 dict begin /italic exch def /bold exch def /shade exch def
    /strlen exch def /str exch def /j exch def /i exch def
    bold italic FontSelect shade setgray
    i j str strlen LabelString
end } def

/HexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimX { /i exch def
	i 0          Chars i 1 sub get 1 LabelString
	i DimY 1 add Chars i 1 sub get 1 LabelString
    } for
    1 1 DimY { /j exch def
	0 j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
	DimX 1 add j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HavannahBoardCoordinates { 3 dict begin
    false true FontSelect CoordinatesShade setgray
    /Base DimX 1 add 2 idiv  def
    1 1 Base { /i exch def
	i 0 HavannahPosn Chars  i 1 sub get 1 LabelString
	0 i HavannahPosn Digits i 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
    1 1 Base 1 sub { /i exch def
	i Base add i HavannahPosn Chars  i Base add 1 sub get 1 LabelString
	i i Base add HavannahPosn Digits i Base add 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/AltHexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimY { /j exch def
	0 j Chars j 1 sub get 1 LabelString
        %DimX 1 add j Chars j 1 sub get 1 LabelString
    } for
    1 1 DimX { /i exch def
	i 0 Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
	%i DimY 1 add Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HexDot { 3 dict begin /size exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint size 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexWhiteMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexWhitePiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexBlackMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexBlackPiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    1 setgray 0 setlinewidth fill
end } def

/HexDoubleMarker { 6 dict begin
    /shaderight exch def /shadeleft exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    gsave
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    shadeleft setgray 0 setlinewidth fill
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    shaderight setgray 0 setlinewidth fill
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    grestore
end } def

/HexBlackWhiteMarker { 0.0 1.0 HexDoubleMarker } def

/HexWhiteBlackMarker { 1.0 0.0 HexDoubleMarker } def
        
/HexMarker { 2 dict begin /j exch def /i exch def
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setlinewidth fill
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke  
end } def

/HexBlackMarker { 2 dict begin /j exch def /i exch def
    0 setgray
    i j HexMarker
end } def

/HexWhiteMarker { 2 dict begin /j exch def /i exch def
    1 setgray
    i j HexMarker
end } def
    
/HexPiece { 3 dict begin /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/MagicStone { 4 dict begin 
    /size exch def /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 1.3 mul size mul 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/HexWhitePiece { 1.0 HexPiece } def

/HexBlackPiece { 0.0 HexPiece } def

/HexWhiteLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def
    i j HexWhitePiece
    i j str strlen 0.0 true true LabelStringVerb
end } def

/HexBlackLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def 
    i j HexBlackPiece
    i j str strlen 1.0 true true LabelStringVerb
end } def

/AbsCoordX { 1 dict begin /x exch def
    OriginX x Scale mul add
end } def

/AbsCoordY { 1 dict begin /y exch def
    OriginY y Scale mul add
end } def

/DrawBox { /maxy exch def /maxx exch def /miny exch def /minx exch def
    newpath
    minx miny moveto
    maxx minx sub 0 rlineto
    0 maxy miny sub rlineto
    minx maxx sub 0 rlineto
    0 miny maxy sub rlineto
    HexLineWidth setlinewidth
    0 setgray
    stroke
} def

/HexVertex { 2 dict begin /j exch def /i exch def
    i j GraphVertexSize HexDot
end } def

/HexLine { 4 dict begin /j2 exch def /i2 exch def /j1 exch def /i1 exch def
    GraphLineWidth setlinewidth
    0 setgray
    newpath
    i1 j1 HexCenterPoint moveto
    i2 j2 HexCenterPoint lineto
    stroke
end } def

%%---------------- Program -------------------


FlatTopBoard
DrawHexBoard
1 HexBoardBorders


%------------ Trailer --------------

showpage

%%EndDocument
 @endspecial 1900 w @beginspecial 0 @llx 0 @lly 66 @urx
47 @ury 1133 @rwi @setspecial
%%BeginDocument: fz/pix/4x4.eps
%!PS-Adobe-3.0
%%Creator: Jack van Rijswijck, thanks to Cameron Browne
%%BoundingBox: 0 0 66 47
%%Pages: 0
%%EndComments

/OriginX -6 def
/OriginY 36 def
%---------------- Variables -------------------

/DimX 4 def
/DimY 4 def
/Scale 1.2 def


% draw  Hex boards, any size ... but labels only up to 26x26
% based on code by Cameron Browne, revised by Jack vR, revised by RBH
%-------------- state initializations -------------------------
1 setlinejoin   % lines meet at a point  ==>    use round join
%---------------- constants -------------------
/Root3Div2  0.86602540378444 def
/Chars   {[(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)
           (n)(o)(p)(q)(r)(s)(t)(u)(v)(w)(x)(y)(z)]} def
/CharsUC {[(A)(B)(C)(D)(E)(F)(G)(H)(I)(J)(K)(L)(M)
           (N)(O)(P)(Q)(R)(S)(T)(U)(V)(W)(X)(Y)(Z)]} def
/Digits  {[(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)(12)(13)
           (14)(15)(16)(17)(18)(19)(20)(21)(22)(23)(24)(25)(26)]} def
/HexRadius      5 Scale mul def % hexagon center-to-corner distance 
/HexLineWidth 0.1 Scale mul def 
/GraphVertexSize 1.0 Scale mul def
/GraphLineWidth 0.5 Scale mul def
/CircleRadius 3.0 Scale mul def 
/CircleLineWidth 0.346 Scale mul def 
/PerimeterWidth 0.5 Scale mul def 
/TextHeight 4.5 def
/TextWidth TextHeight 0.45 mul def 
/BoardShade 0.8 def
/CoordinatesShade 0.5 def
/MarkerSize 1.2 def
/CellOrientation 1 def   % 1: flat bottom  0: pointed bottom
/CellCorner [ % 6 cell corners, wrt center 0 0, plus "up" and "down"
   [ HexRadius  neg       0                           ] 
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul neg ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul neg ]
   [ HexRadius            0                           ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul     ]
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul neg ]
] def
%----- name cell corner indices ... see below
/Left  0 def /DownLeft 1 def /DownRight 2 def 
/Right 3 def /UpRight  4 def /UpLeft    5 def 
/Up    6 def /Down     7 def
%-----------------------------------------------------
% cell orientations:  flat bottom    flat side
%-----------------------------------------------------
% flat bottom 
% board cell indices            cell corner/top/bottom indices
%             --
%           /    \
%        --   1,3  --                  5 -6- 4
%      /    \    /    \               /       \
%   --   1,2  --   2,3  --           0         3
% /    \    /    \    /    \          \       /
%   1,1  --   2,2  --   3,3            1 -7- 2
% \    /    \    /    \    /
%   --   2,1  --   3,2  --
%      \    /    \    /   
%        --   3,1  --     
%----------------------------------------------------
% flat side 
%    /  \  /  \  /  \                       5
%   | 11 || 12 || 13 ||                   /   6
%    \  /  \  /  \  /  \                 0     4
%     || 21 || 22 || 23 |                |     |
%       \  /  \  /  \  /  \              1     3
%        || 31 || 32 || 33 |              7   /
%-------------------------------------------2--------
%----------- procedures -------------
/ScalePoint { % stack: ... x y size ==> ...  x*size y*size
   3 dict begin /size exch def /y exch def /x exch def
   x size mul           y size mul
end } def

/FlatTopBoard { FlatSideCells } def

/FlatSideCells {  % redefine cell orientation for flat side
  /CellOrientation 0 def   
  /CellCorner [ % 6 cell corners, wrt center 0 0  %xcoord ycoord
    [HexRadius Root3Div2 mul neg  HexRadius 2 div     ]
    [HexRadius Root3Div2 mul neg  HexRadius 2 div neg ]
    [0                            HexRadius neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div ]
    [0                            HexRadius ]
    [HexRadius Root3Div2 2 div mul HexRadius 0.75 mul ]
    [HexRadius Root3Div2 2 div mul neg HexRadius 0.75 mul neg ]
  ] def
} def

/HexCenterPoint { % center of cell (i,j)
    2 dict begin /j exch def /i exch def
    CellOrientation 1 eq {
    OriginX i j add HexRadius mul 1.5 mul add %Ox + (i+j)*HR*1.5
    OriginY i j sub HexRadius mul Root3Div2 mul sub %Oy - (i-j)*HR*R3/2
    }{
    OriginX i 2 j mul add HexRadius mul Root3Div2 mul add  %Ox + (2i+j)*HR
    OriginY i 1 sub HexRadius mul 1.5 mul sub %Oy - i*HR*R3/2
    } ifelse
end } def
 
/HexLine { % a b c d
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint lineto
    stroke
} def

/HexCurve { % a b c d e f
    /f exch def
    /e exch def
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint e f HexCenterPoint HexRadius 2 mul arcto
    e f HexCenterPoint lineto
    stroke
} def

/HxgnCorner { 5 dict begin /corn exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    x CellCorner corn get 0 get add
    y CellCorner corn get 1 get add
end } def

/Go { 2 dict begin /corn exch def /mag exch def
   % rlineto in a cell orientation direction
   CellCorner corn get aload pop mag ScalePoint rlineto
end } def

/TurnGo { rotate 1.0 Left Go } def % call: degrees TurnGo
/MagTurnGo { rotate Left Go } def % call: mag degrees TurnGo

/HexagonPath { % call: i j HexagonPath
    newpath 
    UpRight HxgnCorner moveto 
    6 { 1.0 Left Go 60 rotate } repeat 
} def

/FillAndStroke { 2 dict begin /sh exch def /wdth exch def
    gsave sh setgray fill
    grestore 0 setgray wdth setlinewidth stroke
end } def

/ShadedHexagon { 3 dict begin /shade exch def /j exch def /i exch def
    i j HexagonPath
    0 shade FillAndStroke
end } def

/Hexagon { % stack: ... i j
    HexagonPath 
    HexLineWidth BoardShade FillAndStroke
} def

/SemiHexagonPath { % stack: ... top i j
    newpath 
    1 eq { Left HxgnCorner moveto 
        1.0 UpRight Go 1.0 Right Go 1.0 DownRight Go stroke }{
        Right HxgnCorner moveto 
        1.0 DownLeft Go 1.0 Left Go 1.0 UpLeft Go stroke
    } ifelse
} def

/HexBoardPerimeter {
    newpath
    1 DimY UpRight HxgnCorner moveto 1.0 Left Go                      
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 rotate %restore rotation
} def

%----------- Havannah coordinates ----------------------
%                   ..  ..  ..
%                 d1  c2  b3  a4
%                   c1  b2  a3
%                     b1  a2
%                       a1
/HavannahPosn { % convert to usual coordinate, so ... x y  =>  ... 1+DimX-x  y
    exch DimX 1 add exch sub exch 
} def

/HavannahBoardPerimeter {
    newpath
    1 DimX UpRight HxgnCorner moveto 1.0 Left Go                      
    6 {Base 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo } repeat
} def

/DrawHexBoard { 2 dict begin
    gsave
    HexBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexPLBoard { 6 dict begin %point-line board
    gsave
    BoardShade setgray newpath
    -1 DimY 1 add 0.5 mul HexCenterPoint moveto
    1 DimY HexCenterPoint lineto
    DimX 1 add 0.5 mul DimY 2 add HexCenterPoint lineto
    DimX DimY HexCenterPoint lineto
    DimX 2 add DimY 1 add 0.5 mul HexCenterPoint lineto
    DimX 1 HexCenterPoint lineto
    DimX 1 add 0.5 mul -1 HexCenterPoint lineto
    1 1 HexCenterPoint lineto
    closepath fill 0 setgray
    1 DimY HexCenterPoint moveto
    1 1 DimX { /i exch def 
        i 1 i DimY HexLine 
        DimY 1 add 0.5 mul -1 i 1 HexLine
        DimY 1 add 0.5 mul DimY 2 add i DimY HexLine } for
    1 1 DimY { /j exch def 
        1 j DimX j HexLine 
        -1 DimX 1 add 0.5 mul 1 j HexLine
        DimX 2 add DimX 1 add 0.5 mul DimX j HexLine } for
    /topx 1 def /topy 1 def /btmx 1 def /btmy 1 def
    DimX DimY add 3 sub {
      topx DimX lt {/topx 1 topx add def}{/topy 1 topy add def} ifelse 
      btmy DimY lt {/btmy 1 btmy add def}{/btmx 1 btmx add def} ifelse 
      topx topy btmx btmy HexLine
      } repeat
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j HexVertex
	} for } for
    grestore
end } def

/DrawHavannahBoard { 3 dict begin
    /Base DimX 1 add 2 idiv  def
    gsave
    HavannahBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 Base { /j exch def
	Base j 1 sub sub 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    1 1 Base 1 sub { /j exch def
	1 1 DimX j sub { /i exch def
	   i j Base add 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexBorder{ 6 dict begin /start exch def 
    /cells exch def /isBlack exch def /which exch def
    gsave
    which UpLeft eq {1 DimY 1 add start sub Up HxgnCorner moveto /d Left def /r 60 def} if
    which UpRight eq {start DimY Up HxgnCorner moveto /d Right def /r 300 def} if
    which DownLeft eq {DimX 1 add start sub 1 Down HxgnCorner moveto /d Left def /r 300 def} if
    which DownRight eq {DimX start Down HxgnCorner moveto /d Right def /r 60 def} if
    0.5 d Go 
    which UpRight eq which DownRight eq or {180 rotate} if
    r TurnGo 
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.5 360 r sub MagTurnGo 1.5 360 r sub 2 mul MagTurnGo
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.75 360 r sub MagTurnGo
    closepath isBlack 1 eq {gsave fill grestore} if stroke grestore
end } def

/NoDrawHexBoard {  % dummy, used in creating bounding box
} def

/HexBoardBorders { 1 dict begin
    /upperLeftBlack exch def
    PerimeterWidth setlinewidth 0 setgray
    UpLeft    upperLeftBlack       DimY 1 DrawHexBorder
    UpRight   1 upperLeftBlack sub DimX 1 DrawHexBorder
    DownRight upperLeftBlack       DimY 1 DrawHexBorder
    DownLeft  1 upperLeftBlack sub DimX 1 DrawHexBorder
end } def

/YBoardPerimeter {
    newpath 1 1 DownRight HxgnCorner moveto 180 rotate
    3 { DimX 1 sub { 300 TurnGo 60 TurnGo } repeat 
        60 TurnGo 60 TurnGo} 
    repeat % now restore initial rotation state
    180 rotate % closepath
} def

/DrawYBoard { 2 dict begin
    YBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimX {/j exch def
        1 1 DimX 1 add j sub {/i exch def
	    i j 1 SemiHexagonPath stroke
        } for } for
end } def

/FontSelect { % bold italic FontSelect
    2 dict begin /italic exch def /bold exch def
    bold {
	italic 
	{ /Times-BoldItalic findfont TextHeight scalefont setfont } 
	{ /Times-Bold findfont TextHeight scalefont setfont }
	ifelse} 
        {
	italic {/Times-Italic findfont TextHeight scalefont setfont} 
	{ /Times findfont TextHeight scalefont setfont }
	ifelse}
    ifelse
end } def
	    
/LabelString {   % call: i j (str) strlen LabelString
%  to use with board rotation, remove comments
    6 dict begin /strlen exch def /str exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint /y exch def /x exch def
    %BoardRotation rotate
    x y moveto 
    %360 BoardRotation sub rotate
    TextWidth strlen mul 0.5 mul neg TextHeight 0.33 mul neg rmoveto
    str show 
end } def

/AbsLabelString { 4 dict begin
    /strlen exch def /str exch def /y exch def /x exch def
    newpath
    x AbsCoordX TextWidth strlen mul 0.5 mul sub
    y AbsCoordY TextHeight 0.33 mul sub
    moveto
    str
    show
end } def

/LabelStringVerb { % i j (str) strlen shade bold italic LabelStringVerb
    7 dict begin /italic exch def /bold exch def /shade exch def
    /strlen exch def /str exch def /j exch def /i exch def
    bold italic FontSelect shade setgray
    i j str strlen LabelString
end } def

/HexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimX { /i exch def
	i 0          Chars i 1 sub get 1 LabelString
	i DimY 1 add Chars i 1 sub get 1 LabelString
    } for
    1 1 DimY { /j exch def
	0 j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
	DimX 1 add j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HavannahBoardCoordinates { 3 dict begin
    false true FontSelect CoordinatesShade setgray
    /Base DimX 1 add 2 idiv  def
    1 1 Base { /i exch def
	i 0 HavannahPosn Chars  i 1 sub get 1 LabelString
	0 i HavannahPosn Digits i 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
    1 1 Base 1 sub { /i exch def
	i Base add i HavannahPosn Chars  i Base add 1 sub get 1 LabelString
	i i Base add HavannahPosn Digits i Base add 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/AltHexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimY { /j exch def
	0 j Chars j 1 sub get 1 LabelString
        %DimX 1 add j Chars j 1 sub get 1 LabelString
    } for
    1 1 DimX { /i exch def
	i 0 Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
	%i DimY 1 add Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HexDot { 3 dict begin /size exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint size 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexWhiteMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexWhitePiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexBlackMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexBlackPiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    1 setgray 0 setlinewidth fill
end } def

/HexDoubleMarker { 6 dict begin
    /shaderight exch def /shadeleft exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    gsave
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    shadeleft setgray 0 setlinewidth fill
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    shaderight setgray 0 setlinewidth fill
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    grestore
end } def

/HexBlackWhiteMarker { 0.0 1.0 HexDoubleMarker } def

/HexWhiteBlackMarker { 1.0 0.0 HexDoubleMarker } def
        
/HexMarker { 2 dict begin /j exch def /i exch def
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setlinewidth fill
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke  
end } def

/HexBlackMarker { 2 dict begin /j exch def /i exch def
    0 setgray
    i j HexMarker
end } def

/HexWhiteMarker { 2 dict begin /j exch def /i exch def
    1 setgray
    i j HexMarker
end } def
    
/HexPiece { 3 dict begin /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/MagicStone { 4 dict begin 
    /size exch def /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 1.3 mul size mul 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/HexWhitePiece { 1.0 HexPiece } def

/HexBlackPiece { 0.0 HexPiece } def

/HexWhiteLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def
    i j HexWhitePiece
    i j str strlen 0.0 true true LabelStringVerb
end } def

/HexBlackLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def 
    i j HexBlackPiece
    i j str strlen 1.0 true true LabelStringVerb
end } def

/AbsCoordX { 1 dict begin /x exch def
    OriginX x Scale mul add
end } def

/AbsCoordY { 1 dict begin /y exch def
    OriginY y Scale mul add
end } def

/DrawBox { /maxy exch def /maxx exch def /miny exch def /minx exch def
    newpath
    minx miny moveto
    maxx minx sub 0 rlineto
    0 maxy miny sub rlineto
    minx maxx sub 0 rlineto
    0 miny maxy sub rlineto
    HexLineWidth setlinewidth
    0 setgray
    stroke
} def

/HexVertex { 2 dict begin /j exch def /i exch def
    i j GraphVertexSize HexDot
end } def

/HexLine { 4 dict begin /j2 exch def /i2 exch def /j1 exch def /i1 exch def
    GraphLineWidth setlinewidth
    0 setgray
    newpath
    i1 j1 HexCenterPoint moveto
    i2 j2 HexCenterPoint lineto
    stroke
end } def

%%---------------- Program -------------------


FlatTopBoard
DrawHexBoard
1 HexBoardBorders


%------------ Trailer --------------

showpage

%%EndDocument
 @endspecial 563 4679 a @beginspecial 0 @llx 0 @lly 66
@urx 47 @ury 1133 @rwi @setspecial
%%BeginDocument: fz/pix/4x4.eps
%!PS-Adobe-3.0
%%Creator: Jack van Rijswijck, thanks to Cameron Browne
%%BoundingBox: 0 0 66 47
%%Pages: 0
%%EndComments

/OriginX -6 def
/OriginY 36 def
%---------------- Variables -------------------

/DimX 4 def
/DimY 4 def
/Scale 1.2 def


% draw  Hex boards, any size ... but labels only up to 26x26
% based on code by Cameron Browne, revised by Jack vR, revised by RBH
%-------------- state initializations -------------------------
1 setlinejoin   % lines meet at a point  ==>    use round join
%---------------- constants -------------------
/Root3Div2  0.86602540378444 def
/Chars   {[(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)
           (n)(o)(p)(q)(r)(s)(t)(u)(v)(w)(x)(y)(z)]} def
/CharsUC {[(A)(B)(C)(D)(E)(F)(G)(H)(I)(J)(K)(L)(M)
           (N)(O)(P)(Q)(R)(S)(T)(U)(V)(W)(X)(Y)(Z)]} def
/Digits  {[(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)(12)(13)
           (14)(15)(16)(17)(18)(19)(20)(21)(22)(23)(24)(25)(26)]} def
/HexRadius      5 Scale mul def % hexagon center-to-corner distance 
/HexLineWidth 0.1 Scale mul def 
/GraphVertexSize 1.0 Scale mul def
/GraphLineWidth 0.5 Scale mul def
/CircleRadius 3.0 Scale mul def 
/CircleLineWidth 0.346 Scale mul def 
/PerimeterWidth 0.5 Scale mul def 
/TextHeight 4.5 def
/TextWidth TextHeight 0.45 mul def 
/BoardShade 0.8 def
/CoordinatesShade 0.5 def
/MarkerSize 1.2 def
/CellOrientation 1 def   % 1: flat bottom  0: pointed bottom
/CellCorner [ % 6 cell corners, wrt center 0 0, plus "up" and "down"
   [ HexRadius  neg       0                           ] 
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul neg ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul neg ]
   [ HexRadius            0                           ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul     ]
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul neg ]
] def
%----- name cell corner indices ... see below
/Left  0 def /DownLeft 1 def /DownRight 2 def 
/Right 3 def /UpRight  4 def /UpLeft    5 def 
/Up    6 def /Down     7 def
%-----------------------------------------------------
% cell orientations:  flat bottom    flat side
%-----------------------------------------------------
% flat bottom 
% board cell indices            cell corner/top/bottom indices
%             --
%           /    \
%        --   1,3  --                  5 -6- 4
%      /    \    /    \               /       \
%   --   1,2  --   2,3  --           0         3
% /    \    /    \    /    \          \       /
%   1,1  --   2,2  --   3,3            1 -7- 2
% \    /    \    /    \    /
%   --   2,1  --   3,2  --
%      \    /    \    /   
%        --   3,1  --     
%----------------------------------------------------
% flat side 
%    /  \  /  \  /  \                       5
%   | 11 || 12 || 13 ||                   /   6
%    \  /  \  /  \  /  \                 0     4
%     || 21 || 22 || 23 |                |     |
%       \  /  \  /  \  /  \              1     3
%        || 31 || 32 || 33 |              7   /
%-------------------------------------------2--------
%----------- procedures -------------
/ScalePoint { % stack: ... x y size ==> ...  x*size y*size
   3 dict begin /size exch def /y exch def /x exch def
   x size mul           y size mul
end } def

/FlatTopBoard { FlatSideCells } def

/FlatSideCells {  % redefine cell orientation for flat side
  /CellOrientation 0 def   
  /CellCorner [ % 6 cell corners, wrt center 0 0  %xcoord ycoord
    [HexRadius Root3Div2 mul neg  HexRadius 2 div     ]
    [HexRadius Root3Div2 mul neg  HexRadius 2 div neg ]
    [0                            HexRadius neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div ]
    [0                            HexRadius ]
    [HexRadius Root3Div2 2 div mul HexRadius 0.75 mul ]
    [HexRadius Root3Div2 2 div mul neg HexRadius 0.75 mul neg ]
  ] def
} def

/HexCenterPoint { % center of cell (i,j)
    2 dict begin /j exch def /i exch def
    CellOrientation 1 eq {
    OriginX i j add HexRadius mul 1.5 mul add %Ox + (i+j)*HR*1.5
    OriginY i j sub HexRadius mul Root3Div2 mul sub %Oy - (i-j)*HR*R3/2
    }{
    OriginX i 2 j mul add HexRadius mul Root3Div2 mul add  %Ox + (2i+j)*HR
    OriginY i 1 sub HexRadius mul 1.5 mul sub %Oy - i*HR*R3/2
    } ifelse
end } def
 
/HexLine { % a b c d
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint lineto
    stroke
} def

/HexCurve { % a b c d e f
    /f exch def
    /e exch def
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint e f HexCenterPoint HexRadius 2 mul arcto
    e f HexCenterPoint lineto
    stroke
} def

/HxgnCorner { 5 dict begin /corn exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    x CellCorner corn get 0 get add
    y CellCorner corn get 1 get add
end } def

/Go { 2 dict begin /corn exch def /mag exch def
   % rlineto in a cell orientation direction
   CellCorner corn get aload pop mag ScalePoint rlineto
end } def

/TurnGo { rotate 1.0 Left Go } def % call: degrees TurnGo
/MagTurnGo { rotate Left Go } def % call: mag degrees TurnGo

/HexagonPath { % call: i j HexagonPath
    newpath 
    UpRight HxgnCorner moveto 
    6 { 1.0 Left Go 60 rotate } repeat 
} def

/FillAndStroke { 2 dict begin /sh exch def /wdth exch def
    gsave sh setgray fill
    grestore 0 setgray wdth setlinewidth stroke
end } def

/ShadedHexagon { 3 dict begin /shade exch def /j exch def /i exch def
    i j HexagonPath
    0 shade FillAndStroke
end } def

/Hexagon { % stack: ... i j
    HexagonPath 
    HexLineWidth BoardShade FillAndStroke
} def

/SemiHexagonPath { % stack: ... top i j
    newpath 
    1 eq { Left HxgnCorner moveto 
        1.0 UpRight Go 1.0 Right Go 1.0 DownRight Go stroke }{
        Right HxgnCorner moveto 
        1.0 DownLeft Go 1.0 Left Go 1.0 UpLeft Go stroke
    } ifelse
} def

/HexBoardPerimeter {
    newpath
    1 DimY UpRight HxgnCorner moveto 1.0 Left Go                      
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 rotate %restore rotation
} def

%----------- Havannah coordinates ----------------------
%                   ..  ..  ..
%                 d1  c2  b3  a4
%                   c1  b2  a3
%                     b1  a2
%                       a1
/HavannahPosn { % convert to usual coordinate, so ... x y  =>  ... 1+DimX-x  y
    exch DimX 1 add exch sub exch 
} def

/HavannahBoardPerimeter {
    newpath
    1 DimX UpRight HxgnCorner moveto 1.0 Left Go                      
    6 {Base 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo } repeat
} def

/DrawHexBoard { 2 dict begin
    gsave
    HexBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexPLBoard { 6 dict begin %point-line board
    gsave
    BoardShade setgray newpath
    -1 DimY 1 add 0.5 mul HexCenterPoint moveto
    1 DimY HexCenterPoint lineto
    DimX 1 add 0.5 mul DimY 2 add HexCenterPoint lineto
    DimX DimY HexCenterPoint lineto
    DimX 2 add DimY 1 add 0.5 mul HexCenterPoint lineto
    DimX 1 HexCenterPoint lineto
    DimX 1 add 0.5 mul -1 HexCenterPoint lineto
    1 1 HexCenterPoint lineto
    closepath fill 0 setgray
    1 DimY HexCenterPoint moveto
    1 1 DimX { /i exch def 
        i 1 i DimY HexLine 
        DimY 1 add 0.5 mul -1 i 1 HexLine
        DimY 1 add 0.5 mul DimY 2 add i DimY HexLine } for
    1 1 DimY { /j exch def 
        1 j DimX j HexLine 
        -1 DimX 1 add 0.5 mul 1 j HexLine
        DimX 2 add DimX 1 add 0.5 mul DimX j HexLine } for
    /topx 1 def /topy 1 def /btmx 1 def /btmy 1 def
    DimX DimY add 3 sub {
      topx DimX lt {/topx 1 topx add def}{/topy 1 topy add def} ifelse 
      btmy DimY lt {/btmy 1 btmy add def}{/btmx 1 btmx add def} ifelse 
      topx topy btmx btmy HexLine
      } repeat
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j HexVertex
	} for } for
    grestore
end } def

/DrawHavannahBoard { 3 dict begin
    /Base DimX 1 add 2 idiv  def
    gsave
    HavannahBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 Base { /j exch def
	Base j 1 sub sub 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    1 1 Base 1 sub { /j exch def
	1 1 DimX j sub { /i exch def
	   i j Base add 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexBorder{ 6 dict begin /start exch def 
    /cells exch def /isBlack exch def /which exch def
    gsave
    which UpLeft eq {1 DimY 1 add start sub Up HxgnCorner moveto /d Left def /r 60 def} if
    which UpRight eq {start DimY Up HxgnCorner moveto /d Right def /r 300 def} if
    which DownLeft eq {DimX 1 add start sub 1 Down HxgnCorner moveto /d Left def /r 300 def} if
    which DownRight eq {DimX start Down HxgnCorner moveto /d Right def /r 60 def} if
    0.5 d Go 
    which UpRight eq which DownRight eq or {180 rotate} if
    r TurnGo 
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.5 360 r sub MagTurnGo 1.5 360 r sub 2 mul MagTurnGo
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.75 360 r sub MagTurnGo
    closepath isBlack 1 eq {gsave fill grestore} if stroke grestore
end } def

/NoDrawHexBoard {  % dummy, used in creating bounding box
} def

/HexBoardBorders { 1 dict begin
    /upperLeftBlack exch def
    PerimeterWidth setlinewidth 0 setgray
    UpLeft    upperLeftBlack       DimY 1 DrawHexBorder
    UpRight   1 upperLeftBlack sub DimX 1 DrawHexBorder
    DownRight upperLeftBlack       DimY 1 DrawHexBorder
    DownLeft  1 upperLeftBlack sub DimX 1 DrawHexBorder
end } def

/YBoardPerimeter {
    newpath 1 1 DownRight HxgnCorner moveto 180 rotate
    3 { DimX 1 sub { 300 TurnGo 60 TurnGo } repeat 
        60 TurnGo 60 TurnGo} 
    repeat % now restore initial rotation state
    180 rotate % closepath
} def

/DrawYBoard { 2 dict begin
    YBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimX {/j exch def
        1 1 DimX 1 add j sub {/i exch def
	    i j 1 SemiHexagonPath stroke
        } for } for
end } def

/FontSelect { % bold italic FontSelect
    2 dict begin /italic exch def /bold exch def
    bold {
	italic 
	{ /Times-BoldItalic findfont TextHeight scalefont setfont } 
	{ /Times-Bold findfont TextHeight scalefont setfont }
	ifelse} 
        {
	italic {/Times-Italic findfont TextHeight scalefont setfont} 
	{ /Times findfont TextHeight scalefont setfont }
	ifelse}
    ifelse
end } def
	    
/LabelString {   % call: i j (str) strlen LabelString
%  to use with board rotation, remove comments
    6 dict begin /strlen exch def /str exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint /y exch def /x exch def
    %BoardRotation rotate
    x y moveto 
    %360 BoardRotation sub rotate
    TextWidth strlen mul 0.5 mul neg TextHeight 0.33 mul neg rmoveto
    str show 
end } def

/AbsLabelString { 4 dict begin
    /strlen exch def /str exch def /y exch def /x exch def
    newpath
    x AbsCoordX TextWidth strlen mul 0.5 mul sub
    y AbsCoordY TextHeight 0.33 mul sub
    moveto
    str
    show
end } def

/LabelStringVerb { % i j (str) strlen shade bold italic LabelStringVerb
    7 dict begin /italic exch def /bold exch def /shade exch def
    /strlen exch def /str exch def /j exch def /i exch def
    bold italic FontSelect shade setgray
    i j str strlen LabelString
end } def

/HexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimX { /i exch def
	i 0          Chars i 1 sub get 1 LabelString
	i DimY 1 add Chars i 1 sub get 1 LabelString
    } for
    1 1 DimY { /j exch def
	0 j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
	DimX 1 add j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HavannahBoardCoordinates { 3 dict begin
    false true FontSelect CoordinatesShade setgray
    /Base DimX 1 add 2 idiv  def
    1 1 Base { /i exch def
	i 0 HavannahPosn Chars  i 1 sub get 1 LabelString
	0 i HavannahPosn Digits i 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
    1 1 Base 1 sub { /i exch def
	i Base add i HavannahPosn Chars  i Base add 1 sub get 1 LabelString
	i i Base add HavannahPosn Digits i Base add 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/AltHexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimY { /j exch def
	0 j Chars j 1 sub get 1 LabelString
        %DimX 1 add j Chars j 1 sub get 1 LabelString
    } for
    1 1 DimX { /i exch def
	i 0 Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
	%i DimY 1 add Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HexDot { 3 dict begin /size exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint size 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexWhiteMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexWhitePiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexBlackMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexBlackPiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    1 setgray 0 setlinewidth fill
end } def

/HexDoubleMarker { 6 dict begin
    /shaderight exch def /shadeleft exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    gsave
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    shadeleft setgray 0 setlinewidth fill
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    shaderight setgray 0 setlinewidth fill
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    grestore
end } def

/HexBlackWhiteMarker { 0.0 1.0 HexDoubleMarker } def

/HexWhiteBlackMarker { 1.0 0.0 HexDoubleMarker } def
        
/HexMarker { 2 dict begin /j exch def /i exch def
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setlinewidth fill
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke  
end } def

/HexBlackMarker { 2 dict begin /j exch def /i exch def
    0 setgray
    i j HexMarker
end } def

/HexWhiteMarker { 2 dict begin /j exch def /i exch def
    1 setgray
    i j HexMarker
end } def
    
/HexPiece { 3 dict begin /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/MagicStone { 4 dict begin 
    /size exch def /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 1.3 mul size mul 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/HexWhitePiece { 1.0 HexPiece } def

/HexBlackPiece { 0.0 HexPiece } def

/HexWhiteLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def
    i j HexWhitePiece
    i j str strlen 0.0 true true LabelStringVerb
end } def

/HexBlackLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def 
    i j HexBlackPiece
    i j str strlen 1.0 true true LabelStringVerb
end } def

/AbsCoordX { 1 dict begin /x exch def
    OriginX x Scale mul add
end } def

/AbsCoordY { 1 dict begin /y exch def
    OriginY y Scale mul add
end } def

/DrawBox { /maxy exch def /maxx exch def /miny exch def /minx exch def
    newpath
    minx miny moveto
    maxx minx sub 0 rlineto
    0 maxy miny sub rlineto
    minx maxx sub 0 rlineto
    0 miny maxy sub rlineto
    HexLineWidth setlinewidth
    0 setgray
    stroke
} def

/HexVertex { 2 dict begin /j exch def /i exch def
    i j GraphVertexSize HexDot
end } def

/HexLine { 4 dict begin /j2 exch def /i2 exch def /j1 exch def /i1 exch def
    GraphLineWidth setlinewidth
    0 setgray
    newpath
    i1 j1 HexCenterPoint moveto
    i2 j2 HexCenterPoint lineto
    stroke
end } def

%%---------------- Program -------------------


FlatTopBoard
DrawHexBoard
1 HexBoardBorders


%------------ Trailer --------------

showpage

%%EndDocument
 @endspecial 1900 w @beginspecial 0 @llx 0 @lly 66 @urx
47 @ury 1133 @rwi @setspecial
%%BeginDocument: fz/pix/4x4.eps
%!PS-Adobe-3.0
%%Creator: Jack van Rijswijck, thanks to Cameron Browne
%%BoundingBox: 0 0 66 47
%%Pages: 0
%%EndComments

/OriginX -6 def
/OriginY 36 def
%---------------- Variables -------------------

/DimX 4 def
/DimY 4 def
/Scale 1.2 def


% draw  Hex boards, any size ... but labels only up to 26x26
% based on code by Cameron Browne, revised by Jack vR, revised by RBH
%-------------- state initializations -------------------------
1 setlinejoin   % lines meet at a point  ==>    use round join
%---------------- constants -------------------
/Root3Div2  0.86602540378444 def
/Chars   {[(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)
           (n)(o)(p)(q)(r)(s)(t)(u)(v)(w)(x)(y)(z)]} def
/CharsUC {[(A)(B)(C)(D)(E)(F)(G)(H)(I)(J)(K)(L)(M)
           (N)(O)(P)(Q)(R)(S)(T)(U)(V)(W)(X)(Y)(Z)]} def
/Digits  {[(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)(12)(13)
           (14)(15)(16)(17)(18)(19)(20)(21)(22)(23)(24)(25)(26)]} def
/HexRadius      5 Scale mul def % hexagon center-to-corner distance 
/HexLineWidth 0.1 Scale mul def 
/GraphVertexSize 1.0 Scale mul def
/GraphLineWidth 0.5 Scale mul def
/CircleRadius 3.0 Scale mul def 
/CircleLineWidth 0.346 Scale mul def 
/PerimeterWidth 0.5 Scale mul def 
/TextHeight 4.5 def
/TextWidth TextHeight 0.45 mul def 
/BoardShade 0.8 def
/CoordinatesShade 0.5 def
/MarkerSize 1.2 def
/CellOrientation 1 def   % 1: flat bottom  0: pointed bottom
/CellCorner [ % 6 cell corners, wrt center 0 0, plus "up" and "down"
   [ HexRadius  neg       0                           ] 
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul neg ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul neg ]
   [ HexRadius            0                           ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul     ]
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul neg ]
] def
%----- name cell corner indices ... see below
/Left  0 def /DownLeft 1 def /DownRight 2 def 
/Right 3 def /UpRight  4 def /UpLeft    5 def 
/Up    6 def /Down     7 def
%-----------------------------------------------------
% cell orientations:  flat bottom    flat side
%-----------------------------------------------------
% flat bottom 
% board cell indices            cell corner/top/bottom indices
%             --
%           /    \
%        --   1,3  --                  5 -6- 4
%      /    \    /    \               /       \
%   --   1,2  --   2,3  --           0         3
% /    \    /    \    /    \          \       /
%   1,1  --   2,2  --   3,3            1 -7- 2
% \    /    \    /    \    /
%   --   2,1  --   3,2  --
%      \    /    \    /   
%        --   3,1  --     
%----------------------------------------------------
% flat side 
%    /  \  /  \  /  \                       5
%   | 11 || 12 || 13 ||                   /   6
%    \  /  \  /  \  /  \                 0     4
%     || 21 || 22 || 23 |                |     |
%       \  /  \  /  \  /  \              1     3
%        || 31 || 32 || 33 |              7   /
%-------------------------------------------2--------
%----------- procedures -------------
/ScalePoint { % stack: ... x y size ==> ...  x*size y*size
   3 dict begin /size exch def /y exch def /x exch def
   x size mul           y size mul
end } def

/FlatTopBoard { FlatSideCells } def

/FlatSideCells {  % redefine cell orientation for flat side
  /CellOrientation 0 def   
  /CellCorner [ % 6 cell corners, wrt center 0 0  %xcoord ycoord
    [HexRadius Root3Div2 mul neg  HexRadius 2 div     ]
    [HexRadius Root3Div2 mul neg  HexRadius 2 div neg ]
    [0                            HexRadius neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div ]
    [0                            HexRadius ]
    [HexRadius Root3Div2 2 div mul HexRadius 0.75 mul ]
    [HexRadius Root3Div2 2 div mul neg HexRadius 0.75 mul neg ]
  ] def
} def

/HexCenterPoint { % center of cell (i,j)
    2 dict begin /j exch def /i exch def
    CellOrientation 1 eq {
    OriginX i j add HexRadius mul 1.5 mul add %Ox + (i+j)*HR*1.5
    OriginY i j sub HexRadius mul Root3Div2 mul sub %Oy - (i-j)*HR*R3/2
    }{
    OriginX i 2 j mul add HexRadius mul Root3Div2 mul add  %Ox + (2i+j)*HR
    OriginY i 1 sub HexRadius mul 1.5 mul sub %Oy - i*HR*R3/2
    } ifelse
end } def
 
/HexLine { % a b c d
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint lineto
    stroke
} def

/HexCurve { % a b c d e f
    /f exch def
    /e exch def
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint e f HexCenterPoint HexRadius 2 mul arcto
    e f HexCenterPoint lineto
    stroke
} def

/HxgnCorner { 5 dict begin /corn exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    x CellCorner corn get 0 get add
    y CellCorner corn get 1 get add
end } def

/Go { 2 dict begin /corn exch def /mag exch def
   % rlineto in a cell orientation direction
   CellCorner corn get aload pop mag ScalePoint rlineto
end } def

/TurnGo { rotate 1.0 Left Go } def % call: degrees TurnGo
/MagTurnGo { rotate Left Go } def % call: mag degrees TurnGo

/HexagonPath { % call: i j HexagonPath
    newpath 
    UpRight HxgnCorner moveto 
    6 { 1.0 Left Go 60 rotate } repeat 
} def

/FillAndStroke { 2 dict begin /sh exch def /wdth exch def
    gsave sh setgray fill
    grestore 0 setgray wdth setlinewidth stroke
end } def

/ShadedHexagon { 3 dict begin /shade exch def /j exch def /i exch def
    i j HexagonPath
    0 shade FillAndStroke
end } def

/Hexagon { % stack: ... i j
    HexagonPath 
    HexLineWidth BoardShade FillAndStroke
} def

/SemiHexagonPath { % stack: ... top i j
    newpath 
    1 eq { Left HxgnCorner moveto 
        1.0 UpRight Go 1.0 Right Go 1.0 DownRight Go stroke }{
        Right HxgnCorner moveto 
        1.0 DownLeft Go 1.0 Left Go 1.0 UpLeft Go stroke
    } ifelse
} def

/HexBoardPerimeter {
    newpath
    1 DimY UpRight HxgnCorner moveto 1.0 Left Go                      
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 rotate %restore rotation
} def

%----------- Havannah coordinates ----------------------
%                   ..  ..  ..
%                 d1  c2  b3  a4
%                   c1  b2  a3
%                     b1  a2
%                       a1
/HavannahPosn { % convert to usual coordinate, so ... x y  =>  ... 1+DimX-x  y
    exch DimX 1 add exch sub exch 
} def

/HavannahBoardPerimeter {
    newpath
    1 DimX UpRight HxgnCorner moveto 1.0 Left Go                      
    6 {Base 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo } repeat
} def

/DrawHexBoard { 2 dict begin
    gsave
    HexBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexPLBoard { 6 dict begin %point-line board
    gsave
    BoardShade setgray newpath
    -1 DimY 1 add 0.5 mul HexCenterPoint moveto
    1 DimY HexCenterPoint lineto
    DimX 1 add 0.5 mul DimY 2 add HexCenterPoint lineto
    DimX DimY HexCenterPoint lineto
    DimX 2 add DimY 1 add 0.5 mul HexCenterPoint lineto
    DimX 1 HexCenterPoint lineto
    DimX 1 add 0.5 mul -1 HexCenterPoint lineto
    1 1 HexCenterPoint lineto
    closepath fill 0 setgray
    1 DimY HexCenterPoint moveto
    1 1 DimX { /i exch def 
        i 1 i DimY HexLine 
        DimY 1 add 0.5 mul -1 i 1 HexLine
        DimY 1 add 0.5 mul DimY 2 add i DimY HexLine } for
    1 1 DimY { /j exch def 
        1 j DimX j HexLine 
        -1 DimX 1 add 0.5 mul 1 j HexLine
        DimX 2 add DimX 1 add 0.5 mul DimX j HexLine } for
    /topx 1 def /topy 1 def /btmx 1 def /btmy 1 def
    DimX DimY add 3 sub {
      topx DimX lt {/topx 1 topx add def}{/topy 1 topy add def} ifelse 
      btmy DimY lt {/btmy 1 btmy add def}{/btmx 1 btmx add def} ifelse 
      topx topy btmx btmy HexLine
      } repeat
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j HexVertex
	} for } for
    grestore
end } def

/DrawHavannahBoard { 3 dict begin
    /Base DimX 1 add 2 idiv  def
    gsave
    HavannahBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 Base { /j exch def
	Base j 1 sub sub 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    1 1 Base 1 sub { /j exch def
	1 1 DimX j sub { /i exch def
	   i j Base add 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexBorder{ 6 dict begin /start exch def 
    /cells exch def /isBlack exch def /which exch def
    gsave
    which UpLeft eq {1 DimY 1 add start sub Up HxgnCorner moveto /d Left def /r 60 def} if
    which UpRight eq {start DimY Up HxgnCorner moveto /d Right def /r 300 def} if
    which DownLeft eq {DimX 1 add start sub 1 Down HxgnCorner moveto /d Left def /r 300 def} if
    which DownRight eq {DimX start Down HxgnCorner moveto /d Right def /r 60 def} if
    0.5 d Go 
    which UpRight eq which DownRight eq or {180 rotate} if
    r TurnGo 
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.5 360 r sub MagTurnGo 1.5 360 r sub 2 mul MagTurnGo
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.75 360 r sub MagTurnGo
    closepath isBlack 1 eq {gsave fill grestore} if stroke grestore
end } def

/NoDrawHexBoard {  % dummy, used in creating bounding box
} def

/HexBoardBorders { 1 dict begin
    /upperLeftBlack exch def
    PerimeterWidth setlinewidth 0 setgray
    UpLeft    upperLeftBlack       DimY 1 DrawHexBorder
    UpRight   1 upperLeftBlack sub DimX 1 DrawHexBorder
    DownRight upperLeftBlack       DimY 1 DrawHexBorder
    DownLeft  1 upperLeftBlack sub DimX 1 DrawHexBorder
end } def

/YBoardPerimeter {
    newpath 1 1 DownRight HxgnCorner moveto 180 rotate
    3 { DimX 1 sub { 300 TurnGo 60 TurnGo } repeat 
        60 TurnGo 60 TurnGo} 
    repeat % now restore initial rotation state
    180 rotate % closepath
} def

/DrawYBoard { 2 dict begin
    YBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimX {/j exch def
        1 1 DimX 1 add j sub {/i exch def
	    i j 1 SemiHexagonPath stroke
        } for } for
end } def

/FontSelect { % bold italic FontSelect
    2 dict begin /italic exch def /bold exch def
    bold {
	italic 
	{ /Times-BoldItalic findfont TextHeight scalefont setfont } 
	{ /Times-Bold findfont TextHeight scalefont setfont }
	ifelse} 
        {
	italic {/Times-Italic findfont TextHeight scalefont setfont} 
	{ /Times findfont TextHeight scalefont setfont }
	ifelse}
    ifelse
end } def
	    
/LabelString {   % call: i j (str) strlen LabelString
%  to use with board rotation, remove comments
    6 dict begin /strlen exch def /str exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint /y exch def /x exch def
    %BoardRotation rotate
    x y moveto 
    %360 BoardRotation sub rotate
    TextWidth strlen mul 0.5 mul neg TextHeight 0.33 mul neg rmoveto
    str show 
end } def

/AbsLabelString { 4 dict begin
    /strlen exch def /str exch def /y exch def /x exch def
    newpath
    x AbsCoordX TextWidth strlen mul 0.5 mul sub
    y AbsCoordY TextHeight 0.33 mul sub
    moveto
    str
    show
end } def

/LabelStringVerb { % i j (str) strlen shade bold italic LabelStringVerb
    7 dict begin /italic exch def /bold exch def /shade exch def
    /strlen exch def /str exch def /j exch def /i exch def
    bold italic FontSelect shade setgray
    i j str strlen LabelString
end } def

/HexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimX { /i exch def
	i 0          Chars i 1 sub get 1 LabelString
	i DimY 1 add Chars i 1 sub get 1 LabelString
    } for
    1 1 DimY { /j exch def
	0 j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
	DimX 1 add j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HavannahBoardCoordinates { 3 dict begin
    false true FontSelect CoordinatesShade setgray
    /Base DimX 1 add 2 idiv  def
    1 1 Base { /i exch def
	i 0 HavannahPosn Chars  i 1 sub get 1 LabelString
	0 i HavannahPosn Digits i 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
    1 1 Base 1 sub { /i exch def
	i Base add i HavannahPosn Chars  i Base add 1 sub get 1 LabelString
	i i Base add HavannahPosn Digits i Base add 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/AltHexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimY { /j exch def
	0 j Chars j 1 sub get 1 LabelString
        %DimX 1 add j Chars j 1 sub get 1 LabelString
    } for
    1 1 DimX { /i exch def
	i 0 Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
	%i DimY 1 add Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HexDot { 3 dict begin /size exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint size 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexWhiteMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexWhitePiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexBlackMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexBlackPiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    1 setgray 0 setlinewidth fill
end } def

/HexDoubleMarker { 6 dict begin
    /shaderight exch def /shadeleft exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    gsave
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    shadeleft setgray 0 setlinewidth fill
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    shaderight setgray 0 setlinewidth fill
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    grestore
end } def

/HexBlackWhiteMarker { 0.0 1.0 HexDoubleMarker } def

/HexWhiteBlackMarker { 1.0 0.0 HexDoubleMarker } def
        
/HexMarker { 2 dict begin /j exch def /i exch def
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setlinewidth fill
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke  
end } def

/HexBlackMarker { 2 dict begin /j exch def /i exch def
    0 setgray
    i j HexMarker
end } def

/HexWhiteMarker { 2 dict begin /j exch def /i exch def
    1 setgray
    i j HexMarker
end } def
    
/HexPiece { 3 dict begin /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/MagicStone { 4 dict begin 
    /size exch def /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 1.3 mul size mul 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/HexWhitePiece { 1.0 HexPiece } def

/HexBlackPiece { 0.0 HexPiece } def

/HexWhiteLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def
    i j HexWhitePiece
    i j str strlen 0.0 true true LabelStringVerb
end } def

/HexBlackLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def 
    i j HexBlackPiece
    i j str strlen 1.0 true true LabelStringVerb
end } def

/AbsCoordX { 1 dict begin /x exch def
    OriginX x Scale mul add
end } def

/AbsCoordY { 1 dict begin /y exch def
    OriginY y Scale mul add
end } def

/DrawBox { /maxy exch def /maxx exch def /miny exch def /minx exch def
    newpath
    minx miny moveto
    maxx minx sub 0 rlineto
    0 maxy miny sub rlineto
    minx maxx sub 0 rlineto
    0 miny maxy sub rlineto
    HexLineWidth setlinewidth
    0 setgray
    stroke
} def

/HexVertex { 2 dict begin /j exch def /i exch def
    i j GraphVertexSize HexDot
end } def

/HexLine { 4 dict begin /j2 exch def /i2 exch def /j1 exch def /i1 exch def
    GraphLineWidth setlinewidth
    0 setgray
    newpath
    i1 j1 HexCenterPoint moveto
    i2 j2 HexCenterPoint lineto
    stroke
end } def

%%---------------- Program -------------------


FlatTopBoard
DrawHexBoard
1 HexBoardBorders


%------------ Trailer --------------

showpage

%%EndDocument
 @endspecial 1900 w @beginspecial 0 @llx 0 @lly 66 @urx
47 @ury 1133 @rwi @setspecial
%%BeginDocument: fz/pix/4x4.eps
%!PS-Adobe-3.0
%%Creator: Jack van Rijswijck, thanks to Cameron Browne
%%BoundingBox: 0 0 66 47
%%Pages: 0
%%EndComments

/OriginX -6 def
/OriginY 36 def
%---------------- Variables -------------------

/DimX 4 def
/DimY 4 def
/Scale 1.2 def


% draw  Hex boards, any size ... but labels only up to 26x26
% based on code by Cameron Browne, revised by Jack vR, revised by RBH
%-------------- state initializations -------------------------
1 setlinejoin   % lines meet at a point  ==>    use round join
%---------------- constants -------------------
/Root3Div2  0.86602540378444 def
/Chars   {[(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)
           (n)(o)(p)(q)(r)(s)(t)(u)(v)(w)(x)(y)(z)]} def
/CharsUC {[(A)(B)(C)(D)(E)(F)(G)(H)(I)(J)(K)(L)(M)
           (N)(O)(P)(Q)(R)(S)(T)(U)(V)(W)(X)(Y)(Z)]} def
/Digits  {[(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)(12)(13)
           (14)(15)(16)(17)(18)(19)(20)(21)(22)(23)(24)(25)(26)]} def
/HexRadius      5 Scale mul def % hexagon center-to-corner distance 
/HexLineWidth 0.1 Scale mul def 
/GraphVertexSize 1.0 Scale mul def
/GraphLineWidth 0.5 Scale mul def
/CircleRadius 3.0 Scale mul def 
/CircleLineWidth 0.346 Scale mul def 
/PerimeterWidth 0.5 Scale mul def 
/TextHeight 4.5 def
/TextWidth TextHeight 0.45 mul def 
/BoardShade 0.8 def
/CoordinatesShade 0.5 def
/MarkerSize 1.2 def
/CellOrientation 1 def   % 1: flat bottom  0: pointed bottom
/CellCorner [ % 6 cell corners, wrt center 0 0, plus "up" and "down"
   [ HexRadius  neg       0                           ] 
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul neg ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul neg ]
   [ HexRadius            0                           ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul     ]
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul neg ]
] def
%----- name cell corner indices ... see below
/Left  0 def /DownLeft 1 def /DownRight 2 def 
/Right 3 def /UpRight  4 def /UpLeft    5 def 
/Up    6 def /Down     7 def
%-----------------------------------------------------
% cell orientations:  flat bottom    flat side
%-----------------------------------------------------
% flat bottom 
% board cell indices            cell corner/top/bottom indices
%             --
%           /    \
%        --   1,3  --                  5 -6- 4
%      /    \    /    \               /       \
%   --   1,2  --   2,3  --           0         3
% /    \    /    \    /    \          \       /
%   1,1  --   2,2  --   3,3            1 -7- 2
% \    /    \    /    \    /
%   --   2,1  --   3,2  --
%      \    /    \    /   
%        --   3,1  --     
%----------------------------------------------------
% flat side 
%    /  \  /  \  /  \                       5
%   | 11 || 12 || 13 ||                   /   6
%    \  /  \  /  \  /  \                 0     4
%     || 21 || 22 || 23 |                |     |
%       \  /  \  /  \  /  \              1     3
%        || 31 || 32 || 33 |              7   /
%-------------------------------------------2--------
%----------- procedures -------------
/ScalePoint { % stack: ... x y size ==> ...  x*size y*size
   3 dict begin /size exch def /y exch def /x exch def
   x size mul           y size mul
end } def

/FlatTopBoard { FlatSideCells } def

/FlatSideCells {  % redefine cell orientation for flat side
  /CellOrientation 0 def   
  /CellCorner [ % 6 cell corners, wrt center 0 0  %xcoord ycoord
    [HexRadius Root3Div2 mul neg  HexRadius 2 div     ]
    [HexRadius Root3Div2 mul neg  HexRadius 2 div neg ]
    [0                            HexRadius neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div ]
    [0                            HexRadius ]
    [HexRadius Root3Div2 2 div mul HexRadius 0.75 mul ]
    [HexRadius Root3Div2 2 div mul neg HexRadius 0.75 mul neg ]
  ] def
} def

/HexCenterPoint { % center of cell (i,j)
    2 dict begin /j exch def /i exch def
    CellOrientation 1 eq {
    OriginX i j add HexRadius mul 1.5 mul add %Ox + (i+j)*HR*1.5
    OriginY i j sub HexRadius mul Root3Div2 mul sub %Oy - (i-j)*HR*R3/2
    }{
    OriginX i 2 j mul add HexRadius mul Root3Div2 mul add  %Ox + (2i+j)*HR
    OriginY i 1 sub HexRadius mul 1.5 mul sub %Oy - i*HR*R3/2
    } ifelse
end } def
 
/HexLine { % a b c d
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint lineto
    stroke
} def

/HexCurve { % a b c d e f
    /f exch def
    /e exch def
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint e f HexCenterPoint HexRadius 2 mul arcto
    e f HexCenterPoint lineto
    stroke
} def

/HxgnCorner { 5 dict begin /corn exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    x CellCorner corn get 0 get add
    y CellCorner corn get 1 get add
end } def

/Go { 2 dict begin /corn exch def /mag exch def
   % rlineto in a cell orientation direction
   CellCorner corn get aload pop mag ScalePoint rlineto
end } def

/TurnGo { rotate 1.0 Left Go } def % call: degrees TurnGo
/MagTurnGo { rotate Left Go } def % call: mag degrees TurnGo

/HexagonPath { % call: i j HexagonPath
    newpath 
    UpRight HxgnCorner moveto 
    6 { 1.0 Left Go 60 rotate } repeat 
} def

/FillAndStroke { 2 dict begin /sh exch def /wdth exch def
    gsave sh setgray fill
    grestore 0 setgray wdth setlinewidth stroke
end } def

/ShadedHexagon { 3 dict begin /shade exch def /j exch def /i exch def
    i j HexagonPath
    0 shade FillAndStroke
end } def

/Hexagon { % stack: ... i j
    HexagonPath 
    HexLineWidth BoardShade FillAndStroke
} def

/SemiHexagonPath { % stack: ... top i j
    newpath 
    1 eq { Left HxgnCorner moveto 
        1.0 UpRight Go 1.0 Right Go 1.0 DownRight Go stroke }{
        Right HxgnCorner moveto 
        1.0 DownLeft Go 1.0 Left Go 1.0 UpLeft Go stroke
    } ifelse
} def

/HexBoardPerimeter {
    newpath
    1 DimY UpRight HxgnCorner moveto 1.0 Left Go                      
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 rotate %restore rotation
} def

%----------- Havannah coordinates ----------------------
%                   ..  ..  ..
%                 d1  c2  b3  a4
%                   c1  b2  a3
%                     b1  a2
%                       a1
/HavannahPosn { % convert to usual coordinate, so ... x y  =>  ... 1+DimX-x  y
    exch DimX 1 add exch sub exch 
} def

/HavannahBoardPerimeter {
    newpath
    1 DimX UpRight HxgnCorner moveto 1.0 Left Go                      
    6 {Base 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo } repeat
} def

/DrawHexBoard { 2 dict begin
    gsave
    HexBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexPLBoard { 6 dict begin %point-line board
    gsave
    BoardShade setgray newpath
    -1 DimY 1 add 0.5 mul HexCenterPoint moveto
    1 DimY HexCenterPoint lineto
    DimX 1 add 0.5 mul DimY 2 add HexCenterPoint lineto
    DimX DimY HexCenterPoint lineto
    DimX 2 add DimY 1 add 0.5 mul HexCenterPoint lineto
    DimX 1 HexCenterPoint lineto
    DimX 1 add 0.5 mul -1 HexCenterPoint lineto
    1 1 HexCenterPoint lineto
    closepath fill 0 setgray
    1 DimY HexCenterPoint moveto
    1 1 DimX { /i exch def 
        i 1 i DimY HexLine 
        DimY 1 add 0.5 mul -1 i 1 HexLine
        DimY 1 add 0.5 mul DimY 2 add i DimY HexLine } for
    1 1 DimY { /j exch def 
        1 j DimX j HexLine 
        -1 DimX 1 add 0.5 mul 1 j HexLine
        DimX 2 add DimX 1 add 0.5 mul DimX j HexLine } for
    /topx 1 def /topy 1 def /btmx 1 def /btmy 1 def
    DimX DimY add 3 sub {
      topx DimX lt {/topx 1 topx add def}{/topy 1 topy add def} ifelse 
      btmy DimY lt {/btmy 1 btmy add def}{/btmx 1 btmx add def} ifelse 
      topx topy btmx btmy HexLine
      } repeat
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j HexVertex
	} for } for
    grestore
end } def

/DrawHavannahBoard { 3 dict begin
    /Base DimX 1 add 2 idiv  def
    gsave
    HavannahBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 Base { /j exch def
	Base j 1 sub sub 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    1 1 Base 1 sub { /j exch def
	1 1 DimX j sub { /i exch def
	   i j Base add 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexBorder{ 6 dict begin /start exch def 
    /cells exch def /isBlack exch def /which exch def
    gsave
    which UpLeft eq {1 DimY 1 add start sub Up HxgnCorner moveto /d Left def /r 60 def} if
    which UpRight eq {start DimY Up HxgnCorner moveto /d Right def /r 300 def} if
    which DownLeft eq {DimX 1 add start sub 1 Down HxgnCorner moveto /d Left def /r 300 def} if
    which DownRight eq {DimX start Down HxgnCorner moveto /d Right def /r 60 def} if
    0.5 d Go 
    which UpRight eq which DownRight eq or {180 rotate} if
    r TurnGo 
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.5 360 r sub MagTurnGo 1.5 360 r sub 2 mul MagTurnGo
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.75 360 r sub MagTurnGo
    closepath isBlack 1 eq {gsave fill grestore} if stroke grestore
end } def

/NoDrawHexBoard {  % dummy, used in creating bounding box
} def

/HexBoardBorders { 1 dict begin
    /upperLeftBlack exch def
    PerimeterWidth setlinewidth 0 setgray
    UpLeft    upperLeftBlack       DimY 1 DrawHexBorder
    UpRight   1 upperLeftBlack sub DimX 1 DrawHexBorder
    DownRight upperLeftBlack       DimY 1 DrawHexBorder
    DownLeft  1 upperLeftBlack sub DimX 1 DrawHexBorder
end } def

/YBoardPerimeter {
    newpath 1 1 DownRight HxgnCorner moveto 180 rotate
    3 { DimX 1 sub { 300 TurnGo 60 TurnGo } repeat 
        60 TurnGo 60 TurnGo} 
    repeat % now restore initial rotation state
    180 rotate % closepath
} def

/DrawYBoard { 2 dict begin
    YBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimX {/j exch def
        1 1 DimX 1 add j sub {/i exch def
	    i j 1 SemiHexagonPath stroke
        } for } for
end } def

/FontSelect { % bold italic FontSelect
    2 dict begin /italic exch def /bold exch def
    bold {
	italic 
	{ /Times-BoldItalic findfont TextHeight scalefont setfont } 
	{ /Times-Bold findfont TextHeight scalefont setfont }
	ifelse} 
        {
	italic {/Times-Italic findfont TextHeight scalefont setfont} 
	{ /Times findfont TextHeight scalefont setfont }
	ifelse}
    ifelse
end } def
	    
/LabelString {   % call: i j (str) strlen LabelString
%  to use with board rotation, remove comments
    6 dict begin /strlen exch def /str exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint /y exch def /x exch def
    %BoardRotation rotate
    x y moveto 
    %360 BoardRotation sub rotate
    TextWidth strlen mul 0.5 mul neg TextHeight 0.33 mul neg rmoveto
    str show 
end } def

/AbsLabelString { 4 dict begin
    /strlen exch def /str exch def /y exch def /x exch def
    newpath
    x AbsCoordX TextWidth strlen mul 0.5 mul sub
    y AbsCoordY TextHeight 0.33 mul sub
    moveto
    str
    show
end } def

/LabelStringVerb { % i j (str) strlen shade bold italic LabelStringVerb
    7 dict begin /italic exch def /bold exch def /shade exch def
    /strlen exch def /str exch def /j exch def /i exch def
    bold italic FontSelect shade setgray
    i j str strlen LabelString
end } def

/HexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimX { /i exch def
	i 0          Chars i 1 sub get 1 LabelString
	i DimY 1 add Chars i 1 sub get 1 LabelString
    } for
    1 1 DimY { /j exch def
	0 j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
	DimX 1 add j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HavannahBoardCoordinates { 3 dict begin
    false true FontSelect CoordinatesShade setgray
    /Base DimX 1 add 2 idiv  def
    1 1 Base { /i exch def
	i 0 HavannahPosn Chars  i 1 sub get 1 LabelString
	0 i HavannahPosn Digits i 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
    1 1 Base 1 sub { /i exch def
	i Base add i HavannahPosn Chars  i Base add 1 sub get 1 LabelString
	i i Base add HavannahPosn Digits i Base add 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/AltHexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimY { /j exch def
	0 j Chars j 1 sub get 1 LabelString
        %DimX 1 add j Chars j 1 sub get 1 LabelString
    } for
    1 1 DimX { /i exch def
	i 0 Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
	%i DimY 1 add Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HexDot { 3 dict begin /size exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint size 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexWhiteMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexWhitePiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexBlackMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexBlackPiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    1 setgray 0 setlinewidth fill
end } def

/HexDoubleMarker { 6 dict begin
    /shaderight exch def /shadeleft exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    gsave
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    shadeleft setgray 0 setlinewidth fill
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    shaderight setgray 0 setlinewidth fill
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    grestore
end } def

/HexBlackWhiteMarker { 0.0 1.0 HexDoubleMarker } def

/HexWhiteBlackMarker { 1.0 0.0 HexDoubleMarker } def
        
/HexMarker { 2 dict begin /j exch def /i exch def
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setlinewidth fill
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke  
end } def

/HexBlackMarker { 2 dict begin /j exch def /i exch def
    0 setgray
    i j HexMarker
end } def

/HexWhiteMarker { 2 dict begin /j exch def /i exch def
    1 setgray
    i j HexMarker
end } def
    
/HexPiece { 3 dict begin /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/MagicStone { 4 dict begin 
    /size exch def /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 1.3 mul size mul 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/HexWhitePiece { 1.0 HexPiece } def

/HexBlackPiece { 0.0 HexPiece } def

/HexWhiteLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def
    i j HexWhitePiece
    i j str strlen 0.0 true true LabelStringVerb
end } def

/HexBlackLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def 
    i j HexBlackPiece
    i j str strlen 1.0 true true LabelStringVerb
end } def

/AbsCoordX { 1 dict begin /x exch def
    OriginX x Scale mul add
end } def

/AbsCoordY { 1 dict begin /y exch def
    OriginY y Scale mul add
end } def

/DrawBox { /maxy exch def /maxx exch def /miny exch def /minx exch def
    newpath
    minx miny moveto
    maxx minx sub 0 rlineto
    0 maxy miny sub rlineto
    minx maxx sub 0 rlineto
    0 miny maxy sub rlineto
    HexLineWidth setlinewidth
    0 setgray
    stroke
} def

/HexVertex { 2 dict begin /j exch def /i exch def
    i j GraphVertexSize HexDot
end } def

/HexLine { 4 dict begin /j2 exch def /i2 exch def /j1 exch def /i1 exch def
    GraphLineWidth setlinewidth
    0 setgray
    newpath
    i1 j1 HexCenterPoint moveto
    i2 j2 HexCenterPoint lineto
    stroke
end } def

%%---------------- Program -------------------


FlatTopBoard
DrawHexBoard
1 HexBoardBorders


%------------ Trailer --------------

showpage

%%EndDocument
 @endspecial 563 6262 a @beginspecial 0 @llx 0 @lly 66
@urx 47 @ury 1133 @rwi @setspecial
%%BeginDocument: fz/pix/4x4.eps
%!PS-Adobe-3.0
%%Creator: Jack van Rijswijck, thanks to Cameron Browne
%%BoundingBox: 0 0 66 47
%%Pages: 0
%%EndComments

/OriginX -6 def
/OriginY 36 def
%---------------- Variables -------------------

/DimX 4 def
/DimY 4 def
/Scale 1.2 def


% draw  Hex boards, any size ... but labels only up to 26x26
% based on code by Cameron Browne, revised by Jack vR, revised by RBH
%-------------- state initializations -------------------------
1 setlinejoin   % lines meet at a point  ==>    use round join
%---------------- constants -------------------
/Root3Div2  0.86602540378444 def
/Chars   {[(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)
           (n)(o)(p)(q)(r)(s)(t)(u)(v)(w)(x)(y)(z)]} def
/CharsUC {[(A)(B)(C)(D)(E)(F)(G)(H)(I)(J)(K)(L)(M)
           (N)(O)(P)(Q)(R)(S)(T)(U)(V)(W)(X)(Y)(Z)]} def
/Digits  {[(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)(12)(13)
           (14)(15)(16)(17)(18)(19)(20)(21)(22)(23)(24)(25)(26)]} def
/HexRadius      5 Scale mul def % hexagon center-to-corner distance 
/HexLineWidth 0.1 Scale mul def 
/GraphVertexSize 1.0 Scale mul def
/GraphLineWidth 0.5 Scale mul def
/CircleRadius 3.0 Scale mul def 
/CircleLineWidth 0.346 Scale mul def 
/PerimeterWidth 0.5 Scale mul def 
/TextHeight 4.5 def
/TextWidth TextHeight 0.45 mul def 
/BoardShade 0.8 def
/CoordinatesShade 0.5 def
/MarkerSize 1.2 def
/CellOrientation 1 def   % 1: flat bottom  0: pointed bottom
/CellCorner [ % 6 cell corners, wrt center 0 0, plus "up" and "down"
   [ HexRadius  neg       0                           ] 
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul neg ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul neg ]
   [ HexRadius            0                           ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul     ]
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul neg ]
] def
%----- name cell corner indices ... see below
/Left  0 def /DownLeft 1 def /DownRight 2 def 
/Right 3 def /UpRight  4 def /UpLeft    5 def 
/Up    6 def /Down     7 def
%-----------------------------------------------------
% cell orientations:  flat bottom    flat side
%-----------------------------------------------------
% flat bottom 
% board cell indices            cell corner/top/bottom indices
%             --
%           /    \
%        --   1,3  --                  5 -6- 4
%      /    \    /    \               /       \
%   --   1,2  --   2,3  --           0         3
% /    \    /    \    /    \          \       /
%   1,1  --   2,2  --   3,3            1 -7- 2
% \    /    \    /    \    /
%   --   2,1  --   3,2  --
%      \    /    \    /   
%        --   3,1  --     
%----------------------------------------------------
% flat side 
%    /  \  /  \  /  \                       5
%   | 11 || 12 || 13 ||                   /   6
%    \  /  \  /  \  /  \                 0     4
%     || 21 || 22 || 23 |                |     |
%       \  /  \  /  \  /  \              1     3
%        || 31 || 32 || 33 |              7   /
%-------------------------------------------2--------
%----------- procedures -------------
/ScalePoint { % stack: ... x y size ==> ...  x*size y*size
   3 dict begin /size exch def /y exch def /x exch def
   x size mul           y size mul
end } def

/FlatTopBoard { FlatSideCells } def

/FlatSideCells {  % redefine cell orientation for flat side
  /CellOrientation 0 def   
  /CellCorner [ % 6 cell corners, wrt center 0 0  %xcoord ycoord
    [HexRadius Root3Div2 mul neg  HexRadius 2 div     ]
    [HexRadius Root3Div2 mul neg  HexRadius 2 div neg ]
    [0                            HexRadius neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div ]
    [0                            HexRadius ]
    [HexRadius Root3Div2 2 div mul HexRadius 0.75 mul ]
    [HexRadius Root3Div2 2 div mul neg HexRadius 0.75 mul neg ]
  ] def
} def

/HexCenterPoint { % center of cell (i,j)
    2 dict begin /j exch def /i exch def
    CellOrientation 1 eq {
    OriginX i j add HexRadius mul 1.5 mul add %Ox + (i+j)*HR*1.5
    OriginY i j sub HexRadius mul Root3Div2 mul sub %Oy - (i-j)*HR*R3/2
    }{
    OriginX i 2 j mul add HexRadius mul Root3Div2 mul add  %Ox + (2i+j)*HR
    OriginY i 1 sub HexRadius mul 1.5 mul sub %Oy - i*HR*R3/2
    } ifelse
end } def
 
/HexLine { % a b c d
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint lineto
    stroke
} def

/HexCurve { % a b c d e f
    /f exch def
    /e exch def
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint e f HexCenterPoint HexRadius 2 mul arcto
    e f HexCenterPoint lineto
    stroke
} def

/HxgnCorner { 5 dict begin /corn exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    x CellCorner corn get 0 get add
    y CellCorner corn get 1 get add
end } def

/Go { 2 dict begin /corn exch def /mag exch def
   % rlineto in a cell orientation direction
   CellCorner corn get aload pop mag ScalePoint rlineto
end } def

/TurnGo { rotate 1.0 Left Go } def % call: degrees TurnGo
/MagTurnGo { rotate Left Go } def % call: mag degrees TurnGo

/HexagonPath { % call: i j HexagonPath
    newpath 
    UpRight HxgnCorner moveto 
    6 { 1.0 Left Go 60 rotate } repeat 
} def

/FillAndStroke { 2 dict begin /sh exch def /wdth exch def
    gsave sh setgray fill
    grestore 0 setgray wdth setlinewidth stroke
end } def

/ShadedHexagon { 3 dict begin /shade exch def /j exch def /i exch def
    i j HexagonPath
    0 shade FillAndStroke
end } def

/Hexagon { % stack: ... i j
    HexagonPath 
    HexLineWidth BoardShade FillAndStroke
} def

/SemiHexagonPath { % stack: ... top i j
    newpath 
    1 eq { Left HxgnCorner moveto 
        1.0 UpRight Go 1.0 Right Go 1.0 DownRight Go stroke }{
        Right HxgnCorner moveto 
        1.0 DownLeft Go 1.0 Left Go 1.0 UpLeft Go stroke
    } ifelse
} def

/HexBoardPerimeter {
    newpath
    1 DimY UpRight HxgnCorner moveto 1.0 Left Go                      
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 rotate %restore rotation
} def

%----------- Havannah coordinates ----------------------
%                   ..  ..  ..
%                 d1  c2  b3  a4
%                   c1  b2  a3
%                     b1  a2
%                       a1
/HavannahPosn { % convert to usual coordinate, so ... x y  =>  ... 1+DimX-x  y
    exch DimX 1 add exch sub exch 
} def

/HavannahBoardPerimeter {
    newpath
    1 DimX UpRight HxgnCorner moveto 1.0 Left Go                      
    6 {Base 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo } repeat
} def

/DrawHexBoard { 2 dict begin
    gsave
    HexBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexPLBoard { 6 dict begin %point-line board
    gsave
    BoardShade setgray newpath
    -1 DimY 1 add 0.5 mul HexCenterPoint moveto
    1 DimY HexCenterPoint lineto
    DimX 1 add 0.5 mul DimY 2 add HexCenterPoint lineto
    DimX DimY HexCenterPoint lineto
    DimX 2 add DimY 1 add 0.5 mul HexCenterPoint lineto
    DimX 1 HexCenterPoint lineto
    DimX 1 add 0.5 mul -1 HexCenterPoint lineto
    1 1 HexCenterPoint lineto
    closepath fill 0 setgray
    1 DimY HexCenterPoint moveto
    1 1 DimX { /i exch def 
        i 1 i DimY HexLine 
        DimY 1 add 0.5 mul -1 i 1 HexLine
        DimY 1 add 0.5 mul DimY 2 add i DimY HexLine } for
    1 1 DimY { /j exch def 
        1 j DimX j HexLine 
        -1 DimX 1 add 0.5 mul 1 j HexLine
        DimX 2 add DimX 1 add 0.5 mul DimX j HexLine } for
    /topx 1 def /topy 1 def /btmx 1 def /btmy 1 def
    DimX DimY add 3 sub {
      topx DimX lt {/topx 1 topx add def}{/topy 1 topy add def} ifelse 
      btmy DimY lt {/btmy 1 btmy add def}{/btmx 1 btmx add def} ifelse 
      topx topy btmx btmy HexLine
      } repeat
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j HexVertex
	} for } for
    grestore
end } def

/DrawHavannahBoard { 3 dict begin
    /Base DimX 1 add 2 idiv  def
    gsave
    HavannahBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 Base { /j exch def
	Base j 1 sub sub 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    1 1 Base 1 sub { /j exch def
	1 1 DimX j sub { /i exch def
	   i j Base add 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexBorder{ 6 dict begin /start exch def 
    /cells exch def /isBlack exch def /which exch def
    gsave
    which UpLeft eq {1 DimY 1 add start sub Up HxgnCorner moveto /d Left def /r 60 def} if
    which UpRight eq {start DimY Up HxgnCorner moveto /d Right def /r 300 def} if
    which DownLeft eq {DimX 1 add start sub 1 Down HxgnCorner moveto /d Left def /r 300 def} if
    which DownRight eq {DimX start Down HxgnCorner moveto /d Right def /r 60 def} if
    0.5 d Go 
    which UpRight eq which DownRight eq or {180 rotate} if
    r TurnGo 
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.5 360 r sub MagTurnGo 1.5 360 r sub 2 mul MagTurnGo
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.75 360 r sub MagTurnGo
    closepath isBlack 1 eq {gsave fill grestore} if stroke grestore
end } def

/NoDrawHexBoard {  % dummy, used in creating bounding box
} def

/HexBoardBorders { 1 dict begin
    /upperLeftBlack exch def
    PerimeterWidth setlinewidth 0 setgray
    UpLeft    upperLeftBlack       DimY 1 DrawHexBorder
    UpRight   1 upperLeftBlack sub DimX 1 DrawHexBorder
    DownRight upperLeftBlack       DimY 1 DrawHexBorder
    DownLeft  1 upperLeftBlack sub DimX 1 DrawHexBorder
end } def

/YBoardPerimeter {
    newpath 1 1 DownRight HxgnCorner moveto 180 rotate
    3 { DimX 1 sub { 300 TurnGo 60 TurnGo } repeat 
        60 TurnGo 60 TurnGo} 
    repeat % now restore initial rotation state
    180 rotate % closepath
} def

/DrawYBoard { 2 dict begin
    YBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimX {/j exch def
        1 1 DimX 1 add j sub {/i exch def
	    i j 1 SemiHexagonPath stroke
        } for } for
end } def

/FontSelect { % bold italic FontSelect
    2 dict begin /italic exch def /bold exch def
    bold {
	italic 
	{ /Times-BoldItalic findfont TextHeight scalefont setfont } 
	{ /Times-Bold findfont TextHeight scalefont setfont }
	ifelse} 
        {
	italic {/Times-Italic findfont TextHeight scalefont setfont} 
	{ /Times findfont TextHeight scalefont setfont }
	ifelse}
    ifelse
end } def
	    
/LabelString {   % call: i j (str) strlen LabelString
%  to use with board rotation, remove comments
    6 dict begin /strlen exch def /str exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint /y exch def /x exch def
    %BoardRotation rotate
    x y moveto 
    %360 BoardRotation sub rotate
    TextWidth strlen mul 0.5 mul neg TextHeight 0.33 mul neg rmoveto
    str show 
end } def

/AbsLabelString { 4 dict begin
    /strlen exch def /str exch def /y exch def /x exch def
    newpath
    x AbsCoordX TextWidth strlen mul 0.5 mul sub
    y AbsCoordY TextHeight 0.33 mul sub
    moveto
    str
    show
end } def

/LabelStringVerb { % i j (str) strlen shade bold italic LabelStringVerb
    7 dict begin /italic exch def /bold exch def /shade exch def
    /strlen exch def /str exch def /j exch def /i exch def
    bold italic FontSelect shade setgray
    i j str strlen LabelString
end } def

/HexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimX { /i exch def
	i 0          Chars i 1 sub get 1 LabelString
	i DimY 1 add Chars i 1 sub get 1 LabelString
    } for
    1 1 DimY { /j exch def
	0 j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
	DimX 1 add j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HavannahBoardCoordinates { 3 dict begin
    false true FontSelect CoordinatesShade setgray
    /Base DimX 1 add 2 idiv  def
    1 1 Base { /i exch def
	i 0 HavannahPosn Chars  i 1 sub get 1 LabelString
	0 i HavannahPosn Digits i 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
    1 1 Base 1 sub { /i exch def
	i Base add i HavannahPosn Chars  i Base add 1 sub get 1 LabelString
	i i Base add HavannahPosn Digits i Base add 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/AltHexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimY { /j exch def
	0 j Chars j 1 sub get 1 LabelString
        %DimX 1 add j Chars j 1 sub get 1 LabelString
    } for
    1 1 DimX { /i exch def
	i 0 Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
	%i DimY 1 add Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HexDot { 3 dict begin /size exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint size 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexWhiteMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexWhitePiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexBlackMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexBlackPiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    1 setgray 0 setlinewidth fill
end } def

/HexDoubleMarker { 6 dict begin
    /shaderight exch def /shadeleft exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    gsave
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    shadeleft setgray 0 setlinewidth fill
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    shaderight setgray 0 setlinewidth fill
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    grestore
end } def

/HexBlackWhiteMarker { 0.0 1.0 HexDoubleMarker } def

/HexWhiteBlackMarker { 1.0 0.0 HexDoubleMarker } def
        
/HexMarker { 2 dict begin /j exch def /i exch def
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setlinewidth fill
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke  
end } def

/HexBlackMarker { 2 dict begin /j exch def /i exch def
    0 setgray
    i j HexMarker
end } def

/HexWhiteMarker { 2 dict begin /j exch def /i exch def
    1 setgray
    i j HexMarker
end } def
    
/HexPiece { 3 dict begin /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/MagicStone { 4 dict begin 
    /size exch def /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 1.3 mul size mul 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/HexWhitePiece { 1.0 HexPiece } def

/HexBlackPiece { 0.0 HexPiece } def

/HexWhiteLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def
    i j HexWhitePiece
    i j str strlen 0.0 true true LabelStringVerb
end } def

/HexBlackLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def 
    i j HexBlackPiece
    i j str strlen 1.0 true true LabelStringVerb
end } def

/AbsCoordX { 1 dict begin /x exch def
    OriginX x Scale mul add
end } def

/AbsCoordY { 1 dict begin /y exch def
    OriginY y Scale mul add
end } def

/DrawBox { /maxy exch def /maxx exch def /miny exch def /minx exch def
    newpath
    minx miny moveto
    maxx minx sub 0 rlineto
    0 maxy miny sub rlineto
    minx maxx sub 0 rlineto
    0 miny maxy sub rlineto
    HexLineWidth setlinewidth
    0 setgray
    stroke
} def

/HexVertex { 2 dict begin /j exch def /i exch def
    i j GraphVertexSize HexDot
end } def

/HexLine { 4 dict begin /j2 exch def /i2 exch def /j1 exch def /i1 exch def
    GraphLineWidth setlinewidth
    0 setgray
    newpath
    i1 j1 HexCenterPoint moveto
    i2 j2 HexCenterPoint lineto
    stroke
end } def

%%---------------- Program -------------------


FlatTopBoard
DrawHexBoard
1 HexBoardBorders


%------------ Trailer --------------

showpage

%%EndDocument
 @endspecial 1900 w @beginspecial 0 @llx 0 @lly 66 @urx
47 @ury 1133 @rwi @setspecial
%%BeginDocument: fz/pix/4x4.eps
%!PS-Adobe-3.0
%%Creator: Jack van Rijswijck, thanks to Cameron Browne
%%BoundingBox: 0 0 66 47
%%Pages: 0
%%EndComments

/OriginX -6 def
/OriginY 36 def
%---------------- Variables -------------------

/DimX 4 def
/DimY 4 def
/Scale 1.2 def


% draw  Hex boards, any size ... but labels only up to 26x26
% based on code by Cameron Browne, revised by Jack vR, revised by RBH
%-------------- state initializations -------------------------
1 setlinejoin   % lines meet at a point  ==>    use round join
%---------------- constants -------------------
/Root3Div2  0.86602540378444 def
/Chars   {[(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)
           (n)(o)(p)(q)(r)(s)(t)(u)(v)(w)(x)(y)(z)]} def
/CharsUC {[(A)(B)(C)(D)(E)(F)(G)(H)(I)(J)(K)(L)(M)
           (N)(O)(P)(Q)(R)(S)(T)(U)(V)(W)(X)(Y)(Z)]} def
/Digits  {[(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)(12)(13)
           (14)(15)(16)(17)(18)(19)(20)(21)(22)(23)(24)(25)(26)]} def
/HexRadius      5 Scale mul def % hexagon center-to-corner distance 
/HexLineWidth 0.1 Scale mul def 
/GraphVertexSize 1.0 Scale mul def
/GraphLineWidth 0.5 Scale mul def
/CircleRadius 3.0 Scale mul def 
/CircleLineWidth 0.346 Scale mul def 
/PerimeterWidth 0.5 Scale mul def 
/TextHeight 4.5 def
/TextWidth TextHeight 0.45 mul def 
/BoardShade 0.8 def
/CoordinatesShade 0.5 def
/MarkerSize 1.2 def
/CellOrientation 1 def   % 1: flat bottom  0: pointed bottom
/CellCorner [ % 6 cell corners, wrt center 0 0, plus "up" and "down"
   [ HexRadius  neg       0                           ] 
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul neg ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul neg ]
   [ HexRadius            0                           ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul     ]
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul neg ]
] def
%----- name cell corner indices ... see below
/Left  0 def /DownLeft 1 def /DownRight 2 def 
/Right 3 def /UpRight  4 def /UpLeft    5 def 
/Up    6 def /Down     7 def
%-----------------------------------------------------
% cell orientations:  flat bottom    flat side
%-----------------------------------------------------
% flat bottom 
% board cell indices            cell corner/top/bottom indices
%             --
%           /    \
%        --   1,3  --                  5 -6- 4
%      /    \    /    \               /       \
%   --   1,2  --   2,3  --           0         3
% /    \    /    \    /    \          \       /
%   1,1  --   2,2  --   3,3            1 -7- 2
% \    /    \    /    \    /
%   --   2,1  --   3,2  --
%      \    /    \    /   
%        --   3,1  --     
%----------------------------------------------------
% flat side 
%    /  \  /  \  /  \                       5
%   | 11 || 12 || 13 ||                   /   6
%    \  /  \  /  \  /  \                 0     4
%     || 21 || 22 || 23 |                |     |
%       \  /  \  /  \  /  \              1     3
%        || 31 || 32 || 33 |              7   /
%-------------------------------------------2--------
%----------- procedures -------------
/ScalePoint { % stack: ... x y size ==> ...  x*size y*size
   3 dict begin /size exch def /y exch def /x exch def
   x size mul           y size mul
end } def

/FlatTopBoard { FlatSideCells } def

/FlatSideCells {  % redefine cell orientation for flat side
  /CellOrientation 0 def   
  /CellCorner [ % 6 cell corners, wrt center 0 0  %xcoord ycoord
    [HexRadius Root3Div2 mul neg  HexRadius 2 div     ]
    [HexRadius Root3Div2 mul neg  HexRadius 2 div neg ]
    [0                            HexRadius neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div ]
    [0                            HexRadius ]
    [HexRadius Root3Div2 2 div mul HexRadius 0.75 mul ]
    [HexRadius Root3Div2 2 div mul neg HexRadius 0.75 mul neg ]
  ] def
} def

/HexCenterPoint { % center of cell (i,j)
    2 dict begin /j exch def /i exch def
    CellOrientation 1 eq {
    OriginX i j add HexRadius mul 1.5 mul add %Ox + (i+j)*HR*1.5
    OriginY i j sub HexRadius mul Root3Div2 mul sub %Oy - (i-j)*HR*R3/2
    }{
    OriginX i 2 j mul add HexRadius mul Root3Div2 mul add  %Ox + (2i+j)*HR
    OriginY i 1 sub HexRadius mul 1.5 mul sub %Oy - i*HR*R3/2
    } ifelse
end } def
 
/HexLine { % a b c d
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint lineto
    stroke
} def

/HexCurve { % a b c d e f
    /f exch def
    /e exch def
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint e f HexCenterPoint HexRadius 2 mul arcto
    e f HexCenterPoint lineto
    stroke
} def

/HxgnCorner { 5 dict begin /corn exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    x CellCorner corn get 0 get add
    y CellCorner corn get 1 get add
end } def

/Go { 2 dict begin /corn exch def /mag exch def
   % rlineto in a cell orientation direction
   CellCorner corn get aload pop mag ScalePoint rlineto
end } def

/TurnGo { rotate 1.0 Left Go } def % call: degrees TurnGo
/MagTurnGo { rotate Left Go } def % call: mag degrees TurnGo

/HexagonPath { % call: i j HexagonPath
    newpath 
    UpRight HxgnCorner moveto 
    6 { 1.0 Left Go 60 rotate } repeat 
} def

/FillAndStroke { 2 dict begin /sh exch def /wdth exch def
    gsave sh setgray fill
    grestore 0 setgray wdth setlinewidth stroke
end } def

/ShadedHexagon { 3 dict begin /shade exch def /j exch def /i exch def
    i j HexagonPath
    0 shade FillAndStroke
end } def

/Hexagon { % stack: ... i j
    HexagonPath 
    HexLineWidth BoardShade FillAndStroke
} def

/SemiHexagonPath { % stack: ... top i j
    newpath 
    1 eq { Left HxgnCorner moveto 
        1.0 UpRight Go 1.0 Right Go 1.0 DownRight Go stroke }{
        Right HxgnCorner moveto 
        1.0 DownLeft Go 1.0 Left Go 1.0 UpLeft Go stroke
    } ifelse
} def

/HexBoardPerimeter {
    newpath
    1 DimY UpRight HxgnCorner moveto 1.0 Left Go                      
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 rotate %restore rotation
} def

%----------- Havannah coordinates ----------------------
%                   ..  ..  ..
%                 d1  c2  b3  a4
%                   c1  b2  a3
%                     b1  a2
%                       a1
/HavannahPosn { % convert to usual coordinate, so ... x y  =>  ... 1+DimX-x  y
    exch DimX 1 add exch sub exch 
} def

/HavannahBoardPerimeter {
    newpath
    1 DimX UpRight HxgnCorner moveto 1.0 Left Go                      
    6 {Base 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo } repeat
} def

/DrawHexBoard { 2 dict begin
    gsave
    HexBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexPLBoard { 6 dict begin %point-line board
    gsave
    BoardShade setgray newpath
    -1 DimY 1 add 0.5 mul HexCenterPoint moveto
    1 DimY HexCenterPoint lineto
    DimX 1 add 0.5 mul DimY 2 add HexCenterPoint lineto
    DimX DimY HexCenterPoint lineto
    DimX 2 add DimY 1 add 0.5 mul HexCenterPoint lineto
    DimX 1 HexCenterPoint lineto
    DimX 1 add 0.5 mul -1 HexCenterPoint lineto
    1 1 HexCenterPoint lineto
    closepath fill 0 setgray
    1 DimY HexCenterPoint moveto
    1 1 DimX { /i exch def 
        i 1 i DimY HexLine 
        DimY 1 add 0.5 mul -1 i 1 HexLine
        DimY 1 add 0.5 mul DimY 2 add i DimY HexLine } for
    1 1 DimY { /j exch def 
        1 j DimX j HexLine 
        -1 DimX 1 add 0.5 mul 1 j HexLine
        DimX 2 add DimX 1 add 0.5 mul DimX j HexLine } for
    /topx 1 def /topy 1 def /btmx 1 def /btmy 1 def
    DimX DimY add 3 sub {
      topx DimX lt {/topx 1 topx add def}{/topy 1 topy add def} ifelse 
      btmy DimY lt {/btmy 1 btmy add def}{/btmx 1 btmx add def} ifelse 
      topx topy btmx btmy HexLine
      } repeat
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j HexVertex
	} for } for
    grestore
end } def

/DrawHavannahBoard { 3 dict begin
    /Base DimX 1 add 2 idiv  def
    gsave
    HavannahBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 Base { /j exch def
	Base j 1 sub sub 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    1 1 Base 1 sub { /j exch def
	1 1 DimX j sub { /i exch def
	   i j Base add 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexBorder{ 6 dict begin /start exch def 
    /cells exch def /isBlack exch def /which exch def
    gsave
    which UpLeft eq {1 DimY 1 add start sub Up HxgnCorner moveto /d Left def /r 60 def} if
    which UpRight eq {start DimY Up HxgnCorner moveto /d Right def /r 300 def} if
    which DownLeft eq {DimX 1 add start sub 1 Down HxgnCorner moveto /d Left def /r 300 def} if
    which DownRight eq {DimX start Down HxgnCorner moveto /d Right def /r 60 def} if
    0.5 d Go 
    which UpRight eq which DownRight eq or {180 rotate} if
    r TurnGo 
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.5 360 r sub MagTurnGo 1.5 360 r sub 2 mul MagTurnGo
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.75 360 r sub MagTurnGo
    closepath isBlack 1 eq {gsave fill grestore} if stroke grestore
end } def

/NoDrawHexBoard {  % dummy, used in creating bounding box
} def

/HexBoardBorders { 1 dict begin
    /upperLeftBlack exch def
    PerimeterWidth setlinewidth 0 setgray
    UpLeft    upperLeftBlack       DimY 1 DrawHexBorder
    UpRight   1 upperLeftBlack sub DimX 1 DrawHexBorder
    DownRight upperLeftBlack       DimY 1 DrawHexBorder
    DownLeft  1 upperLeftBlack sub DimX 1 DrawHexBorder
end } def

/YBoardPerimeter {
    newpath 1 1 DownRight HxgnCorner moveto 180 rotate
    3 { DimX 1 sub { 300 TurnGo 60 TurnGo } repeat 
        60 TurnGo 60 TurnGo} 
    repeat % now restore initial rotation state
    180 rotate % closepath
} def

/DrawYBoard { 2 dict begin
    YBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimX {/j exch def
        1 1 DimX 1 add j sub {/i exch def
	    i j 1 SemiHexagonPath stroke
        } for } for
end } def

/FontSelect { % bold italic FontSelect
    2 dict begin /italic exch def /bold exch def
    bold {
	italic 
	{ /Times-BoldItalic findfont TextHeight scalefont setfont } 
	{ /Times-Bold findfont TextHeight scalefont setfont }
	ifelse} 
        {
	italic {/Times-Italic findfont TextHeight scalefont setfont} 
	{ /Times findfont TextHeight scalefont setfont }
	ifelse}
    ifelse
end } def
	    
/LabelString {   % call: i j (str) strlen LabelString
%  to use with board rotation, remove comments
    6 dict begin /strlen exch def /str exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint /y exch def /x exch def
    %BoardRotation rotate
    x y moveto 
    %360 BoardRotation sub rotate
    TextWidth strlen mul 0.5 mul neg TextHeight 0.33 mul neg rmoveto
    str show 
end } def

/AbsLabelString { 4 dict begin
    /strlen exch def /str exch def /y exch def /x exch def
    newpath
    x AbsCoordX TextWidth strlen mul 0.5 mul sub
    y AbsCoordY TextHeight 0.33 mul sub
    moveto
    str
    show
end } def

/LabelStringVerb { % i j (str) strlen shade bold italic LabelStringVerb
    7 dict begin /italic exch def /bold exch def /shade exch def
    /strlen exch def /str exch def /j exch def /i exch def
    bold italic FontSelect shade setgray
    i j str strlen LabelString
end } def

/HexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimX { /i exch def
	i 0          Chars i 1 sub get 1 LabelString
	i DimY 1 add Chars i 1 sub get 1 LabelString
    } for
    1 1 DimY { /j exch def
	0 j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
	DimX 1 add j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HavannahBoardCoordinates { 3 dict begin
    false true FontSelect CoordinatesShade setgray
    /Base DimX 1 add 2 idiv  def
    1 1 Base { /i exch def
	i 0 HavannahPosn Chars  i 1 sub get 1 LabelString
	0 i HavannahPosn Digits i 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
    1 1 Base 1 sub { /i exch def
	i Base add i HavannahPosn Chars  i Base add 1 sub get 1 LabelString
	i i Base add HavannahPosn Digits i Base add 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/AltHexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimY { /j exch def
	0 j Chars j 1 sub get 1 LabelString
        %DimX 1 add j Chars j 1 sub get 1 LabelString
    } for
    1 1 DimX { /i exch def
	i 0 Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
	%i DimY 1 add Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HexDot { 3 dict begin /size exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint size 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexWhiteMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexWhitePiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexBlackMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexBlackPiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    1 setgray 0 setlinewidth fill
end } def

/HexDoubleMarker { 6 dict begin
    /shaderight exch def /shadeleft exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    gsave
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    shadeleft setgray 0 setlinewidth fill
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    shaderight setgray 0 setlinewidth fill
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    grestore
end } def

/HexBlackWhiteMarker { 0.0 1.0 HexDoubleMarker } def

/HexWhiteBlackMarker { 1.0 0.0 HexDoubleMarker } def
        
/HexMarker { 2 dict begin /j exch def /i exch def
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setlinewidth fill
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke  
end } def

/HexBlackMarker { 2 dict begin /j exch def /i exch def
    0 setgray
    i j HexMarker
end } def

/HexWhiteMarker { 2 dict begin /j exch def /i exch def
    1 setgray
    i j HexMarker
end } def
    
/HexPiece { 3 dict begin /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/MagicStone { 4 dict begin 
    /size exch def /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 1.3 mul size mul 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/HexWhitePiece { 1.0 HexPiece } def

/HexBlackPiece { 0.0 HexPiece } def

/HexWhiteLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def
    i j HexWhitePiece
    i j str strlen 0.0 true true LabelStringVerb
end } def

/HexBlackLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def 
    i j HexBlackPiece
    i j str strlen 1.0 true true LabelStringVerb
end } def

/AbsCoordX { 1 dict begin /x exch def
    OriginX x Scale mul add
end } def

/AbsCoordY { 1 dict begin /y exch def
    OriginY y Scale mul add
end } def

/DrawBox { /maxy exch def /maxx exch def /miny exch def /minx exch def
    newpath
    minx miny moveto
    maxx minx sub 0 rlineto
    0 maxy miny sub rlineto
    minx maxx sub 0 rlineto
    0 miny maxy sub rlineto
    HexLineWidth setlinewidth
    0 setgray
    stroke
} def

/HexVertex { 2 dict begin /j exch def /i exch def
    i j GraphVertexSize HexDot
end } def

/HexLine { 4 dict begin /j2 exch def /i2 exch def /j1 exch def /i1 exch def
    GraphLineWidth setlinewidth
    0 setgray
    newpath
    i1 j1 HexCenterPoint moveto
    i2 j2 HexCenterPoint lineto
    stroke
end } def

%%---------------- Program -------------------


FlatTopBoard
DrawHexBoard
1 HexBoardBorders


%------------ Trailer --------------

showpage

%%EndDocument
 @endspecial 1900 w @beginspecial 0 @llx 0 @lly 66 @urx
47 @ury 1133 @rwi @setspecial
%%BeginDocument: fz/pix/4x4.eps
%!PS-Adobe-3.0
%%Creator: Jack van Rijswijck, thanks to Cameron Browne
%%BoundingBox: 0 0 66 47
%%Pages: 0
%%EndComments

/OriginX -6 def
/OriginY 36 def
%---------------- Variables -------------------

/DimX 4 def
/DimY 4 def
/Scale 1.2 def


% draw  Hex boards, any size ... but labels only up to 26x26
% based on code by Cameron Browne, revised by Jack vR, revised by RBH
%-------------- state initializations -------------------------
1 setlinejoin   % lines meet at a point  ==>    use round join
%---------------- constants -------------------
/Root3Div2  0.86602540378444 def
/Chars   {[(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)
           (n)(o)(p)(q)(r)(s)(t)(u)(v)(w)(x)(y)(z)]} def
/CharsUC {[(A)(B)(C)(D)(E)(F)(G)(H)(I)(J)(K)(L)(M)
           (N)(O)(P)(Q)(R)(S)(T)(U)(V)(W)(X)(Y)(Z)]} def
/Digits  {[(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)(12)(13)
           (14)(15)(16)(17)(18)(19)(20)(21)(22)(23)(24)(25)(26)]} def
/HexRadius      5 Scale mul def % hexagon center-to-corner distance 
/HexLineWidth 0.1 Scale mul def 
/GraphVertexSize 1.0 Scale mul def
/GraphLineWidth 0.5 Scale mul def
/CircleRadius 3.0 Scale mul def 
/CircleLineWidth 0.346 Scale mul def 
/PerimeterWidth 0.5 Scale mul def 
/TextHeight 4.5 def
/TextWidth TextHeight 0.45 mul def 
/BoardShade 0.8 def
/CoordinatesShade 0.5 def
/MarkerSize 1.2 def
/CellOrientation 1 def   % 1: flat bottom  0: pointed bottom
/CellCorner [ % 6 cell corners, wrt center 0 0, plus "up" and "down"
   [ HexRadius  neg       0                           ] 
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul neg ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul neg ]
   [ HexRadius            0                           ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul     ]
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul neg ]
] def
%----- name cell corner indices ... see below
/Left  0 def /DownLeft 1 def /DownRight 2 def 
/Right 3 def /UpRight  4 def /UpLeft    5 def 
/Up    6 def /Down     7 def
%-----------------------------------------------------
% cell orientations:  flat bottom    flat side
%-----------------------------------------------------
% flat bottom 
% board cell indices            cell corner/top/bottom indices
%             --
%           /    \
%        --   1,3  --                  5 -6- 4
%      /    \    /    \               /       \
%   --   1,2  --   2,3  --           0         3
% /    \    /    \    /    \          \       /
%   1,1  --   2,2  --   3,3            1 -7- 2
% \    /    \    /    \    /
%   --   2,1  --   3,2  --
%      \    /    \    /   
%        --   3,1  --     
%----------------------------------------------------
% flat side 
%    /  \  /  \  /  \                       5
%   | 11 || 12 || 13 ||                   /   6
%    \  /  \  /  \  /  \                 0     4
%     || 21 || 22 || 23 |                |     |
%       \  /  \  /  \  /  \              1     3
%        || 31 || 32 || 33 |              7   /
%-------------------------------------------2--------
%----------- procedures -------------
/ScalePoint { % stack: ... x y size ==> ...  x*size y*size
   3 dict begin /size exch def /y exch def /x exch def
   x size mul           y size mul
end } def

/FlatTopBoard { FlatSideCells } def

/FlatSideCells {  % redefine cell orientation for flat side
  /CellOrientation 0 def   
  /CellCorner [ % 6 cell corners, wrt center 0 0  %xcoord ycoord
    [HexRadius Root3Div2 mul neg  HexRadius 2 div     ]
    [HexRadius Root3Div2 mul neg  HexRadius 2 div neg ]
    [0                            HexRadius neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div ]
    [0                            HexRadius ]
    [HexRadius Root3Div2 2 div mul HexRadius 0.75 mul ]
    [HexRadius Root3Div2 2 div mul neg HexRadius 0.75 mul neg ]
  ] def
} def

/HexCenterPoint { % center of cell (i,j)
    2 dict begin /j exch def /i exch def
    CellOrientation 1 eq {
    OriginX i j add HexRadius mul 1.5 mul add %Ox + (i+j)*HR*1.5
    OriginY i j sub HexRadius mul Root3Div2 mul sub %Oy - (i-j)*HR*R3/2
    }{
    OriginX i 2 j mul add HexRadius mul Root3Div2 mul add  %Ox + (2i+j)*HR
    OriginY i 1 sub HexRadius mul 1.5 mul sub %Oy - i*HR*R3/2
    } ifelse
end } def
 
/HexLine { % a b c d
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint lineto
    stroke
} def

/HexCurve { % a b c d e f
    /f exch def
    /e exch def
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint e f HexCenterPoint HexRadius 2 mul arcto
    e f HexCenterPoint lineto
    stroke
} def

/HxgnCorner { 5 dict begin /corn exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    x CellCorner corn get 0 get add
    y CellCorner corn get 1 get add
end } def

/Go { 2 dict begin /corn exch def /mag exch def
   % rlineto in a cell orientation direction
   CellCorner corn get aload pop mag ScalePoint rlineto
end } def

/TurnGo { rotate 1.0 Left Go } def % call: degrees TurnGo
/MagTurnGo { rotate Left Go } def % call: mag degrees TurnGo

/HexagonPath { % call: i j HexagonPath
    newpath 
    UpRight HxgnCorner moveto 
    6 { 1.0 Left Go 60 rotate } repeat 
} def

/FillAndStroke { 2 dict begin /sh exch def /wdth exch def
    gsave sh setgray fill
    grestore 0 setgray wdth setlinewidth stroke
end } def

/ShadedHexagon { 3 dict begin /shade exch def /j exch def /i exch def
    i j HexagonPath
    0 shade FillAndStroke
end } def

/Hexagon { % stack: ... i j
    HexagonPath 
    HexLineWidth BoardShade FillAndStroke
} def

/SemiHexagonPath { % stack: ... top i j
    newpath 
    1 eq { Left HxgnCorner moveto 
        1.0 UpRight Go 1.0 Right Go 1.0 DownRight Go stroke }{
        Right HxgnCorner moveto 
        1.0 DownLeft Go 1.0 Left Go 1.0 UpLeft Go stroke
    } ifelse
} def

/HexBoardPerimeter {
    newpath
    1 DimY UpRight HxgnCorner moveto 1.0 Left Go                      
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 rotate %restore rotation
} def

%----------- Havannah coordinates ----------------------
%                   ..  ..  ..
%                 d1  c2  b3  a4
%                   c1  b2  a3
%                     b1  a2
%                       a1
/HavannahPosn { % convert to usual coordinate, so ... x y  =>  ... 1+DimX-x  y
    exch DimX 1 add exch sub exch 
} def

/HavannahBoardPerimeter {
    newpath
    1 DimX UpRight HxgnCorner moveto 1.0 Left Go                      
    6 {Base 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo } repeat
} def

/DrawHexBoard { 2 dict begin
    gsave
    HexBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexPLBoard { 6 dict begin %point-line board
    gsave
    BoardShade setgray newpath
    -1 DimY 1 add 0.5 mul HexCenterPoint moveto
    1 DimY HexCenterPoint lineto
    DimX 1 add 0.5 mul DimY 2 add HexCenterPoint lineto
    DimX DimY HexCenterPoint lineto
    DimX 2 add DimY 1 add 0.5 mul HexCenterPoint lineto
    DimX 1 HexCenterPoint lineto
    DimX 1 add 0.5 mul -1 HexCenterPoint lineto
    1 1 HexCenterPoint lineto
    closepath fill 0 setgray
    1 DimY HexCenterPoint moveto
    1 1 DimX { /i exch def 
        i 1 i DimY HexLine 
        DimY 1 add 0.5 mul -1 i 1 HexLine
        DimY 1 add 0.5 mul DimY 2 add i DimY HexLine } for
    1 1 DimY { /j exch def 
        1 j DimX j HexLine 
        -1 DimX 1 add 0.5 mul 1 j HexLine
        DimX 2 add DimX 1 add 0.5 mul DimX j HexLine } for
    /topx 1 def /topy 1 def /btmx 1 def /btmy 1 def
    DimX DimY add 3 sub {
      topx DimX lt {/topx 1 topx add def}{/topy 1 topy add def} ifelse 
      btmy DimY lt {/btmy 1 btmy add def}{/btmx 1 btmx add def} ifelse 
      topx topy btmx btmy HexLine
      } repeat
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j HexVertex
	} for } for
    grestore
end } def

/DrawHavannahBoard { 3 dict begin
    /Base DimX 1 add 2 idiv  def
    gsave
    HavannahBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 Base { /j exch def
	Base j 1 sub sub 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    1 1 Base 1 sub { /j exch def
	1 1 DimX j sub { /i exch def
	   i j Base add 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexBorder{ 6 dict begin /start exch def 
    /cells exch def /isBlack exch def /which exch def
    gsave
    which UpLeft eq {1 DimY 1 add start sub Up HxgnCorner moveto /d Left def /r 60 def} if
    which UpRight eq {start DimY Up HxgnCorner moveto /d Right def /r 300 def} if
    which DownLeft eq {DimX 1 add start sub 1 Down HxgnCorner moveto /d Left def /r 300 def} if
    which DownRight eq {DimX start Down HxgnCorner moveto /d Right def /r 60 def} if
    0.5 d Go 
    which UpRight eq which DownRight eq or {180 rotate} if
    r TurnGo 
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.5 360 r sub MagTurnGo 1.5 360 r sub 2 mul MagTurnGo
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.75 360 r sub MagTurnGo
    closepath isBlack 1 eq {gsave fill grestore} if stroke grestore
end } def

/NoDrawHexBoard {  % dummy, used in creating bounding box
} def

/HexBoardBorders { 1 dict begin
    /upperLeftBlack exch def
    PerimeterWidth setlinewidth 0 setgray
    UpLeft    upperLeftBlack       DimY 1 DrawHexBorder
    UpRight   1 upperLeftBlack sub DimX 1 DrawHexBorder
    DownRight upperLeftBlack       DimY 1 DrawHexBorder
    DownLeft  1 upperLeftBlack sub DimX 1 DrawHexBorder
end } def

/YBoardPerimeter {
    newpath 1 1 DownRight HxgnCorner moveto 180 rotate
    3 { DimX 1 sub { 300 TurnGo 60 TurnGo } repeat 
        60 TurnGo 60 TurnGo} 
    repeat % now restore initial rotation state
    180 rotate % closepath
} def

/DrawYBoard { 2 dict begin
    YBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimX {/j exch def
        1 1 DimX 1 add j sub {/i exch def
	    i j 1 SemiHexagonPath stroke
        } for } for
end } def

/FontSelect { % bold italic FontSelect
    2 dict begin /italic exch def /bold exch def
    bold {
	italic 
	{ /Times-BoldItalic findfont TextHeight scalefont setfont } 
	{ /Times-Bold findfont TextHeight scalefont setfont }
	ifelse} 
        {
	italic {/Times-Italic findfont TextHeight scalefont setfont} 
	{ /Times findfont TextHeight scalefont setfont }
	ifelse}
    ifelse
end } def
	    
/LabelString {   % call: i j (str) strlen LabelString
%  to use with board rotation, remove comments
    6 dict begin /strlen exch def /str exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint /y exch def /x exch def
    %BoardRotation rotate
    x y moveto 
    %360 BoardRotation sub rotate
    TextWidth strlen mul 0.5 mul neg TextHeight 0.33 mul neg rmoveto
    str show 
end } def

/AbsLabelString { 4 dict begin
    /strlen exch def /str exch def /y exch def /x exch def
    newpath
    x AbsCoordX TextWidth strlen mul 0.5 mul sub
    y AbsCoordY TextHeight 0.33 mul sub
    moveto
    str
    show
end } def

/LabelStringVerb { % i j (str) strlen shade bold italic LabelStringVerb
    7 dict begin /italic exch def /bold exch def /shade exch def
    /strlen exch def /str exch def /j exch def /i exch def
    bold italic FontSelect shade setgray
    i j str strlen LabelString
end } def

/HexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimX { /i exch def
	i 0          Chars i 1 sub get 1 LabelString
	i DimY 1 add Chars i 1 sub get 1 LabelString
    } for
    1 1 DimY { /j exch def
	0 j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
	DimX 1 add j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HavannahBoardCoordinates { 3 dict begin
    false true FontSelect CoordinatesShade setgray
    /Base DimX 1 add 2 idiv  def
    1 1 Base { /i exch def
	i 0 HavannahPosn Chars  i 1 sub get 1 LabelString
	0 i HavannahPosn Digits i 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
    1 1 Base 1 sub { /i exch def
	i Base add i HavannahPosn Chars  i Base add 1 sub get 1 LabelString
	i i Base add HavannahPosn Digits i Base add 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/AltHexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimY { /j exch def
	0 j Chars j 1 sub get 1 LabelString
        %DimX 1 add j Chars j 1 sub get 1 LabelString
    } for
    1 1 DimX { /i exch def
	i 0 Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
	%i DimY 1 add Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HexDot { 3 dict begin /size exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint size 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexWhiteMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexWhitePiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexBlackMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexBlackPiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    1 setgray 0 setlinewidth fill
end } def

/HexDoubleMarker { 6 dict begin
    /shaderight exch def /shadeleft exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    gsave
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    shadeleft setgray 0 setlinewidth fill
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    shaderight setgray 0 setlinewidth fill
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    grestore
end } def

/HexBlackWhiteMarker { 0.0 1.0 HexDoubleMarker } def

/HexWhiteBlackMarker { 1.0 0.0 HexDoubleMarker } def
        
/HexMarker { 2 dict begin /j exch def /i exch def
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setlinewidth fill
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke  
end } def

/HexBlackMarker { 2 dict begin /j exch def /i exch def
    0 setgray
    i j HexMarker
end } def

/HexWhiteMarker { 2 dict begin /j exch def /i exch def
    1 setgray
    i j HexMarker
end } def
    
/HexPiece { 3 dict begin /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/MagicStone { 4 dict begin 
    /size exch def /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 1.3 mul size mul 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/HexWhitePiece { 1.0 HexPiece } def

/HexBlackPiece { 0.0 HexPiece } def

/HexWhiteLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def
    i j HexWhitePiece
    i j str strlen 0.0 true true LabelStringVerb
end } def

/HexBlackLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def 
    i j HexBlackPiece
    i j str strlen 1.0 true true LabelStringVerb
end } def

/AbsCoordX { 1 dict begin /x exch def
    OriginX x Scale mul add
end } def

/AbsCoordY { 1 dict begin /y exch def
    OriginY y Scale mul add
end } def

/DrawBox { /maxy exch def /maxx exch def /miny exch def /minx exch def
    newpath
    minx miny moveto
    maxx minx sub 0 rlineto
    0 maxy miny sub rlineto
    minx maxx sub 0 rlineto
    0 miny maxy sub rlineto
    HexLineWidth setlinewidth
    0 setgray
    stroke
} def

/HexVertex { 2 dict begin /j exch def /i exch def
    i j GraphVertexSize HexDot
end } def

/HexLine { 4 dict begin /j2 exch def /i2 exch def /j1 exch def /i1 exch def
    GraphLineWidth setlinewidth
    0 setgray
    newpath
    i1 j1 HexCenterPoint moveto
    i2 j2 HexCenterPoint lineto
    stroke
end } def

%%---------------- Program -------------------


FlatTopBoard
DrawHexBoard
1 HexBoardBorders


%------------ Trailer --------------

showpage

%%EndDocument
 @endspecial 563 7844 a @beginspecial 0 @llx 0 @lly 66
@urx 47 @ury 1133 @rwi @setspecial
%%BeginDocument: fz/pix/4x4.eps
%!PS-Adobe-3.0
%%Creator: Jack van Rijswijck, thanks to Cameron Browne
%%BoundingBox: 0 0 66 47
%%Pages: 0
%%EndComments

/OriginX -6 def
/OriginY 36 def
%---------------- Variables -------------------

/DimX 4 def
/DimY 4 def
/Scale 1.2 def


% draw  Hex boards, any size ... but labels only up to 26x26
% based on code by Cameron Browne, revised by Jack vR, revised by RBH
%-------------- state initializations -------------------------
1 setlinejoin   % lines meet at a point  ==>    use round join
%---------------- constants -------------------
/Root3Div2  0.86602540378444 def
/Chars   {[(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)
           (n)(o)(p)(q)(r)(s)(t)(u)(v)(w)(x)(y)(z)]} def
/CharsUC {[(A)(B)(C)(D)(E)(F)(G)(H)(I)(J)(K)(L)(M)
           (N)(O)(P)(Q)(R)(S)(T)(U)(V)(W)(X)(Y)(Z)]} def
/Digits  {[(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)(12)(13)
           (14)(15)(16)(17)(18)(19)(20)(21)(22)(23)(24)(25)(26)]} def
/HexRadius      5 Scale mul def % hexagon center-to-corner distance 
/HexLineWidth 0.1 Scale mul def 
/GraphVertexSize 1.0 Scale mul def
/GraphLineWidth 0.5 Scale mul def
/CircleRadius 3.0 Scale mul def 
/CircleLineWidth 0.346 Scale mul def 
/PerimeterWidth 0.5 Scale mul def 
/TextHeight 4.5 def
/TextWidth TextHeight 0.45 mul def 
/BoardShade 0.8 def
/CoordinatesShade 0.5 def
/MarkerSize 1.2 def
/CellOrientation 1 def   % 1: flat bottom  0: pointed bottom
/CellCorner [ % 6 cell corners, wrt center 0 0, plus "up" and "down"
   [ HexRadius  neg       0                           ] 
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul neg ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul neg ]
   [ HexRadius            0                           ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul     ]
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul neg ]
] def
%----- name cell corner indices ... see below
/Left  0 def /DownLeft 1 def /DownRight 2 def 
/Right 3 def /UpRight  4 def /UpLeft    5 def 
/Up    6 def /Down     7 def
%-----------------------------------------------------
% cell orientations:  flat bottom    flat side
%-----------------------------------------------------
% flat bottom 
% board cell indices            cell corner/top/bottom indices
%             --
%           /    \
%        --   1,3  --                  5 -6- 4
%      /    \    /    \               /       \
%   --   1,2  --   2,3  --           0         3
% /    \    /    \    /    \          \       /
%   1,1  --   2,2  --   3,3            1 -7- 2
% \    /    \    /    \    /
%   --   2,1  --   3,2  --
%      \    /    \    /   
%        --   3,1  --     
%----------------------------------------------------
% flat side 
%    /  \  /  \  /  \                       5
%   | 11 || 12 || 13 ||                   /   6
%    \  /  \  /  \  /  \                 0     4
%     || 21 || 22 || 23 |                |     |
%       \  /  \  /  \  /  \              1     3
%        || 31 || 32 || 33 |              7   /
%-------------------------------------------2--------
%----------- procedures -------------
/ScalePoint { % stack: ... x y size ==> ...  x*size y*size
   3 dict begin /size exch def /y exch def /x exch def
   x size mul           y size mul
end } def

/FlatTopBoard { FlatSideCells } def

/FlatSideCells {  % redefine cell orientation for flat side
  /CellOrientation 0 def   
  /CellCorner [ % 6 cell corners, wrt center 0 0  %xcoord ycoord
    [HexRadius Root3Div2 mul neg  HexRadius 2 div     ]
    [HexRadius Root3Div2 mul neg  HexRadius 2 div neg ]
    [0                            HexRadius neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div ]
    [0                            HexRadius ]
    [HexRadius Root3Div2 2 div mul HexRadius 0.75 mul ]
    [HexRadius Root3Div2 2 div mul neg HexRadius 0.75 mul neg ]
  ] def
} def

/HexCenterPoint { % center of cell (i,j)
    2 dict begin /j exch def /i exch def
    CellOrientation 1 eq {
    OriginX i j add HexRadius mul 1.5 mul add %Ox + (i+j)*HR*1.5
    OriginY i j sub HexRadius mul Root3Div2 mul sub %Oy - (i-j)*HR*R3/2
    }{
    OriginX i 2 j mul add HexRadius mul Root3Div2 mul add  %Ox + (2i+j)*HR
    OriginY i 1 sub HexRadius mul 1.5 mul sub %Oy - i*HR*R3/2
    } ifelse
end } def
 
/HexLine { % a b c d
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint lineto
    stroke
} def

/HexCurve { % a b c d e f
    /f exch def
    /e exch def
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint e f HexCenterPoint HexRadius 2 mul arcto
    e f HexCenterPoint lineto
    stroke
} def

/HxgnCorner { 5 dict begin /corn exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    x CellCorner corn get 0 get add
    y CellCorner corn get 1 get add
end } def

/Go { 2 dict begin /corn exch def /mag exch def
   % rlineto in a cell orientation direction
   CellCorner corn get aload pop mag ScalePoint rlineto
end } def

/TurnGo { rotate 1.0 Left Go } def % call: degrees TurnGo
/MagTurnGo { rotate Left Go } def % call: mag degrees TurnGo

/HexagonPath { % call: i j HexagonPath
    newpath 
    UpRight HxgnCorner moveto 
    6 { 1.0 Left Go 60 rotate } repeat 
} def

/FillAndStroke { 2 dict begin /sh exch def /wdth exch def
    gsave sh setgray fill
    grestore 0 setgray wdth setlinewidth stroke
end } def

/ShadedHexagon { 3 dict begin /shade exch def /j exch def /i exch def
    i j HexagonPath
    0 shade FillAndStroke
end } def

/Hexagon { % stack: ... i j
    HexagonPath 
    HexLineWidth BoardShade FillAndStroke
} def

/SemiHexagonPath { % stack: ... top i j
    newpath 
    1 eq { Left HxgnCorner moveto 
        1.0 UpRight Go 1.0 Right Go 1.0 DownRight Go stroke }{
        Right HxgnCorner moveto 
        1.0 DownLeft Go 1.0 Left Go 1.0 UpLeft Go stroke
    } ifelse
} def

/HexBoardPerimeter {
    newpath
    1 DimY UpRight HxgnCorner moveto 1.0 Left Go                      
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 rotate %restore rotation
} def

%----------- Havannah coordinates ----------------------
%                   ..  ..  ..
%                 d1  c2  b3  a4
%                   c1  b2  a3
%                     b1  a2
%                       a1
/HavannahPosn { % convert to usual coordinate, so ... x y  =>  ... 1+DimX-x  y
    exch DimX 1 add exch sub exch 
} def

/HavannahBoardPerimeter {
    newpath
    1 DimX UpRight HxgnCorner moveto 1.0 Left Go                      
    6 {Base 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo } repeat
} def

/DrawHexBoard { 2 dict begin
    gsave
    HexBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexPLBoard { 6 dict begin %point-line board
    gsave
    BoardShade setgray newpath
    -1 DimY 1 add 0.5 mul HexCenterPoint moveto
    1 DimY HexCenterPoint lineto
    DimX 1 add 0.5 mul DimY 2 add HexCenterPoint lineto
    DimX DimY HexCenterPoint lineto
    DimX 2 add DimY 1 add 0.5 mul HexCenterPoint lineto
    DimX 1 HexCenterPoint lineto
    DimX 1 add 0.5 mul -1 HexCenterPoint lineto
    1 1 HexCenterPoint lineto
    closepath fill 0 setgray
    1 DimY HexCenterPoint moveto
    1 1 DimX { /i exch def 
        i 1 i DimY HexLine 
        DimY 1 add 0.5 mul -1 i 1 HexLine
        DimY 1 add 0.5 mul DimY 2 add i DimY HexLine } for
    1 1 DimY { /j exch def 
        1 j DimX j HexLine 
        -1 DimX 1 add 0.5 mul 1 j HexLine
        DimX 2 add DimX 1 add 0.5 mul DimX j HexLine } for
    /topx 1 def /topy 1 def /btmx 1 def /btmy 1 def
    DimX DimY add 3 sub {
      topx DimX lt {/topx 1 topx add def}{/topy 1 topy add def} ifelse 
      btmy DimY lt {/btmy 1 btmy add def}{/btmx 1 btmx add def} ifelse 
      topx topy btmx btmy HexLine
      } repeat
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j HexVertex
	} for } for
    grestore
end } def

/DrawHavannahBoard { 3 dict begin
    /Base DimX 1 add 2 idiv  def
    gsave
    HavannahBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 Base { /j exch def
	Base j 1 sub sub 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    1 1 Base 1 sub { /j exch def
	1 1 DimX j sub { /i exch def
	   i j Base add 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexBorder{ 6 dict begin /start exch def 
    /cells exch def /isBlack exch def /which exch def
    gsave
    which UpLeft eq {1 DimY 1 add start sub Up HxgnCorner moveto /d Left def /r 60 def} if
    which UpRight eq {start DimY Up HxgnCorner moveto /d Right def /r 300 def} if
    which DownLeft eq {DimX 1 add start sub 1 Down HxgnCorner moveto /d Left def /r 300 def} if
    which DownRight eq {DimX start Down HxgnCorner moveto /d Right def /r 60 def} if
    0.5 d Go 
    which UpRight eq which DownRight eq or {180 rotate} if
    r TurnGo 
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.5 360 r sub MagTurnGo 1.5 360 r sub 2 mul MagTurnGo
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.75 360 r sub MagTurnGo
    closepath isBlack 1 eq {gsave fill grestore} if stroke grestore
end } def

/NoDrawHexBoard {  % dummy, used in creating bounding box
} def

/HexBoardBorders { 1 dict begin
    /upperLeftBlack exch def
    PerimeterWidth setlinewidth 0 setgray
    UpLeft    upperLeftBlack       DimY 1 DrawHexBorder
    UpRight   1 upperLeftBlack sub DimX 1 DrawHexBorder
    DownRight upperLeftBlack       DimY 1 DrawHexBorder
    DownLeft  1 upperLeftBlack sub DimX 1 DrawHexBorder
end } def

/YBoardPerimeter {
    newpath 1 1 DownRight HxgnCorner moveto 180 rotate
    3 { DimX 1 sub { 300 TurnGo 60 TurnGo } repeat 
        60 TurnGo 60 TurnGo} 
    repeat % now restore initial rotation state
    180 rotate % closepath
} def

/DrawYBoard { 2 dict begin
    YBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimX {/j exch def
        1 1 DimX 1 add j sub {/i exch def
	    i j 1 SemiHexagonPath stroke
        } for } for
end } def

/FontSelect { % bold italic FontSelect
    2 dict begin /italic exch def /bold exch def
    bold {
	italic 
	{ /Times-BoldItalic findfont TextHeight scalefont setfont } 
	{ /Times-Bold findfont TextHeight scalefont setfont }
	ifelse} 
        {
	italic {/Times-Italic findfont TextHeight scalefont setfont} 
	{ /Times findfont TextHeight scalefont setfont }
	ifelse}
    ifelse
end } def
	    
/LabelString {   % call: i j (str) strlen LabelString
%  to use with board rotation, remove comments
    6 dict begin /strlen exch def /str exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint /y exch def /x exch def
    %BoardRotation rotate
    x y moveto 
    %360 BoardRotation sub rotate
    TextWidth strlen mul 0.5 mul neg TextHeight 0.33 mul neg rmoveto
    str show 
end } def

/AbsLabelString { 4 dict begin
    /strlen exch def /str exch def /y exch def /x exch def
    newpath
    x AbsCoordX TextWidth strlen mul 0.5 mul sub
    y AbsCoordY TextHeight 0.33 mul sub
    moveto
    str
    show
end } def

/LabelStringVerb { % i j (str) strlen shade bold italic LabelStringVerb
    7 dict begin /italic exch def /bold exch def /shade exch def
    /strlen exch def /str exch def /j exch def /i exch def
    bold italic FontSelect shade setgray
    i j str strlen LabelString
end } def

/HexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimX { /i exch def
	i 0          Chars i 1 sub get 1 LabelString
	i DimY 1 add Chars i 1 sub get 1 LabelString
    } for
    1 1 DimY { /j exch def
	0 j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
	DimX 1 add j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HavannahBoardCoordinates { 3 dict begin
    false true FontSelect CoordinatesShade setgray
    /Base DimX 1 add 2 idiv  def
    1 1 Base { /i exch def
	i 0 HavannahPosn Chars  i 1 sub get 1 LabelString
	0 i HavannahPosn Digits i 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
    1 1 Base 1 sub { /i exch def
	i Base add i HavannahPosn Chars  i Base add 1 sub get 1 LabelString
	i i Base add HavannahPosn Digits i Base add 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/AltHexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimY { /j exch def
	0 j Chars j 1 sub get 1 LabelString
        %DimX 1 add j Chars j 1 sub get 1 LabelString
    } for
    1 1 DimX { /i exch def
	i 0 Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
	%i DimY 1 add Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HexDot { 3 dict begin /size exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint size 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexWhiteMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexWhitePiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexBlackMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexBlackPiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    1 setgray 0 setlinewidth fill
end } def

/HexDoubleMarker { 6 dict begin
    /shaderight exch def /shadeleft exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    gsave
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    shadeleft setgray 0 setlinewidth fill
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    shaderight setgray 0 setlinewidth fill
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    grestore
end } def

/HexBlackWhiteMarker { 0.0 1.0 HexDoubleMarker } def

/HexWhiteBlackMarker { 1.0 0.0 HexDoubleMarker } def
        
/HexMarker { 2 dict begin /j exch def /i exch def
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setlinewidth fill
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke  
end } def

/HexBlackMarker { 2 dict begin /j exch def /i exch def
    0 setgray
    i j HexMarker
end } def

/HexWhiteMarker { 2 dict begin /j exch def /i exch def
    1 setgray
    i j HexMarker
end } def
    
/HexPiece { 3 dict begin /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/MagicStone { 4 dict begin 
    /size exch def /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 1.3 mul size mul 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/HexWhitePiece { 1.0 HexPiece } def

/HexBlackPiece { 0.0 HexPiece } def

/HexWhiteLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def
    i j HexWhitePiece
    i j str strlen 0.0 true true LabelStringVerb
end } def

/HexBlackLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def 
    i j HexBlackPiece
    i j str strlen 1.0 true true LabelStringVerb
end } def

/AbsCoordX { 1 dict begin /x exch def
    OriginX x Scale mul add
end } def

/AbsCoordY { 1 dict begin /y exch def
    OriginY y Scale mul add
end } def

/DrawBox { /maxy exch def /maxx exch def /miny exch def /minx exch def
    newpath
    minx miny moveto
    maxx minx sub 0 rlineto
    0 maxy miny sub rlineto
    minx maxx sub 0 rlineto
    0 miny maxy sub rlineto
    HexLineWidth setlinewidth
    0 setgray
    stroke
} def

/HexVertex { 2 dict begin /j exch def /i exch def
    i j GraphVertexSize HexDot
end } def

/HexLine { 4 dict begin /j2 exch def /i2 exch def /j1 exch def /i1 exch def
    GraphLineWidth setlinewidth
    0 setgray
    newpath
    i1 j1 HexCenterPoint moveto
    i2 j2 HexCenterPoint lineto
    stroke
end } def

%%---------------- Program -------------------


FlatTopBoard
DrawHexBoard
1 HexBoardBorders


%------------ Trailer --------------

showpage

%%EndDocument
 @endspecial 1900 w @beginspecial 0 @llx 0 @lly 66 @urx
47 @ury 1133 @rwi @setspecial
%%BeginDocument: fz/pix/4x4.eps
%!PS-Adobe-3.0
%%Creator: Jack van Rijswijck, thanks to Cameron Browne
%%BoundingBox: 0 0 66 47
%%Pages: 0
%%EndComments

/OriginX -6 def
/OriginY 36 def
%---------------- Variables -------------------

/DimX 4 def
/DimY 4 def
/Scale 1.2 def


% draw  Hex boards, any size ... but labels only up to 26x26
% based on code by Cameron Browne, revised by Jack vR, revised by RBH
%-------------- state initializations -------------------------
1 setlinejoin   % lines meet at a point  ==>    use round join
%---------------- constants -------------------
/Root3Div2  0.86602540378444 def
/Chars   {[(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)
           (n)(o)(p)(q)(r)(s)(t)(u)(v)(w)(x)(y)(z)]} def
/CharsUC {[(A)(B)(C)(D)(E)(F)(G)(H)(I)(J)(K)(L)(M)
           (N)(O)(P)(Q)(R)(S)(T)(U)(V)(W)(X)(Y)(Z)]} def
/Digits  {[(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)(12)(13)
           (14)(15)(16)(17)(18)(19)(20)(21)(22)(23)(24)(25)(26)]} def
/HexRadius      5 Scale mul def % hexagon center-to-corner distance 
/HexLineWidth 0.1 Scale mul def 
/GraphVertexSize 1.0 Scale mul def
/GraphLineWidth 0.5 Scale mul def
/CircleRadius 3.0 Scale mul def 
/CircleLineWidth 0.346 Scale mul def 
/PerimeterWidth 0.5 Scale mul def 
/TextHeight 4.5 def
/TextWidth TextHeight 0.45 mul def 
/BoardShade 0.8 def
/CoordinatesShade 0.5 def
/MarkerSize 1.2 def
/CellOrientation 1 def   % 1: flat bottom  0: pointed bottom
/CellCorner [ % 6 cell corners, wrt center 0 0, plus "up" and "down"
   [ HexRadius  neg       0                           ] 
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul neg ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul neg ]
   [ HexRadius            0                           ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul     ]
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul neg ]
] def
%----- name cell corner indices ... see below
/Left  0 def /DownLeft 1 def /DownRight 2 def 
/Right 3 def /UpRight  4 def /UpLeft    5 def 
/Up    6 def /Down     7 def
%-----------------------------------------------------
% cell orientations:  flat bottom    flat side
%-----------------------------------------------------
% flat bottom 
% board cell indices            cell corner/top/bottom indices
%             --
%           /    \
%        --   1,3  --                  5 -6- 4
%      /    \    /    \               /       \
%   --   1,2  --   2,3  --           0         3
% /    \    /    \    /    \          \       /
%   1,1  --   2,2  --   3,3            1 -7- 2
% \    /    \    /    \    /
%   --   2,1  --   3,2  --
%      \    /    \    /   
%        --   3,1  --     
%----------------------------------------------------
% flat side 
%    /  \  /  \  /  \                       5
%   | 11 || 12 || 13 ||                   /   6
%    \  /  \  /  \  /  \                 0     4
%     || 21 || 22 || 23 |                |     |
%       \  /  \  /  \  /  \              1     3
%        || 31 || 32 || 33 |              7   /
%-------------------------------------------2--------
%----------- procedures -------------
/ScalePoint { % stack: ... x y size ==> ...  x*size y*size
   3 dict begin /size exch def /y exch def /x exch def
   x size mul           y size mul
end } def

/FlatTopBoard { FlatSideCells } def

/FlatSideCells {  % redefine cell orientation for flat side
  /CellOrientation 0 def   
  /CellCorner [ % 6 cell corners, wrt center 0 0  %xcoord ycoord
    [HexRadius Root3Div2 mul neg  HexRadius 2 div     ]
    [HexRadius Root3Div2 mul neg  HexRadius 2 div neg ]
    [0                            HexRadius neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div ]
    [0                            HexRadius ]
    [HexRadius Root3Div2 2 div mul HexRadius 0.75 mul ]
    [HexRadius Root3Div2 2 div mul neg HexRadius 0.75 mul neg ]
  ] def
} def

/HexCenterPoint { % center of cell (i,j)
    2 dict begin /j exch def /i exch def
    CellOrientation 1 eq {
    OriginX i j add HexRadius mul 1.5 mul add %Ox + (i+j)*HR*1.5
    OriginY i j sub HexRadius mul Root3Div2 mul sub %Oy - (i-j)*HR*R3/2
    }{
    OriginX i 2 j mul add HexRadius mul Root3Div2 mul add  %Ox + (2i+j)*HR
    OriginY i 1 sub HexRadius mul 1.5 mul sub %Oy - i*HR*R3/2
    } ifelse
end } def
 
/HexLine { % a b c d
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint lineto
    stroke
} def

/HexCurve { % a b c d e f
    /f exch def
    /e exch def
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint e f HexCenterPoint HexRadius 2 mul arcto
    e f HexCenterPoint lineto
    stroke
} def

/HxgnCorner { 5 dict begin /corn exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    x CellCorner corn get 0 get add
    y CellCorner corn get 1 get add
end } def

/Go { 2 dict begin /corn exch def /mag exch def
   % rlineto in a cell orientation direction
   CellCorner corn get aload pop mag ScalePoint rlineto
end } def

/TurnGo { rotate 1.0 Left Go } def % call: degrees TurnGo
/MagTurnGo { rotate Left Go } def % call: mag degrees TurnGo

/HexagonPath { % call: i j HexagonPath
    newpath 
    UpRight HxgnCorner moveto 
    6 { 1.0 Left Go 60 rotate } repeat 
} def

/FillAndStroke { 2 dict begin /sh exch def /wdth exch def
    gsave sh setgray fill
    grestore 0 setgray wdth setlinewidth stroke
end } def

/ShadedHexagon { 3 dict begin /shade exch def /j exch def /i exch def
    i j HexagonPath
    0 shade FillAndStroke
end } def

/Hexagon { % stack: ... i j
    HexagonPath 
    HexLineWidth BoardShade FillAndStroke
} def

/SemiHexagonPath { % stack: ... top i j
    newpath 
    1 eq { Left HxgnCorner moveto 
        1.0 UpRight Go 1.0 Right Go 1.0 DownRight Go stroke }{
        Right HxgnCorner moveto 
        1.0 DownLeft Go 1.0 Left Go 1.0 UpLeft Go stroke
    } ifelse
} def

/HexBoardPerimeter {
    newpath
    1 DimY UpRight HxgnCorner moveto 1.0 Left Go                      
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 rotate %restore rotation
} def

%----------- Havannah coordinates ----------------------
%                   ..  ..  ..
%                 d1  c2  b3  a4
%                   c1  b2  a3
%                     b1  a2
%                       a1
/HavannahPosn { % convert to usual coordinate, so ... x y  =>  ... 1+DimX-x  y
    exch DimX 1 add exch sub exch 
} def

/HavannahBoardPerimeter {
    newpath
    1 DimX UpRight HxgnCorner moveto 1.0 Left Go                      
    6 {Base 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo } repeat
} def

/DrawHexBoard { 2 dict begin
    gsave
    HexBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexPLBoard { 6 dict begin %point-line board
    gsave
    BoardShade setgray newpath
    -1 DimY 1 add 0.5 mul HexCenterPoint moveto
    1 DimY HexCenterPoint lineto
    DimX 1 add 0.5 mul DimY 2 add HexCenterPoint lineto
    DimX DimY HexCenterPoint lineto
    DimX 2 add DimY 1 add 0.5 mul HexCenterPoint lineto
    DimX 1 HexCenterPoint lineto
    DimX 1 add 0.5 mul -1 HexCenterPoint lineto
    1 1 HexCenterPoint lineto
    closepath fill 0 setgray
    1 DimY HexCenterPoint moveto
    1 1 DimX { /i exch def 
        i 1 i DimY HexLine 
        DimY 1 add 0.5 mul -1 i 1 HexLine
        DimY 1 add 0.5 mul DimY 2 add i DimY HexLine } for
    1 1 DimY { /j exch def 
        1 j DimX j HexLine 
        -1 DimX 1 add 0.5 mul 1 j HexLine
        DimX 2 add DimX 1 add 0.5 mul DimX j HexLine } for
    /topx 1 def /topy 1 def /btmx 1 def /btmy 1 def
    DimX DimY add 3 sub {
      topx DimX lt {/topx 1 topx add def}{/topy 1 topy add def} ifelse 
      btmy DimY lt {/btmy 1 btmy add def}{/btmx 1 btmx add def} ifelse 
      topx topy btmx btmy HexLine
      } repeat
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j HexVertex
	} for } for
    grestore
end } def

/DrawHavannahBoard { 3 dict begin
    /Base DimX 1 add 2 idiv  def
    gsave
    HavannahBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 Base { /j exch def
	Base j 1 sub sub 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    1 1 Base 1 sub { /j exch def
	1 1 DimX j sub { /i exch def
	   i j Base add 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexBorder{ 6 dict begin /start exch def 
    /cells exch def /isBlack exch def /which exch def
    gsave
    which UpLeft eq {1 DimY 1 add start sub Up HxgnCorner moveto /d Left def /r 60 def} if
    which UpRight eq {start DimY Up HxgnCorner moveto /d Right def /r 300 def} if
    which DownLeft eq {DimX 1 add start sub 1 Down HxgnCorner moveto /d Left def /r 300 def} if
    which DownRight eq {DimX start Down HxgnCorner moveto /d Right def /r 60 def} if
    0.5 d Go 
    which UpRight eq which DownRight eq or {180 rotate} if
    r TurnGo 
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.5 360 r sub MagTurnGo 1.5 360 r sub 2 mul MagTurnGo
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.75 360 r sub MagTurnGo
    closepath isBlack 1 eq {gsave fill grestore} if stroke grestore
end } def

/NoDrawHexBoard {  % dummy, used in creating bounding box
} def

/HexBoardBorders { 1 dict begin
    /upperLeftBlack exch def
    PerimeterWidth setlinewidth 0 setgray
    UpLeft    upperLeftBlack       DimY 1 DrawHexBorder
    UpRight   1 upperLeftBlack sub DimX 1 DrawHexBorder
    DownRight upperLeftBlack       DimY 1 DrawHexBorder
    DownLeft  1 upperLeftBlack sub DimX 1 DrawHexBorder
end } def

/YBoardPerimeter {
    newpath 1 1 DownRight HxgnCorner moveto 180 rotate
    3 { DimX 1 sub { 300 TurnGo 60 TurnGo } repeat 
        60 TurnGo 60 TurnGo} 
    repeat % now restore initial rotation state
    180 rotate % closepath
} def

/DrawYBoard { 2 dict begin
    YBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimX {/j exch def
        1 1 DimX 1 add j sub {/i exch def
	    i j 1 SemiHexagonPath stroke
        } for } for
end } def

/FontSelect { % bold italic FontSelect
    2 dict begin /italic exch def /bold exch def
    bold {
	italic 
	{ /Times-BoldItalic findfont TextHeight scalefont setfont } 
	{ /Times-Bold findfont TextHeight scalefont setfont }
	ifelse} 
        {
	italic {/Times-Italic findfont TextHeight scalefont setfont} 
	{ /Times findfont TextHeight scalefont setfont }
	ifelse}
    ifelse
end } def
	    
/LabelString {   % call: i j (str) strlen LabelString
%  to use with board rotation, remove comments
    6 dict begin /strlen exch def /str exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint /y exch def /x exch def
    %BoardRotation rotate
    x y moveto 
    %360 BoardRotation sub rotate
    TextWidth strlen mul 0.5 mul neg TextHeight 0.33 mul neg rmoveto
    str show 
end } def

/AbsLabelString { 4 dict begin
    /strlen exch def /str exch def /y exch def /x exch def
    newpath
    x AbsCoordX TextWidth strlen mul 0.5 mul sub
    y AbsCoordY TextHeight 0.33 mul sub
    moveto
    str
    show
end } def

/LabelStringVerb { % i j (str) strlen shade bold italic LabelStringVerb
    7 dict begin /italic exch def /bold exch def /shade exch def
    /strlen exch def /str exch def /j exch def /i exch def
    bold italic FontSelect shade setgray
    i j str strlen LabelString
end } def

/HexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimX { /i exch def
	i 0          Chars i 1 sub get 1 LabelString
	i DimY 1 add Chars i 1 sub get 1 LabelString
    } for
    1 1 DimY { /j exch def
	0 j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
	DimX 1 add j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HavannahBoardCoordinates { 3 dict begin
    false true FontSelect CoordinatesShade setgray
    /Base DimX 1 add 2 idiv  def
    1 1 Base { /i exch def
	i 0 HavannahPosn Chars  i 1 sub get 1 LabelString
	0 i HavannahPosn Digits i 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
    1 1 Base 1 sub { /i exch def
	i Base add i HavannahPosn Chars  i Base add 1 sub get 1 LabelString
	i i Base add HavannahPosn Digits i Base add 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/AltHexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimY { /j exch def
	0 j Chars j 1 sub get 1 LabelString
        %DimX 1 add j Chars j 1 sub get 1 LabelString
    } for
    1 1 DimX { /i exch def
	i 0 Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
	%i DimY 1 add Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HexDot { 3 dict begin /size exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint size 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexWhiteMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexWhitePiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexBlackMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexBlackPiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    1 setgray 0 setlinewidth fill
end } def

/HexDoubleMarker { 6 dict begin
    /shaderight exch def /shadeleft exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    gsave
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    shadeleft setgray 0 setlinewidth fill
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    shaderight setgray 0 setlinewidth fill
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    grestore
end } def

/HexBlackWhiteMarker { 0.0 1.0 HexDoubleMarker } def

/HexWhiteBlackMarker { 1.0 0.0 HexDoubleMarker } def
        
/HexMarker { 2 dict begin /j exch def /i exch def
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setlinewidth fill
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke  
end } def

/HexBlackMarker { 2 dict begin /j exch def /i exch def
    0 setgray
    i j HexMarker
end } def

/HexWhiteMarker { 2 dict begin /j exch def /i exch def
    1 setgray
    i j HexMarker
end } def
    
/HexPiece { 3 dict begin /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/MagicStone { 4 dict begin 
    /size exch def /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 1.3 mul size mul 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/HexWhitePiece { 1.0 HexPiece } def

/HexBlackPiece { 0.0 HexPiece } def

/HexWhiteLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def
    i j HexWhitePiece
    i j str strlen 0.0 true true LabelStringVerb
end } def

/HexBlackLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def 
    i j HexBlackPiece
    i j str strlen 1.0 true true LabelStringVerb
end } def

/AbsCoordX { 1 dict begin /x exch def
    OriginX x Scale mul add
end } def

/AbsCoordY { 1 dict begin /y exch def
    OriginY y Scale mul add
end } def

/DrawBox { /maxy exch def /maxx exch def /miny exch def /minx exch def
    newpath
    minx miny moveto
    maxx minx sub 0 rlineto
    0 maxy miny sub rlineto
    minx maxx sub 0 rlineto
    0 miny maxy sub rlineto
    HexLineWidth setlinewidth
    0 setgray
    stroke
} def

/HexVertex { 2 dict begin /j exch def /i exch def
    i j GraphVertexSize HexDot
end } def

/HexLine { 4 dict begin /j2 exch def /i2 exch def /j1 exch def /i1 exch def
    GraphLineWidth setlinewidth
    0 setgray
    newpath
    i1 j1 HexCenterPoint moveto
    i2 j2 HexCenterPoint lineto
    stroke
end } def

%%---------------- Program -------------------


FlatTopBoard
DrawHexBoard
1 HexBoardBorders


%------------ Trailer --------------

showpage

%%EndDocument
 @endspecial 1900 w @beginspecial 0 @llx 0 @lly 66 @urx
47 @ury 1133 @rwi @setspecial
%%BeginDocument: fz/pix/4x4.eps
%!PS-Adobe-3.0
%%Creator: Jack van Rijswijck, thanks to Cameron Browne
%%BoundingBox: 0 0 66 47
%%Pages: 0
%%EndComments

/OriginX -6 def
/OriginY 36 def
%---------------- Variables -------------------

/DimX 4 def
/DimY 4 def
/Scale 1.2 def


% draw  Hex boards, any size ... but labels only up to 26x26
% based on code by Cameron Browne, revised by Jack vR, revised by RBH
%-------------- state initializations -------------------------
1 setlinejoin   % lines meet at a point  ==>    use round join
%---------------- constants -------------------
/Root3Div2  0.86602540378444 def
/Chars   {[(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)
           (n)(o)(p)(q)(r)(s)(t)(u)(v)(w)(x)(y)(z)]} def
/CharsUC {[(A)(B)(C)(D)(E)(F)(G)(H)(I)(J)(K)(L)(M)
           (N)(O)(P)(Q)(R)(S)(T)(U)(V)(W)(X)(Y)(Z)]} def
/Digits  {[(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)(12)(13)
           (14)(15)(16)(17)(18)(19)(20)(21)(22)(23)(24)(25)(26)]} def
/HexRadius      5 Scale mul def % hexagon center-to-corner distance 
/HexLineWidth 0.1 Scale mul def 
/GraphVertexSize 1.0 Scale mul def
/GraphLineWidth 0.5 Scale mul def
/CircleRadius 3.0 Scale mul def 
/CircleLineWidth 0.346 Scale mul def 
/PerimeterWidth 0.5 Scale mul def 
/TextHeight 4.5 def
/TextWidth TextHeight 0.45 mul def 
/BoardShade 0.8 def
/CoordinatesShade 0.5 def
/MarkerSize 1.2 def
/CellOrientation 1 def   % 1: flat bottom  0: pointed bottom
/CellCorner [ % 6 cell corners, wrt center 0 0, plus "up" and "down"
   [ HexRadius  neg       0                           ] 
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul neg ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul neg ]
   [ HexRadius            0                           ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul     ]
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul neg ]
] def
%----- name cell corner indices ... see below
/Left  0 def /DownLeft 1 def /DownRight 2 def 
/Right 3 def /UpRight  4 def /UpLeft    5 def 
/Up    6 def /Down     7 def
%-----------------------------------------------------
% cell orientations:  flat bottom    flat side
%-----------------------------------------------------
% flat bottom 
% board cell indices            cell corner/top/bottom indices
%             --
%           /    \
%        --   1,3  --                  5 -6- 4
%      /    \    /    \               /       \
%   --   1,2  --   2,3  --           0         3
% /    \    /    \    /    \          \       /
%   1,1  --   2,2  --   3,3            1 -7- 2
% \    /    \    /    \    /
%   --   2,1  --   3,2  --
%      \    /    \    /   
%        --   3,1  --     
%----------------------------------------------------
% flat side 
%    /  \  /  \  /  \                       5
%   | 11 || 12 || 13 ||                   /   6
%    \  /  \  /  \  /  \                 0     4
%     || 21 || 22 || 23 |                |     |
%       \  /  \  /  \  /  \              1     3
%        || 31 || 32 || 33 |              7   /
%-------------------------------------------2--------
%----------- procedures -------------
/ScalePoint { % stack: ... x y size ==> ...  x*size y*size
   3 dict begin /size exch def /y exch def /x exch def
   x size mul           y size mul
end } def

/FlatTopBoard { FlatSideCells } def

/FlatSideCells {  % redefine cell orientation for flat side
  /CellOrientation 0 def   
  /CellCorner [ % 6 cell corners, wrt center 0 0  %xcoord ycoord
    [HexRadius Root3Div2 mul neg  HexRadius 2 div     ]
    [HexRadius Root3Div2 mul neg  HexRadius 2 div neg ]
    [0                            HexRadius neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div ]
    [0                            HexRadius ]
    [HexRadius Root3Div2 2 div mul HexRadius 0.75 mul ]
    [HexRadius Root3Div2 2 div mul neg HexRadius 0.75 mul neg ]
  ] def
} def

/HexCenterPoint { % center of cell (i,j)
    2 dict begin /j exch def /i exch def
    CellOrientation 1 eq {
    OriginX i j add HexRadius mul 1.5 mul add %Ox + (i+j)*HR*1.5
    OriginY i j sub HexRadius mul Root3Div2 mul sub %Oy - (i-j)*HR*R3/2
    }{
    OriginX i 2 j mul add HexRadius mul Root3Div2 mul add  %Ox + (2i+j)*HR
    OriginY i 1 sub HexRadius mul 1.5 mul sub %Oy - i*HR*R3/2
    } ifelse
end } def
 
/HexLine { % a b c d
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint lineto
    stroke
} def

/HexCurve { % a b c d e f
    /f exch def
    /e exch def
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint e f HexCenterPoint HexRadius 2 mul arcto
    e f HexCenterPoint lineto
    stroke
} def

/HxgnCorner { 5 dict begin /corn exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    x CellCorner corn get 0 get add
    y CellCorner corn get 1 get add
end } def

/Go { 2 dict begin /corn exch def /mag exch def
   % rlineto in a cell orientation direction
   CellCorner corn get aload pop mag ScalePoint rlineto
end } def

/TurnGo { rotate 1.0 Left Go } def % call: degrees TurnGo
/MagTurnGo { rotate Left Go } def % call: mag degrees TurnGo

/HexagonPath { % call: i j HexagonPath
    newpath 
    UpRight HxgnCorner moveto 
    6 { 1.0 Left Go 60 rotate } repeat 
} def

/FillAndStroke { 2 dict begin /sh exch def /wdth exch def
    gsave sh setgray fill
    grestore 0 setgray wdth setlinewidth stroke
end } def

/ShadedHexagon { 3 dict begin /shade exch def /j exch def /i exch def
    i j HexagonPath
    0 shade FillAndStroke
end } def

/Hexagon { % stack: ... i j
    HexagonPath 
    HexLineWidth BoardShade FillAndStroke
} def

/SemiHexagonPath { % stack: ... top i j
    newpath 
    1 eq { Left HxgnCorner moveto 
        1.0 UpRight Go 1.0 Right Go 1.0 DownRight Go stroke }{
        Right HxgnCorner moveto 
        1.0 DownLeft Go 1.0 Left Go 1.0 UpLeft Go stroke
    } ifelse
} def

/HexBoardPerimeter {
    newpath
    1 DimY UpRight HxgnCorner moveto 1.0 Left Go                      
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 rotate %restore rotation
} def

%----------- Havannah coordinates ----------------------
%                   ..  ..  ..
%                 d1  c2  b3  a4
%                   c1  b2  a3
%                     b1  a2
%                       a1
/HavannahPosn { % convert to usual coordinate, so ... x y  =>  ... 1+DimX-x  y
    exch DimX 1 add exch sub exch 
} def

/HavannahBoardPerimeter {
    newpath
    1 DimX UpRight HxgnCorner moveto 1.0 Left Go                      
    6 {Base 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo } repeat
} def

/DrawHexBoard { 2 dict begin
    gsave
    HexBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexPLBoard { 6 dict begin %point-line board
    gsave
    BoardShade setgray newpath
    -1 DimY 1 add 0.5 mul HexCenterPoint moveto
    1 DimY HexCenterPoint lineto
    DimX 1 add 0.5 mul DimY 2 add HexCenterPoint lineto
    DimX DimY HexCenterPoint lineto
    DimX 2 add DimY 1 add 0.5 mul HexCenterPoint lineto
    DimX 1 HexCenterPoint lineto
    DimX 1 add 0.5 mul -1 HexCenterPoint lineto
    1 1 HexCenterPoint lineto
    closepath fill 0 setgray
    1 DimY HexCenterPoint moveto
    1 1 DimX { /i exch def 
        i 1 i DimY HexLine 
        DimY 1 add 0.5 mul -1 i 1 HexLine
        DimY 1 add 0.5 mul DimY 2 add i DimY HexLine } for
    1 1 DimY { /j exch def 
        1 j DimX j HexLine 
        -1 DimX 1 add 0.5 mul 1 j HexLine
        DimX 2 add DimX 1 add 0.5 mul DimX j HexLine } for
    /topx 1 def /topy 1 def /btmx 1 def /btmy 1 def
    DimX DimY add 3 sub {
      topx DimX lt {/topx 1 topx add def}{/topy 1 topy add def} ifelse 
      btmy DimY lt {/btmy 1 btmy add def}{/btmx 1 btmx add def} ifelse 
      topx topy btmx btmy HexLine
      } repeat
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j HexVertex
	} for } for
    grestore
end } def

/DrawHavannahBoard { 3 dict begin
    /Base DimX 1 add 2 idiv  def
    gsave
    HavannahBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 Base { /j exch def
	Base j 1 sub sub 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    1 1 Base 1 sub { /j exch def
	1 1 DimX j sub { /i exch def
	   i j Base add 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexBorder{ 6 dict begin /start exch def 
    /cells exch def /isBlack exch def /which exch def
    gsave
    which UpLeft eq {1 DimY 1 add start sub Up HxgnCorner moveto /d Left def /r 60 def} if
    which UpRight eq {start DimY Up HxgnCorner moveto /d Right def /r 300 def} if
    which DownLeft eq {DimX 1 add start sub 1 Down HxgnCorner moveto /d Left def /r 300 def} if
    which DownRight eq {DimX start Down HxgnCorner moveto /d Right def /r 60 def} if
    0.5 d Go 
    which UpRight eq which DownRight eq or {180 rotate} if
    r TurnGo 
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.5 360 r sub MagTurnGo 1.5 360 r sub 2 mul MagTurnGo
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.75 360 r sub MagTurnGo
    closepath isBlack 1 eq {gsave fill grestore} if stroke grestore
end } def

/NoDrawHexBoard {  % dummy, used in creating bounding box
} def

/HexBoardBorders { 1 dict begin
    /upperLeftBlack exch def
    PerimeterWidth setlinewidth 0 setgray
    UpLeft    upperLeftBlack       DimY 1 DrawHexBorder
    UpRight   1 upperLeftBlack sub DimX 1 DrawHexBorder
    DownRight upperLeftBlack       DimY 1 DrawHexBorder
    DownLeft  1 upperLeftBlack sub DimX 1 DrawHexBorder
end } def

/YBoardPerimeter {
    newpath 1 1 DownRight HxgnCorner moveto 180 rotate
    3 { DimX 1 sub { 300 TurnGo 60 TurnGo } repeat 
        60 TurnGo 60 TurnGo} 
    repeat % now restore initial rotation state
    180 rotate % closepath
} def

/DrawYBoard { 2 dict begin
    YBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimX {/j exch def
        1 1 DimX 1 add j sub {/i exch def
	    i j 1 SemiHexagonPath stroke
        } for } for
end } def

/FontSelect { % bold italic FontSelect
    2 dict begin /italic exch def /bold exch def
    bold {
	italic 
	{ /Times-BoldItalic findfont TextHeight scalefont setfont } 
	{ /Times-Bold findfont TextHeight scalefont setfont }
	ifelse} 
        {
	italic {/Times-Italic findfont TextHeight scalefont setfont} 
	{ /Times findfont TextHeight scalefont setfont }
	ifelse}
    ifelse
end } def
	    
/LabelString {   % call: i j (str) strlen LabelString
%  to use with board rotation, remove comments
    6 dict begin /strlen exch def /str exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint /y exch def /x exch def
    %BoardRotation rotate
    x y moveto 
    %360 BoardRotation sub rotate
    TextWidth strlen mul 0.5 mul neg TextHeight 0.33 mul neg rmoveto
    str show 
end } def

/AbsLabelString { 4 dict begin
    /strlen exch def /str exch def /y exch def /x exch def
    newpath
    x AbsCoordX TextWidth strlen mul 0.5 mul sub
    y AbsCoordY TextHeight 0.33 mul sub
    moveto
    str
    show
end } def

/LabelStringVerb { % i j (str) strlen shade bold italic LabelStringVerb
    7 dict begin /italic exch def /bold exch def /shade exch def
    /strlen exch def /str exch def /j exch def /i exch def
    bold italic FontSelect shade setgray
    i j str strlen LabelString
end } def

/HexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimX { /i exch def
	i 0          Chars i 1 sub get 1 LabelString
	i DimY 1 add Chars i 1 sub get 1 LabelString
    } for
    1 1 DimY { /j exch def
	0 j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
	DimX 1 add j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HavannahBoardCoordinates { 3 dict begin
    false true FontSelect CoordinatesShade setgray
    /Base DimX 1 add 2 idiv  def
    1 1 Base { /i exch def
	i 0 HavannahPosn Chars  i 1 sub get 1 LabelString
	0 i HavannahPosn Digits i 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
    1 1 Base 1 sub { /i exch def
	i Base add i HavannahPosn Chars  i Base add 1 sub get 1 LabelString
	i i Base add HavannahPosn Digits i Base add 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/AltHexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimY { /j exch def
	0 j Chars j 1 sub get 1 LabelString
        %DimX 1 add j Chars j 1 sub get 1 LabelString
    } for
    1 1 DimX { /i exch def
	i 0 Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
	%i DimY 1 add Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HexDot { 3 dict begin /size exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint size 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexWhiteMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexWhitePiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexBlackMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexBlackPiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    1 setgray 0 setlinewidth fill
end } def

/HexDoubleMarker { 6 dict begin
    /shaderight exch def /shadeleft exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    gsave
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    shadeleft setgray 0 setlinewidth fill
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    shaderight setgray 0 setlinewidth fill
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    grestore
end } def

/HexBlackWhiteMarker { 0.0 1.0 HexDoubleMarker } def

/HexWhiteBlackMarker { 1.0 0.0 HexDoubleMarker } def
        
/HexMarker { 2 dict begin /j exch def /i exch def
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setlinewidth fill
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke  
end } def

/HexBlackMarker { 2 dict begin /j exch def /i exch def
    0 setgray
    i j HexMarker
end } def

/HexWhiteMarker { 2 dict begin /j exch def /i exch def
    1 setgray
    i j HexMarker
end } def
    
/HexPiece { 3 dict begin /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/MagicStone { 4 dict begin 
    /size exch def /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 1.3 mul size mul 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/HexWhitePiece { 1.0 HexPiece } def

/HexBlackPiece { 0.0 HexPiece } def

/HexWhiteLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def
    i j HexWhitePiece
    i j str strlen 0.0 true true LabelStringVerb
end } def

/HexBlackLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def 
    i j HexBlackPiece
    i j str strlen 1.0 true true LabelStringVerb
end } def

/AbsCoordX { 1 dict begin /x exch def
    OriginX x Scale mul add
end } def

/AbsCoordY { 1 dict begin /y exch def
    OriginY y Scale mul add
end } def

/DrawBox { /maxy exch def /maxx exch def /miny exch def /minx exch def
    newpath
    minx miny moveto
    maxx minx sub 0 rlineto
    0 maxy miny sub rlineto
    minx maxx sub 0 rlineto
    0 miny maxy sub rlineto
    HexLineWidth setlinewidth
    0 setgray
    stroke
} def

/HexVertex { 2 dict begin /j exch def /i exch def
    i j GraphVertexSize HexDot
end } def

/HexLine { 4 dict begin /j2 exch def /i2 exch def /j1 exch def /i1 exch def
    GraphLineWidth setlinewidth
    0 setgray
    newpath
    i1 j1 HexCenterPoint moveto
    i2 j2 HexCenterPoint lineto
    stroke
end } def

%%---------------- Program -------------------


FlatTopBoard
DrawHexBoard
1 HexBoardBorders


%------------ Trailer --------------

showpage

%%EndDocument
 @endspecial 563 9426 a @beginspecial 0 @llx 0 @lly 66
@urx 47 @ury 1133 @rwi @setspecial
%%BeginDocument: fz/pix/4x4.eps
%!PS-Adobe-3.0
%%Creator: Jack van Rijswijck, thanks to Cameron Browne
%%BoundingBox: 0 0 66 47
%%Pages: 0
%%EndComments

/OriginX -6 def
/OriginY 36 def
%---------------- Variables -------------------

/DimX 4 def
/DimY 4 def
/Scale 1.2 def


% draw  Hex boards, any size ... but labels only up to 26x26
% based on code by Cameron Browne, revised by Jack vR, revised by RBH
%-------------- state initializations -------------------------
1 setlinejoin   % lines meet at a point  ==>    use round join
%---------------- constants -------------------
/Root3Div2  0.86602540378444 def
/Chars   {[(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)
           (n)(o)(p)(q)(r)(s)(t)(u)(v)(w)(x)(y)(z)]} def
/CharsUC {[(A)(B)(C)(D)(E)(F)(G)(H)(I)(J)(K)(L)(M)
           (N)(O)(P)(Q)(R)(S)(T)(U)(V)(W)(X)(Y)(Z)]} def
/Digits  {[(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)(12)(13)
           (14)(15)(16)(17)(18)(19)(20)(21)(22)(23)(24)(25)(26)]} def
/HexRadius      5 Scale mul def % hexagon center-to-corner distance 
/HexLineWidth 0.1 Scale mul def 
/GraphVertexSize 1.0 Scale mul def
/GraphLineWidth 0.5 Scale mul def
/CircleRadius 3.0 Scale mul def 
/CircleLineWidth 0.346 Scale mul def 
/PerimeterWidth 0.5 Scale mul def 
/TextHeight 4.5 def
/TextWidth TextHeight 0.45 mul def 
/BoardShade 0.8 def
/CoordinatesShade 0.5 def
/MarkerSize 1.2 def
/CellOrientation 1 def   % 1: flat bottom  0: pointed bottom
/CellCorner [ % 6 cell corners, wrt center 0 0, plus "up" and "down"
   [ HexRadius  neg       0                           ] 
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul neg ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul neg ]
   [ HexRadius            0                           ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul     ]
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul neg ]
] def
%----- name cell corner indices ... see below
/Left  0 def /DownLeft 1 def /DownRight 2 def 
/Right 3 def /UpRight  4 def /UpLeft    5 def 
/Up    6 def /Down     7 def
%-----------------------------------------------------
% cell orientations:  flat bottom    flat side
%-----------------------------------------------------
% flat bottom 
% board cell indices            cell corner/top/bottom indices
%             --
%           /    \
%        --   1,3  --                  5 -6- 4
%      /    \    /    \               /       \
%   --   1,2  --   2,3  --           0         3
% /    \    /    \    /    \          \       /
%   1,1  --   2,2  --   3,3            1 -7- 2
% \    /    \    /    \    /
%   --   2,1  --   3,2  --
%      \    /    \    /   
%        --   3,1  --     
%----------------------------------------------------
% flat side 
%    /  \  /  \  /  \                       5
%   | 11 || 12 || 13 ||                   /   6
%    \  /  \  /  \  /  \                 0     4
%     || 21 || 22 || 23 |                |     |
%       \  /  \  /  \  /  \              1     3
%        || 31 || 32 || 33 |              7   /
%-------------------------------------------2--------
%----------- procedures -------------
/ScalePoint { % stack: ... x y size ==> ...  x*size y*size
   3 dict begin /size exch def /y exch def /x exch def
   x size mul           y size mul
end } def

/FlatTopBoard { FlatSideCells } def

/FlatSideCells {  % redefine cell orientation for flat side
  /CellOrientation 0 def   
  /CellCorner [ % 6 cell corners, wrt center 0 0  %xcoord ycoord
    [HexRadius Root3Div2 mul neg  HexRadius 2 div     ]
    [HexRadius Root3Div2 mul neg  HexRadius 2 div neg ]
    [0                            HexRadius neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div ]
    [0                            HexRadius ]
    [HexRadius Root3Div2 2 div mul HexRadius 0.75 mul ]
    [HexRadius Root3Div2 2 div mul neg HexRadius 0.75 mul neg ]
  ] def
} def

/HexCenterPoint { % center of cell (i,j)
    2 dict begin /j exch def /i exch def
    CellOrientation 1 eq {
    OriginX i j add HexRadius mul 1.5 mul add %Ox + (i+j)*HR*1.5
    OriginY i j sub HexRadius mul Root3Div2 mul sub %Oy - (i-j)*HR*R3/2
    }{
    OriginX i 2 j mul add HexRadius mul Root3Div2 mul add  %Ox + (2i+j)*HR
    OriginY i 1 sub HexRadius mul 1.5 mul sub %Oy - i*HR*R3/2
    } ifelse
end } def
 
/HexLine { % a b c d
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint lineto
    stroke
} def

/HexCurve { % a b c d e f
    /f exch def
    /e exch def
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint e f HexCenterPoint HexRadius 2 mul arcto
    e f HexCenterPoint lineto
    stroke
} def

/HxgnCorner { 5 dict begin /corn exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    x CellCorner corn get 0 get add
    y CellCorner corn get 1 get add
end } def

/Go { 2 dict begin /corn exch def /mag exch def
   % rlineto in a cell orientation direction
   CellCorner corn get aload pop mag ScalePoint rlineto
end } def

/TurnGo { rotate 1.0 Left Go } def % call: degrees TurnGo
/MagTurnGo { rotate Left Go } def % call: mag degrees TurnGo

/HexagonPath { % call: i j HexagonPath
    newpath 
    UpRight HxgnCorner moveto 
    6 { 1.0 Left Go 60 rotate } repeat 
} def

/FillAndStroke { 2 dict begin /sh exch def /wdth exch def
    gsave sh setgray fill
    grestore 0 setgray wdth setlinewidth stroke
end } def

/ShadedHexagon { 3 dict begin /shade exch def /j exch def /i exch def
    i j HexagonPath
    0 shade FillAndStroke
end } def

/Hexagon { % stack: ... i j
    HexagonPath 
    HexLineWidth BoardShade FillAndStroke
} def

/SemiHexagonPath { % stack: ... top i j
    newpath 
    1 eq { Left HxgnCorner moveto 
        1.0 UpRight Go 1.0 Right Go 1.0 DownRight Go stroke }{
        Right HxgnCorner moveto 
        1.0 DownLeft Go 1.0 Left Go 1.0 UpLeft Go stroke
    } ifelse
} def

/HexBoardPerimeter {
    newpath
    1 DimY UpRight HxgnCorner moveto 1.0 Left Go                      
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 rotate %restore rotation
} def

%----------- Havannah coordinates ----------------------
%                   ..  ..  ..
%                 d1  c2  b3  a4
%                   c1  b2  a3
%                     b1  a2
%                       a1
/HavannahPosn { % convert to usual coordinate, so ... x y  =>  ... 1+DimX-x  y
    exch DimX 1 add exch sub exch 
} def

/HavannahBoardPerimeter {
    newpath
    1 DimX UpRight HxgnCorner moveto 1.0 Left Go                      
    6 {Base 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo } repeat
} def

/DrawHexBoard { 2 dict begin
    gsave
    HexBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexPLBoard { 6 dict begin %point-line board
    gsave
    BoardShade setgray newpath
    -1 DimY 1 add 0.5 mul HexCenterPoint moveto
    1 DimY HexCenterPoint lineto
    DimX 1 add 0.5 mul DimY 2 add HexCenterPoint lineto
    DimX DimY HexCenterPoint lineto
    DimX 2 add DimY 1 add 0.5 mul HexCenterPoint lineto
    DimX 1 HexCenterPoint lineto
    DimX 1 add 0.5 mul -1 HexCenterPoint lineto
    1 1 HexCenterPoint lineto
    closepath fill 0 setgray
    1 DimY HexCenterPoint moveto
    1 1 DimX { /i exch def 
        i 1 i DimY HexLine 
        DimY 1 add 0.5 mul -1 i 1 HexLine
        DimY 1 add 0.5 mul DimY 2 add i DimY HexLine } for
    1 1 DimY { /j exch def 
        1 j DimX j HexLine 
        -1 DimX 1 add 0.5 mul 1 j HexLine
        DimX 2 add DimX 1 add 0.5 mul DimX j HexLine } for
    /topx 1 def /topy 1 def /btmx 1 def /btmy 1 def
    DimX DimY add 3 sub {
      topx DimX lt {/topx 1 topx add def}{/topy 1 topy add def} ifelse 
      btmy DimY lt {/btmy 1 btmy add def}{/btmx 1 btmx add def} ifelse 
      topx topy btmx btmy HexLine
      } repeat
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j HexVertex
	} for } for
    grestore
end } def

/DrawHavannahBoard { 3 dict begin
    /Base DimX 1 add 2 idiv  def
    gsave
    HavannahBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 Base { /j exch def
	Base j 1 sub sub 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    1 1 Base 1 sub { /j exch def
	1 1 DimX j sub { /i exch def
	   i j Base add 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexBorder{ 6 dict begin /start exch def 
    /cells exch def /isBlack exch def /which exch def
    gsave
    which UpLeft eq {1 DimY 1 add start sub Up HxgnCorner moveto /d Left def /r 60 def} if
    which UpRight eq {start DimY Up HxgnCorner moveto /d Right def /r 300 def} if
    which DownLeft eq {DimX 1 add start sub 1 Down HxgnCorner moveto /d Left def /r 300 def} if
    which DownRight eq {DimX start Down HxgnCorner moveto /d Right def /r 60 def} if
    0.5 d Go 
    which UpRight eq which DownRight eq or {180 rotate} if
    r TurnGo 
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.5 360 r sub MagTurnGo 1.5 360 r sub 2 mul MagTurnGo
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.75 360 r sub MagTurnGo
    closepath isBlack 1 eq {gsave fill grestore} if stroke grestore
end } def

/NoDrawHexBoard {  % dummy, used in creating bounding box
} def

/HexBoardBorders { 1 dict begin
    /upperLeftBlack exch def
    PerimeterWidth setlinewidth 0 setgray
    UpLeft    upperLeftBlack       DimY 1 DrawHexBorder
    UpRight   1 upperLeftBlack sub DimX 1 DrawHexBorder
    DownRight upperLeftBlack       DimY 1 DrawHexBorder
    DownLeft  1 upperLeftBlack sub DimX 1 DrawHexBorder
end } def

/YBoardPerimeter {
    newpath 1 1 DownRight HxgnCorner moveto 180 rotate
    3 { DimX 1 sub { 300 TurnGo 60 TurnGo } repeat 
        60 TurnGo 60 TurnGo} 
    repeat % now restore initial rotation state
    180 rotate % closepath
} def

/DrawYBoard { 2 dict begin
    YBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimX {/j exch def
        1 1 DimX 1 add j sub {/i exch def
	    i j 1 SemiHexagonPath stroke
        } for } for
end } def

/FontSelect { % bold italic FontSelect
    2 dict begin /italic exch def /bold exch def
    bold {
	italic 
	{ /Times-BoldItalic findfont TextHeight scalefont setfont } 
	{ /Times-Bold findfont TextHeight scalefont setfont }
	ifelse} 
        {
	italic {/Times-Italic findfont TextHeight scalefont setfont} 
	{ /Times findfont TextHeight scalefont setfont }
	ifelse}
    ifelse
end } def
	    
/LabelString {   % call: i j (str) strlen LabelString
%  to use with board rotation, remove comments
    6 dict begin /strlen exch def /str exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint /y exch def /x exch def
    %BoardRotation rotate
    x y moveto 
    %360 BoardRotation sub rotate
    TextWidth strlen mul 0.5 mul neg TextHeight 0.33 mul neg rmoveto
    str show 
end } def

/AbsLabelString { 4 dict begin
    /strlen exch def /str exch def /y exch def /x exch def
    newpath
    x AbsCoordX TextWidth strlen mul 0.5 mul sub
    y AbsCoordY TextHeight 0.33 mul sub
    moveto
    str
    show
end } def

/LabelStringVerb { % i j (str) strlen shade bold italic LabelStringVerb
    7 dict begin /italic exch def /bold exch def /shade exch def
    /strlen exch def /str exch def /j exch def /i exch def
    bold italic FontSelect shade setgray
    i j str strlen LabelString
end } def

/HexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimX { /i exch def
	i 0          Chars i 1 sub get 1 LabelString
	i DimY 1 add Chars i 1 sub get 1 LabelString
    } for
    1 1 DimY { /j exch def
	0 j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
	DimX 1 add j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HavannahBoardCoordinates { 3 dict begin
    false true FontSelect CoordinatesShade setgray
    /Base DimX 1 add 2 idiv  def
    1 1 Base { /i exch def
	i 0 HavannahPosn Chars  i 1 sub get 1 LabelString
	0 i HavannahPosn Digits i 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
    1 1 Base 1 sub { /i exch def
	i Base add i HavannahPosn Chars  i Base add 1 sub get 1 LabelString
	i i Base add HavannahPosn Digits i Base add 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/AltHexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimY { /j exch def
	0 j Chars j 1 sub get 1 LabelString
        %DimX 1 add j Chars j 1 sub get 1 LabelString
    } for
    1 1 DimX { /i exch def
	i 0 Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
	%i DimY 1 add Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HexDot { 3 dict begin /size exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint size 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexWhiteMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexWhitePiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexBlackMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexBlackPiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    1 setgray 0 setlinewidth fill
end } def

/HexDoubleMarker { 6 dict begin
    /shaderight exch def /shadeleft exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    gsave
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    shadeleft setgray 0 setlinewidth fill
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    shaderight setgray 0 setlinewidth fill
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    grestore
end } def

/HexBlackWhiteMarker { 0.0 1.0 HexDoubleMarker } def

/HexWhiteBlackMarker { 1.0 0.0 HexDoubleMarker } def
        
/HexMarker { 2 dict begin /j exch def /i exch def
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setlinewidth fill
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke  
end } def

/HexBlackMarker { 2 dict begin /j exch def /i exch def
    0 setgray
    i j HexMarker
end } def

/HexWhiteMarker { 2 dict begin /j exch def /i exch def
    1 setgray
    i j HexMarker
end } def
    
/HexPiece { 3 dict begin /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/MagicStone { 4 dict begin 
    /size exch def /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 1.3 mul size mul 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/HexWhitePiece { 1.0 HexPiece } def

/HexBlackPiece { 0.0 HexPiece } def

/HexWhiteLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def
    i j HexWhitePiece
    i j str strlen 0.0 true true LabelStringVerb
end } def

/HexBlackLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def 
    i j HexBlackPiece
    i j str strlen 1.0 true true LabelStringVerb
end } def

/AbsCoordX { 1 dict begin /x exch def
    OriginX x Scale mul add
end } def

/AbsCoordY { 1 dict begin /y exch def
    OriginY y Scale mul add
end } def

/DrawBox { /maxy exch def /maxx exch def /miny exch def /minx exch def
    newpath
    minx miny moveto
    maxx minx sub 0 rlineto
    0 maxy miny sub rlineto
    minx maxx sub 0 rlineto
    0 miny maxy sub rlineto
    HexLineWidth setlinewidth
    0 setgray
    stroke
} def

/HexVertex { 2 dict begin /j exch def /i exch def
    i j GraphVertexSize HexDot
end } def

/HexLine { 4 dict begin /j2 exch def /i2 exch def /j1 exch def /i1 exch def
    GraphLineWidth setlinewidth
    0 setgray
    newpath
    i1 j1 HexCenterPoint moveto
    i2 j2 HexCenterPoint lineto
    stroke
end } def

%%---------------- Program -------------------


FlatTopBoard
DrawHexBoard
1 HexBoardBorders


%------------ Trailer --------------

showpage

%%EndDocument
 @endspecial 1900 w @beginspecial 0 @llx 0 @lly 66 @urx
47 @ury 1133 @rwi @setspecial
%%BeginDocument: fz/pix/4x4.eps
%!PS-Adobe-3.0
%%Creator: Jack van Rijswijck, thanks to Cameron Browne
%%BoundingBox: 0 0 66 47
%%Pages: 0
%%EndComments

/OriginX -6 def
/OriginY 36 def
%---------------- Variables -------------------

/DimX 4 def
/DimY 4 def
/Scale 1.2 def


% draw  Hex boards, any size ... but labels only up to 26x26
% based on code by Cameron Browne, revised by Jack vR, revised by RBH
%-------------- state initializations -------------------------
1 setlinejoin   % lines meet at a point  ==>    use round join
%---------------- constants -------------------
/Root3Div2  0.86602540378444 def
/Chars   {[(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)
           (n)(o)(p)(q)(r)(s)(t)(u)(v)(w)(x)(y)(z)]} def
/CharsUC {[(A)(B)(C)(D)(E)(F)(G)(H)(I)(J)(K)(L)(M)
           (N)(O)(P)(Q)(R)(S)(T)(U)(V)(W)(X)(Y)(Z)]} def
/Digits  {[(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)(12)(13)
           (14)(15)(16)(17)(18)(19)(20)(21)(22)(23)(24)(25)(26)]} def
/HexRadius      5 Scale mul def % hexagon center-to-corner distance 
/HexLineWidth 0.1 Scale mul def 
/GraphVertexSize 1.0 Scale mul def
/GraphLineWidth 0.5 Scale mul def
/CircleRadius 3.0 Scale mul def 
/CircleLineWidth 0.346 Scale mul def 
/PerimeterWidth 0.5 Scale mul def 
/TextHeight 4.5 def
/TextWidth TextHeight 0.45 mul def 
/BoardShade 0.8 def
/CoordinatesShade 0.5 def
/MarkerSize 1.2 def
/CellOrientation 1 def   % 1: flat bottom  0: pointed bottom
/CellCorner [ % 6 cell corners, wrt center 0 0, plus "up" and "down"
   [ HexRadius  neg       0                           ] 
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul neg ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul neg ]
   [ HexRadius            0                           ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul     ]
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul neg ]
] def
%----- name cell corner indices ... see below
/Left  0 def /DownLeft 1 def /DownRight 2 def 
/Right 3 def /UpRight  4 def /UpLeft    5 def 
/Up    6 def /Down     7 def
%-----------------------------------------------------
% cell orientations:  flat bottom    flat side
%-----------------------------------------------------
% flat bottom 
% board cell indices            cell corner/top/bottom indices
%             --
%           /    \
%        --   1,3  --                  5 -6- 4
%      /    \    /    \               /       \
%   --   1,2  --   2,3  --           0         3
% /    \    /    \    /    \          \       /
%   1,1  --   2,2  --   3,3            1 -7- 2
% \    /    \    /    \    /
%   --   2,1  --   3,2  --
%      \    /    \    /   
%        --   3,1  --     
%----------------------------------------------------
% flat side 
%    /  \  /  \  /  \                       5
%   | 11 || 12 || 13 ||                   /   6
%    \  /  \  /  \  /  \                 0     4
%     || 21 || 22 || 23 |                |     |
%       \  /  \  /  \  /  \              1     3
%        || 31 || 32 || 33 |              7   /
%-------------------------------------------2--------
%----------- procedures -------------
/ScalePoint { % stack: ... x y size ==> ...  x*size y*size
   3 dict begin /size exch def /y exch def /x exch def
   x size mul           y size mul
end } def

/FlatTopBoard { FlatSideCells } def

/FlatSideCells {  % redefine cell orientation for flat side
  /CellOrientation 0 def   
  /CellCorner [ % 6 cell corners, wrt center 0 0  %xcoord ycoord
    [HexRadius Root3Div2 mul neg  HexRadius 2 div     ]
    [HexRadius Root3Div2 mul neg  HexRadius 2 div neg ]
    [0                            HexRadius neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div ]
    [0                            HexRadius ]
    [HexRadius Root3Div2 2 div mul HexRadius 0.75 mul ]
    [HexRadius Root3Div2 2 div mul neg HexRadius 0.75 mul neg ]
  ] def
} def

/HexCenterPoint { % center of cell (i,j)
    2 dict begin /j exch def /i exch def
    CellOrientation 1 eq {
    OriginX i j add HexRadius mul 1.5 mul add %Ox + (i+j)*HR*1.5
    OriginY i j sub HexRadius mul Root3Div2 mul sub %Oy - (i-j)*HR*R3/2
    }{
    OriginX i 2 j mul add HexRadius mul Root3Div2 mul add  %Ox + (2i+j)*HR
    OriginY i 1 sub HexRadius mul 1.5 mul sub %Oy - i*HR*R3/2
    } ifelse
end } def
 
/HexLine { % a b c d
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint lineto
    stroke
} def

/HexCurve { % a b c d e f
    /f exch def
    /e exch def
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint e f HexCenterPoint HexRadius 2 mul arcto
    e f HexCenterPoint lineto
    stroke
} def

/HxgnCorner { 5 dict begin /corn exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    x CellCorner corn get 0 get add
    y CellCorner corn get 1 get add
end } def

/Go { 2 dict begin /corn exch def /mag exch def
   % rlineto in a cell orientation direction
   CellCorner corn get aload pop mag ScalePoint rlineto
end } def

/TurnGo { rotate 1.0 Left Go } def % call: degrees TurnGo
/MagTurnGo { rotate Left Go } def % call: mag degrees TurnGo

/HexagonPath { % call: i j HexagonPath
    newpath 
    UpRight HxgnCorner moveto 
    6 { 1.0 Left Go 60 rotate } repeat 
} def

/FillAndStroke { 2 dict begin /sh exch def /wdth exch def
    gsave sh setgray fill
    grestore 0 setgray wdth setlinewidth stroke
end } def

/ShadedHexagon { 3 dict begin /shade exch def /j exch def /i exch def
    i j HexagonPath
    0 shade FillAndStroke
end } def

/Hexagon { % stack: ... i j
    HexagonPath 
    HexLineWidth BoardShade FillAndStroke
} def

/SemiHexagonPath { % stack: ... top i j
    newpath 
    1 eq { Left HxgnCorner moveto 
        1.0 UpRight Go 1.0 Right Go 1.0 DownRight Go stroke }{
        Right HxgnCorner moveto 
        1.0 DownLeft Go 1.0 Left Go 1.0 UpLeft Go stroke
    } ifelse
} def

/HexBoardPerimeter {
    newpath
    1 DimY UpRight HxgnCorner moveto 1.0 Left Go                      
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 rotate %restore rotation
} def

%----------- Havannah coordinates ----------------------
%                   ..  ..  ..
%                 d1  c2  b3  a4
%                   c1  b2  a3
%                     b1  a2
%                       a1
/HavannahPosn { % convert to usual coordinate, so ... x y  =>  ... 1+DimX-x  y
    exch DimX 1 add exch sub exch 
} def

/HavannahBoardPerimeter {
    newpath
    1 DimX UpRight HxgnCorner moveto 1.0 Left Go                      
    6 {Base 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo } repeat
} def

/DrawHexBoard { 2 dict begin
    gsave
    HexBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexPLBoard { 6 dict begin %point-line board
    gsave
    BoardShade setgray newpath
    -1 DimY 1 add 0.5 mul HexCenterPoint moveto
    1 DimY HexCenterPoint lineto
    DimX 1 add 0.5 mul DimY 2 add HexCenterPoint lineto
    DimX DimY HexCenterPoint lineto
    DimX 2 add DimY 1 add 0.5 mul HexCenterPoint lineto
    DimX 1 HexCenterPoint lineto
    DimX 1 add 0.5 mul -1 HexCenterPoint lineto
    1 1 HexCenterPoint lineto
    closepath fill 0 setgray
    1 DimY HexCenterPoint moveto
    1 1 DimX { /i exch def 
        i 1 i DimY HexLine 
        DimY 1 add 0.5 mul -1 i 1 HexLine
        DimY 1 add 0.5 mul DimY 2 add i DimY HexLine } for
    1 1 DimY { /j exch def 
        1 j DimX j HexLine 
        -1 DimX 1 add 0.5 mul 1 j HexLine
        DimX 2 add DimX 1 add 0.5 mul DimX j HexLine } for
    /topx 1 def /topy 1 def /btmx 1 def /btmy 1 def
    DimX DimY add 3 sub {
      topx DimX lt {/topx 1 topx add def}{/topy 1 topy add def} ifelse 
      btmy DimY lt {/btmy 1 btmy add def}{/btmx 1 btmx add def} ifelse 
      topx topy btmx btmy HexLine
      } repeat
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j HexVertex
	} for } for
    grestore
end } def

/DrawHavannahBoard { 3 dict begin
    /Base DimX 1 add 2 idiv  def
    gsave
    HavannahBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 Base { /j exch def
	Base j 1 sub sub 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    1 1 Base 1 sub { /j exch def
	1 1 DimX j sub { /i exch def
	   i j Base add 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexBorder{ 6 dict begin /start exch def 
    /cells exch def /isBlack exch def /which exch def
    gsave
    which UpLeft eq {1 DimY 1 add start sub Up HxgnCorner moveto /d Left def /r 60 def} if
    which UpRight eq {start DimY Up HxgnCorner moveto /d Right def /r 300 def} if
    which DownLeft eq {DimX 1 add start sub 1 Down HxgnCorner moveto /d Left def /r 300 def} if
    which DownRight eq {DimX start Down HxgnCorner moveto /d Right def /r 60 def} if
    0.5 d Go 
    which UpRight eq which DownRight eq or {180 rotate} if
    r TurnGo 
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.5 360 r sub MagTurnGo 1.5 360 r sub 2 mul MagTurnGo
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.75 360 r sub MagTurnGo
    closepath isBlack 1 eq {gsave fill grestore} if stroke grestore
end } def

/NoDrawHexBoard {  % dummy, used in creating bounding box
} def

/HexBoardBorders { 1 dict begin
    /upperLeftBlack exch def
    PerimeterWidth setlinewidth 0 setgray
    UpLeft    upperLeftBlack       DimY 1 DrawHexBorder
    UpRight   1 upperLeftBlack sub DimX 1 DrawHexBorder
    DownRight upperLeftBlack       DimY 1 DrawHexBorder
    DownLeft  1 upperLeftBlack sub DimX 1 DrawHexBorder
end } def

/YBoardPerimeter {
    newpath 1 1 DownRight HxgnCorner moveto 180 rotate
    3 { DimX 1 sub { 300 TurnGo 60 TurnGo } repeat 
        60 TurnGo 60 TurnGo} 
    repeat % now restore initial rotation state
    180 rotate % closepath
} def

/DrawYBoard { 2 dict begin
    YBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimX {/j exch def
        1 1 DimX 1 add j sub {/i exch def
	    i j 1 SemiHexagonPath stroke
        } for } for
end } def

/FontSelect { % bold italic FontSelect
    2 dict begin /italic exch def /bold exch def
    bold {
	italic 
	{ /Times-BoldItalic findfont TextHeight scalefont setfont } 
	{ /Times-Bold findfont TextHeight scalefont setfont }
	ifelse} 
        {
	italic {/Times-Italic findfont TextHeight scalefont setfont} 
	{ /Times findfont TextHeight scalefont setfont }
	ifelse}
    ifelse
end } def
	    
/LabelString {   % call: i j (str) strlen LabelString
%  to use with board rotation, remove comments
    6 dict begin /strlen exch def /str exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint /y exch def /x exch def
    %BoardRotation rotate
    x y moveto 
    %360 BoardRotation sub rotate
    TextWidth strlen mul 0.5 mul neg TextHeight 0.33 mul neg rmoveto
    str show 
end } def

/AbsLabelString { 4 dict begin
    /strlen exch def /str exch def /y exch def /x exch def
    newpath
    x AbsCoordX TextWidth strlen mul 0.5 mul sub
    y AbsCoordY TextHeight 0.33 mul sub
    moveto
    str
    show
end } def

/LabelStringVerb { % i j (str) strlen shade bold italic LabelStringVerb
    7 dict begin /italic exch def /bold exch def /shade exch def
    /strlen exch def /str exch def /j exch def /i exch def
    bold italic FontSelect shade setgray
    i j str strlen LabelString
end } def

/HexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimX { /i exch def
	i 0          Chars i 1 sub get 1 LabelString
	i DimY 1 add Chars i 1 sub get 1 LabelString
    } for
    1 1 DimY { /j exch def
	0 j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
	DimX 1 add j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HavannahBoardCoordinates { 3 dict begin
    false true FontSelect CoordinatesShade setgray
    /Base DimX 1 add 2 idiv  def
    1 1 Base { /i exch def
	i 0 HavannahPosn Chars  i 1 sub get 1 LabelString
	0 i HavannahPosn Digits i 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
    1 1 Base 1 sub { /i exch def
	i Base add i HavannahPosn Chars  i Base add 1 sub get 1 LabelString
	i i Base add HavannahPosn Digits i Base add 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/AltHexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimY { /j exch def
	0 j Chars j 1 sub get 1 LabelString
        %DimX 1 add j Chars j 1 sub get 1 LabelString
    } for
    1 1 DimX { /i exch def
	i 0 Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
	%i DimY 1 add Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HexDot { 3 dict begin /size exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint size 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexWhiteMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexWhitePiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexBlackMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexBlackPiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    1 setgray 0 setlinewidth fill
end } def

/HexDoubleMarker { 6 dict begin
    /shaderight exch def /shadeleft exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    gsave
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    shadeleft setgray 0 setlinewidth fill
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    shaderight setgray 0 setlinewidth fill
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    grestore
end } def

/HexBlackWhiteMarker { 0.0 1.0 HexDoubleMarker } def

/HexWhiteBlackMarker { 1.0 0.0 HexDoubleMarker } def
        
/HexMarker { 2 dict begin /j exch def /i exch def
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setlinewidth fill
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke  
end } def

/HexBlackMarker { 2 dict begin /j exch def /i exch def
    0 setgray
    i j HexMarker
end } def

/HexWhiteMarker { 2 dict begin /j exch def /i exch def
    1 setgray
    i j HexMarker
end } def
    
/HexPiece { 3 dict begin /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/MagicStone { 4 dict begin 
    /size exch def /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 1.3 mul size mul 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/HexWhitePiece { 1.0 HexPiece } def

/HexBlackPiece { 0.0 HexPiece } def

/HexWhiteLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def
    i j HexWhitePiece
    i j str strlen 0.0 true true LabelStringVerb
end } def

/HexBlackLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def 
    i j HexBlackPiece
    i j str strlen 1.0 true true LabelStringVerb
end } def

/AbsCoordX { 1 dict begin /x exch def
    OriginX x Scale mul add
end } def

/AbsCoordY { 1 dict begin /y exch def
    OriginY y Scale mul add
end } def

/DrawBox { /maxy exch def /maxx exch def /miny exch def /minx exch def
    newpath
    minx miny moveto
    maxx minx sub 0 rlineto
    0 maxy miny sub rlineto
    minx maxx sub 0 rlineto
    0 miny maxy sub rlineto
    HexLineWidth setlinewidth
    0 setgray
    stroke
} def

/HexVertex { 2 dict begin /j exch def /i exch def
    i j GraphVertexSize HexDot
end } def

/HexLine { 4 dict begin /j2 exch def /i2 exch def /j1 exch def /i1 exch def
    GraphLineWidth setlinewidth
    0 setgray
    newpath
    i1 j1 HexCenterPoint moveto
    i2 j2 HexCenterPoint lineto
    stroke
end } def

%%---------------- Program -------------------


FlatTopBoard
DrawHexBoard
1 HexBoardBorders


%------------ Trailer --------------

showpage

%%EndDocument
 @endspecial 1900 w @beginspecial 0 @llx 0 @lly 66 @urx
47 @ury 1133 @rwi @setspecial
%%BeginDocument: fz/pix/4x4.eps
%!PS-Adobe-3.0
%%Creator: Jack van Rijswijck, thanks to Cameron Browne
%%BoundingBox: 0 0 66 47
%%Pages: 0
%%EndComments

/OriginX -6 def
/OriginY 36 def
%---------------- Variables -------------------

/DimX 4 def
/DimY 4 def
/Scale 1.2 def


% draw  Hex boards, any size ... but labels only up to 26x26
% based on code by Cameron Browne, revised by Jack vR, revised by RBH
%-------------- state initializations -------------------------
1 setlinejoin   % lines meet at a point  ==>    use round join
%---------------- constants -------------------
/Root3Div2  0.86602540378444 def
/Chars   {[(a)(b)(c)(d)(e)(f)(g)(h)(i)(j)(k)(l)(m)
           (n)(o)(p)(q)(r)(s)(t)(u)(v)(w)(x)(y)(z)]} def
/CharsUC {[(A)(B)(C)(D)(E)(F)(G)(H)(I)(J)(K)(L)(M)
           (N)(O)(P)(Q)(R)(S)(T)(U)(V)(W)(X)(Y)(Z)]} def
/Digits  {[(1)(2)(3)(4)(5)(6)(7)(8)(9)(10)(11)(12)(13)
           (14)(15)(16)(17)(18)(19)(20)(21)(22)(23)(24)(25)(26)]} def
/HexRadius      5 Scale mul def % hexagon center-to-corner distance 
/HexLineWidth 0.1 Scale mul def 
/GraphVertexSize 1.0 Scale mul def
/GraphLineWidth 0.5 Scale mul def
/CircleRadius 3.0 Scale mul def 
/CircleLineWidth 0.346 Scale mul def 
/PerimeterWidth 0.5 Scale mul def 
/TextHeight 4.5 def
/TextWidth TextHeight 0.45 mul def 
/BoardShade 0.8 def
/CoordinatesShade 0.5 def
/MarkerSize 1.2 def
/CellOrientation 1 def   % 1: flat bottom  0: pointed bottom
/CellCorner [ % 6 cell corners, wrt center 0 0, plus "up" and "down"
   [ HexRadius  neg       0                           ] 
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul neg ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul neg ]
   [ HexRadius            0                           ]
   [ HexRadius 2 div      HexRadius Root3Div2 mul     ]
   [ HexRadius 2 div neg  HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul     ]
   [ 0                    HexRadius Root3Div2 mul neg ]
] def
%----- name cell corner indices ... see below
/Left  0 def /DownLeft 1 def /DownRight 2 def 
/Right 3 def /UpRight  4 def /UpLeft    5 def 
/Up    6 def /Down     7 def
%-----------------------------------------------------
% cell orientations:  flat bottom    flat side
%-----------------------------------------------------
% flat bottom 
% board cell indices            cell corner/top/bottom indices
%             --
%           /    \
%        --   1,3  --                  5 -6- 4
%      /    \    /    \               /       \
%   --   1,2  --   2,3  --           0         3
% /    \    /    \    /    \          \       /
%   1,1  --   2,2  --   3,3            1 -7- 2
% \    /    \    /    \    /
%   --   2,1  --   3,2  --
%      \    /    \    /   
%        --   3,1  --     
%----------------------------------------------------
% flat side 
%    /  \  /  \  /  \                       5
%   | 11 || 12 || 13 ||                   /   6
%    \  /  \  /  \  /  \                 0     4
%     || 21 || 22 || 23 |                |     |
%       \  /  \  /  \  /  \              1     3
%        || 31 || 32 || 33 |              7   /
%-------------------------------------------2--------
%----------- procedures -------------
/ScalePoint { % stack: ... x y size ==> ...  x*size y*size
   3 dict begin /size exch def /y exch def /x exch def
   x size mul           y size mul
end } def

/FlatTopBoard { FlatSideCells } def

/FlatSideCells {  % redefine cell orientation for flat side
  /CellOrientation 0 def   
  /CellCorner [ % 6 cell corners, wrt center 0 0  %xcoord ycoord
    [HexRadius Root3Div2 mul neg  HexRadius 2 div     ]
    [HexRadius Root3Div2 mul neg  HexRadius 2 div neg ]
    [0                            HexRadius neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div neg ]
    [HexRadius Root3Div2 mul      HexRadius 2 div ]
    [0                            HexRadius ]
    [HexRadius Root3Div2 2 div mul HexRadius 0.75 mul ]
    [HexRadius Root3Div2 2 div mul neg HexRadius 0.75 mul neg ]
  ] def
} def

/HexCenterPoint { % center of cell (i,j)
    2 dict begin /j exch def /i exch def
    CellOrientation 1 eq {
    OriginX i j add HexRadius mul 1.5 mul add %Ox + (i+j)*HR*1.5
    OriginY i j sub HexRadius mul Root3Div2 mul sub %Oy - (i-j)*HR*R3/2
    }{
    OriginX i 2 j mul add HexRadius mul Root3Div2 mul add  %Ox + (2i+j)*HR
    OriginY i 1 sub HexRadius mul 1.5 mul sub %Oy - i*HR*R3/2
    } ifelse
end } def
 
/HexLine { % a b c d
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint lineto
    stroke
} def

/HexCurve { % a b c d e f
    /f exch def
    /e exch def
    /d exch def
    /c exch def
    /b exch def
    /a exch def
    newpath
    a b HexCenterPoint moveto
    c d HexCenterPoint e f HexCenterPoint HexRadius 2 mul arcto
    e f HexCenterPoint lineto
    stroke
} def

/HxgnCorner { 5 dict begin /corn exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    x CellCorner corn get 0 get add
    y CellCorner corn get 1 get add
end } def

/Go { 2 dict begin /corn exch def /mag exch def
   % rlineto in a cell orientation direction
   CellCorner corn get aload pop mag ScalePoint rlineto
end } def

/TurnGo { rotate 1.0 Left Go } def % call: degrees TurnGo
/MagTurnGo { rotate Left Go } def % call: mag degrees TurnGo

/HexagonPath { % call: i j HexagonPath
    newpath 
    UpRight HxgnCorner moveto 
    6 { 1.0 Left Go 60 rotate } repeat 
} def

/FillAndStroke { 2 dict begin /sh exch def /wdth exch def
    gsave sh setgray fill
    grestore 0 setgray wdth setlinewidth stroke
end } def

/ShadedHexagon { 3 dict begin /shade exch def /j exch def /i exch def
    i j HexagonPath
    0 shade FillAndStroke
end } def

/Hexagon { % stack: ... i j
    HexagonPath 
    HexLineWidth BoardShade FillAndStroke
} def

/SemiHexagonPath { % stack: ... top i j
    newpath 
    1 eq { Left HxgnCorner moveto 
        1.0 UpRight Go 1.0 Right Go 1.0 DownRight Go stroke }{
        Right HxgnCorner moveto 
        1.0 DownLeft Go 1.0 Left Go 1.0 UpLeft Go stroke
    } ifelse
} def

/HexBoardPerimeter {
    newpath
    1 DimY UpRight HxgnCorner moveto 1.0 Left Go                      
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 
    DimY 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo 60 TurnGo
    DimX 1 sub { 60 TurnGo 300 TurnGo } repeat 60 rotate %restore rotation
} def

%----------- Havannah coordinates ----------------------
%                   ..  ..  ..
%                 d1  c2  b3  a4
%                   c1  b2  a3
%                     b1  a2
%                       a1
/HavannahPosn { % convert to usual coordinate, so ... x y  =>  ... 1+DimX-x  y
    exch DimX 1 add exch sub exch 
} def

/HavannahBoardPerimeter {
    newpath
    1 DimX UpRight HxgnCorner moveto 1.0 Left Go                      
    6 {Base 1 sub { 60 TurnGo 300 TurnGo } repeat 60 TurnGo } repeat
} def

/DrawHexBoard { 2 dict begin
    gsave
    HexBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexPLBoard { 6 dict begin %point-line board
    gsave
    BoardShade setgray newpath
    -1 DimY 1 add 0.5 mul HexCenterPoint moveto
    1 DimY HexCenterPoint lineto
    DimX 1 add 0.5 mul DimY 2 add HexCenterPoint lineto
    DimX DimY HexCenterPoint lineto
    DimX 2 add DimY 1 add 0.5 mul HexCenterPoint lineto
    DimX 1 HexCenterPoint lineto
    DimX 1 add 0.5 mul -1 HexCenterPoint lineto
    1 1 HexCenterPoint lineto
    closepath fill 0 setgray
    1 DimY HexCenterPoint moveto
    1 1 DimX { /i exch def 
        i 1 i DimY HexLine 
        DimY 1 add 0.5 mul -1 i 1 HexLine
        DimY 1 add 0.5 mul DimY 2 add i DimY HexLine } for
    1 1 DimY { /j exch def 
        1 j DimX j HexLine 
        -1 DimX 1 add 0.5 mul 1 j HexLine
        DimX 2 add DimX 1 add 0.5 mul DimX j HexLine } for
    /topx 1 def /topy 1 def /btmx 1 def /btmy 1 def
    DimX DimY add 3 sub {
      topx DimX lt {/topx 1 topx add def}{/topy 1 topy add def} ifelse 
      btmy DimY lt {/btmy 1 btmy add def}{/btmx 1 btmx add def} ifelse 
      topx topy btmx btmy HexLine
      } repeat
    1 1 DimY { /j exch def
	1 1 DimX { /i exch def
	   i j HexVertex
	} for } for
    grestore
end } def

/DrawHavannahBoard { 3 dict begin
    /Base DimX 1 add 2 idiv  def
    gsave
    HavannahBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 Base { /j exch def
	Base j 1 sub sub 1 DimX { /i exch def
	   i j 1 SemiHexagonPath stroke
	} for } for
    1 1 Base 1 sub { /j exch def
	1 1 DimX j sub { /i exch def
	   i j Base add 1 SemiHexagonPath stroke
	} for } for
    grestore
end } def

/DrawHexBorder{ 6 dict begin /start exch def 
    /cells exch def /isBlack exch def /which exch def
    gsave
    which UpLeft eq {1 DimY 1 add start sub Up HxgnCorner moveto /d Left def /r 60 def} if
    which UpRight eq {start DimY Up HxgnCorner moveto /d Right def /r 300 def} if
    which DownLeft eq {DimX 1 add start sub 1 Down HxgnCorner moveto /d Left def /r 300 def} if
    which DownRight eq {DimX start Down HxgnCorner moveto /d Right def /r 60 def} if
    0.5 d Go 
    which UpRight eq which DownRight eq or {180 rotate} if
    r TurnGo 
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.5 360 r sub MagTurnGo 1.5 360 r sub 2 mul MagTurnGo
    cells 1 sub {360 r sub TurnGo r TurnGo} repeat
    0.75 360 r sub MagTurnGo
    closepath isBlack 1 eq {gsave fill grestore} if stroke grestore
end } def

/NoDrawHexBoard {  % dummy, used in creating bounding box
} def

/HexBoardBorders { 1 dict begin
    /upperLeftBlack exch def
    PerimeterWidth setlinewidth 0 setgray
    UpLeft    upperLeftBlack       DimY 1 DrawHexBorder
    UpRight   1 upperLeftBlack sub DimX 1 DrawHexBorder
    DownRight upperLeftBlack       DimY 1 DrawHexBorder
    DownLeft  1 upperLeftBlack sub DimX 1 DrawHexBorder
end } def

/YBoardPerimeter {
    newpath 1 1 DownRight HxgnCorner moveto 180 rotate
    3 { DimX 1 sub { 300 TurnGo 60 TurnGo } repeat 
        60 TurnGo 60 TurnGo} 
    repeat % now restore initial rotation state
    180 rotate % closepath
} def

/DrawYBoard { 2 dict begin
    YBoardPerimeter 
    PerimeterWidth BoardShade FillAndStroke
    HexLineWidth setlinewidth
    1 1 DimX {/j exch def
        1 1 DimX 1 add j sub {/i exch def
	    i j 1 SemiHexagonPath stroke
        } for } for
end } def

/FontSelect { % bold italic FontSelect
    2 dict begin /italic exch def /bold exch def
    bold {
	italic 
	{ /Times-BoldItalic findfont TextHeight scalefont setfont } 
	{ /Times-Bold findfont TextHeight scalefont setfont }
	ifelse} 
        {
	italic {/Times-Italic findfont TextHeight scalefont setfont} 
	{ /Times findfont TextHeight scalefont setfont }
	ifelse}
    ifelse
end } def
	    
/LabelString {   % call: i j (str) strlen LabelString
%  to use with board rotation, remove comments
    6 dict begin /strlen exch def /str exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint /y exch def /x exch def
    %BoardRotation rotate
    x y moveto 
    %360 BoardRotation sub rotate
    TextWidth strlen mul 0.5 mul neg TextHeight 0.33 mul neg rmoveto
    str show 
end } def

/AbsLabelString { 4 dict begin
    /strlen exch def /str exch def /y exch def /x exch def
    newpath
    x AbsCoordX TextWidth strlen mul 0.5 mul sub
    y AbsCoordY TextHeight 0.33 mul sub
    moveto
    str
    show
end } def

/LabelStringVerb { % i j (str) strlen shade bold italic LabelStringVerb
    7 dict begin /italic exch def /bold exch def /shade exch def
    /strlen exch def /str exch def /j exch def /i exch def
    bold italic FontSelect shade setgray
    i j str strlen LabelString
end } def

/HexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimX { /i exch def
	i 0          Chars i 1 sub get 1 LabelString
	i DimY 1 add Chars i 1 sub get 1 LabelString
    } for
    1 1 DimY { /j exch def
	0 j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
	DimX 1 add j Digits j 1 sub get DimY 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HavannahBoardCoordinates { 3 dict begin
    false true FontSelect CoordinatesShade setgray
    /Base DimX 1 add 2 idiv  def
    1 1 Base { /i exch def
	i 0 HavannahPosn Chars  i 1 sub get 1 LabelString
	0 i HavannahPosn Digits i 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
    1 1 Base 1 sub { /i exch def
	i Base add i HavannahPosn Chars  i Base add 1 sub get 1 LabelString
	i i Base add HavannahPosn Digits i Base add 1 sub get 
	    DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/AltHexBoardCoordinates { 2 dict begin
    false true FontSelect CoordinatesShade setgray
    1 1 DimY { /j exch def
	0 j Chars j 1 sub get 1 LabelString
        %DimX 1 add j Chars j 1 sub get 1 LabelString
    } for
    1 1 DimX { /i exch def
	i 0 Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
	%i DimY 1 add Digits i 1 sub get DimX 9 gt {2} {1} ifelse LabelString
    } for
end } def

/HexDot { 3 dict begin /size exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint size 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexWhiteMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexWhitePiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray 0 setlinewidth fill
end } def

/HexBlackMarkedPiece { 2 dict begin /j exch def /i exch def 
    i j HexBlackPiece 
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    1 setgray 0 setlinewidth fill
end } def

/HexDoubleMarker { 6 dict begin
    /shaderight exch def /shadeleft exch def /j exch def /i exch def
    i j HexCenterPoint /y exch def /x exch def
    gsave
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    shadeleft setgray 0 setlinewidth fill
    newpath
    x MarkerSize sub y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    shaderight setgray 0 setlinewidth fill
    newpath
    x MarkerSize add y MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke
    grestore
end } def

/HexBlackWhiteMarker { 0.0 1.0 HexDoubleMarker } def

/HexWhiteBlackMarker { 1.0 0.0 HexDoubleMarker } def
        
/HexMarker { 2 dict begin /j exch def /i exch def
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setlinewidth fill
    newpath
    i j HexCenterPoint MarkerSize 0 360 arc
    0 setgray CircleLineWidth setlinewidth stroke  
end } def

/HexBlackMarker { 2 dict begin /j exch def /i exch def
    0 setgray
    i j HexMarker
end } def

/HexWhiteMarker { 2 dict begin /j exch def /i exch def
    1 setgray
    i j HexMarker
end } def
    
/HexPiece { 3 dict begin /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/MagicStone { 4 dict begin 
    /size exch def /shade exch def /j exch def /i exch def
    newpath
    i j HexCenterPoint CircleRadius 1.3 mul size mul 0 360 arc
    CircleLineWidth shade FillAndStroke
end } def

/HexWhitePiece { 1.0 HexPiece } def

/HexBlackPiece { 0.0 HexPiece } def

/HexWhiteLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def
    i j HexWhitePiece
    i j str strlen 0.0 true true LabelStringVerb
end } def

/HexBlackLabelledPiece { % i j (str) strlen
    4 dict begin /strlen exch def /str exch def /j exch def /i exch def 
    i j HexBlackPiece
    i j str strlen 1.0 true true LabelStringVerb
end } def

/AbsCoordX { 1 dict begin /x exch def
    OriginX x Scale mul add
end } def

/AbsCoordY { 1 dict begin /y exch def
    OriginY y Scale mul add
end } def

/DrawBox { /maxy exch def /maxx exch def /miny exch def /minx exch def
    newpath
    minx miny moveto
    maxx minx sub 0 rlineto
    0 maxy miny sub rlineto
    minx maxx sub 0 rlineto
    0 miny maxy sub rlineto
    HexLineWidth setlinewidth
    0 setgray
    stroke
} def

/HexVertex { 2 dict begin /j exch def /i exch def
    i j GraphVertexSize HexDot
end } def

/HexLine { 4 dict begin /j2 exch def /i2 exch def /j1 exch def /i1 exch def
    GraphLineWidth setlinewidth
    0 setgray
    newpath
    i1 j1 HexCenterPoint moveto
    i2 j2 HexCenterPoint lineto
    stroke
end } def

%%---------------- Program -------------------


FlatTopBoard
DrawHexBoard
1 HexBoardBorders


%------------ Trailer --------------

showpage

%%EndDocument
 @endspecial Black Black eop end
%%Trailer

userdict /end-hook known{end-hook}if
%%EOF
